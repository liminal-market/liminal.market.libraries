var WalletType;
(function (WalletType) {
    WalletType["Metamask"] = "metamask";
    WalletType["WalletConnect"] = "walletConnect";
    WalletType["CoinbaseWallet"] = "coinbase";
    WalletType["Web3Auth"] = "web3Auth";
    WalletType["MagicLink"] = "MagicLink";
    WalletType["Unknown"] = "unknown";
})(WalletType || (WalletType = {}));

class ProviderInfo {
    web3Provider;
    ProviderName = 'unknown';
    WalletName = '';
    WalletUrl = '';
    WalletType = WalletType.Unknown;
    UserAddress = '';
    InternalWallet = false;
    static Instance;
    constructor(web3Provider) {
        if (!web3Provider || !web3Provider.provider)
            return;
        this.web3Provider = web3Provider;
        if (this.web3Provider.connection && this.web3Provider.connection.url == 'metamask') {
            this.loadMetamask(web3Provider);
        }
        else if (this.web3Provider.provider.wc) {
            this.loadWalletConnect(web3Provider);
        }
        else if (this.web3Provider.provider.isMagic) {
            this.loadMagicConnect(web3Provider);
        }
        else {
            this.loadCustom(web3Provider);
        }
        ProviderInfo.Instance = this;
    }
    loadMetamask(walletConnectionInfo) {
        this.ProviderName = 'metamask';
        this.WalletName = "Metamask";
        this.WalletUrl = 'https://metamask.io/';
        this.WalletType = WalletType.Metamask;
        this.UserAddress = walletConnectionInfo.provider.selectedAddress;
    }
    loadWalletConnect(walletConnectionInfo) {
        let wc = walletConnectionInfo.provider.wc;
        this.ProviderName = "walletConnect";
        this.WalletName = wc._peerMeta.name;
        this.WalletUrl = wc._peerMeta.url ?? '';
        this.WalletType = WalletType.WalletConnect;
    }
    loadCustom(provider) {
        this.ProviderName = 'web3auth';
        this.WalletName = 'Torus';
        this.WalletUrl = 'https://app.tor.us/';
        this.WalletType = WalletType.Web3Auth;
    }
    loadMagicConnect(walletConnectionInfo) {
        this.ProviderName = 'MagicLink';
        this.WalletName = 'MagicLink';
        this.WalletType = WalletType.MagicLink;
        this.InternalWallet = true;
    }
}

class CookieHelper {
    document;
    constructor(doc) {
        this.document = (doc) ? doc : document;
    }
    setCookie(name, value) {
        let date = new Date();
        this.deleteCookie(name);
        this.document.cookie = name + "=" + value + "; expires=Mon, 2 Dec " + (date.getFullYear() + 1) + " 12:00:00 UTC;path=/;SameSite=Strict;";
    }
    getCookieValue(name) {
        return this.document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)')?.pop() || '';
    }
    setCookieProvider(providerName) {
        this.setCookie("provider", providerName);
    }
    deleteCookie(name) {
        this.document.cookie = name + "=0; expires=Mon, 2 Dec 2020 12:00:00 UTC;path=/";
    }
}

class User {
    provider;
    chainId;
    ether;
    email;
    providerInfo;
    alpacaId;
    address;
    magic;
    connector;
    _token = "";
    isLoggedIn = false;
    signer;
    constructor(provider, address, chainId, ether) {
        this.provider = provider;
        this.address = address;
        this.chainId = chainId;
        this.ether = ether;
        this.providerInfo = new ProviderInfo(provider);
        this.email = "";
        let cookieHelper = new CookieHelper();
        this._token = cookieHelper.getCookieValue("token");
    }
    get token() {
        return this._token;
    }
    set token(value) {
        this._token = value;
    }
    setValidate(validate) {
        let base64 = btoa(JSON.stringify(validate));
        let cookieHelper = new CookieHelper();
        cookieHelper.setCookie("validate", base64);
    }
}

var SwitchNetworkHtml = "<div id=\"switchNetworkInfo\">\n    You can choose any of these networks.\n    <!--\n    <div>\n        <h3>Mainnet - real money & stocks</h3>\n        {{#each mainNetworks}}\n        <button href=\"\" class=\"setNetwork\"\n                data-chainid=\"{{ChainId}}\">{{ChainName}}\n        </button>\n        {{/each}}\n    </div>-->\n    <div>\n        <h3>Testnet - fake money & stocks</h3>\n        {{#each testNetworks}}\n        <button href=\"\" class=\"setNetwork\" data-chainid=\"{{ChainId}}\">{{ChainName}}\n        </button>\n        {{/each}}\n    </div>\n</div>\n<div id=\"jsSwitchNetworkNotWorking\" class=\"d-none\">\n    It seem as we can't add the network automatically for your, so you need to add it your self.\n    This is the information you need to add the network. You will need to figure out where to\n    add new network for your wallet, as it difference between wallets.\n    <form>\n        <label>ChainId:\n            <input id=\"switchChainId\">\n        </label>\n        <label>Chain name\n            <input id=\"switchChainName\">\n        </label>\n        <label>Currency name\n            <input id=\"switchCurrencyName\">\n        </label>\n        <label>\n            Symbol\n            <input id=\"switchSymbol\">\n        </label>\n        <label>Decimal\n            <input id=\"switchDecimal\">\n        </label>\n        <label>Rpc Url\n            <input id=\"switchRpcUrl\">\n        </label>\n    </form>\n</div>";

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire$1(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var handlebarsExports = {};
var handlebars$1 = {
  get exports(){ return handlebarsExports; },
  set exports(v){ handlebarsExports = v; },
};

var handlebars_runtimeExports = {};
var handlebars_runtime = {
  get exports(){ return handlebars_runtimeExports; },
  set exports(v){ handlebars_runtimeExports = v; },
};

var base$2 = {};

var utils$c = {};

utils$c.__esModule = true;
utils$c.extend = extend;
utils$c.indexOf = indexOf;
utils$c.escapeExpression = escapeExpression;
utils$c.isEmpty = isEmpty;
utils$c.createFrame = createFrame;
utils$c.blockParams = blockParams;
utils$c.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};
var badChars = /[&<>"'`=]/g,
  possible = /[&<>"'`=]/;
function escapeChar$1(chr) {
  return escape[chr];
}
function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }
  return obj;
}
var toString$1 = Object.prototype.toString;
utils$c.toString = toString$1;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction$1 = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction$1(/x/)) {
  utils$c.isFunction = isFunction$1 = function (value) {
    return typeof value === 'function' && toString$1.call(value) === '[object Function]';
  };
}
utils$c.isFunction = isFunction$1;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray$2 = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString$1.call(value) === '[object Array]' : false;
};
utils$c.isArray = isArray$2;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}
function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }
  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar$1);
}
function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray$2(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}
function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}
function blockParams(params, ids) {
  params.path = ids;
  return params;
}
function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}

var exceptionExports = {};
var exception = {
  get exports(){ return exceptionExports; },
  set exports(v){ exceptionExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];
  function Exception(message, node) {
    var loc = node && node.loc,
      line = undefined,
      endLineNumber = undefined,
      column = undefined,
      endColumn = undefined;
    if (loc) {
      line = loc.start.line;
      endLineNumber = loc.end.line;
      column = loc.start.column;
      endColumn = loc.end.column;
      message += ' - ' + line + ':' + column;
    }
    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    /* istanbul ignore else */
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }
    try {
      if (loc) {
        this.lineNumber = line;
        this.endLineNumber = endLineNumber;

        // Work around issue under safari where we can't directly set the column value
        /* istanbul ignore next */
        if (Object.defineProperty) {
          Object.defineProperty(this, 'column', {
            value: column,
            enumerable: true
          });
          Object.defineProperty(this, 'endColumn', {
            value: endColumn,
            enumerable: true
          });
        } else {
          this.column = column;
          this.endColumn = endColumn;
        }
      }
    } catch (nop) {
      /* Ignore if the browser is very particular */
    }
  }
  Exception.prototype = new Error();
  exports['default'] = Exception;
  module.exports = exports['default'];
})(exception, exceptionExports);

var helpers$1 = {};

var blockHelperMissingExports = {};
var blockHelperMissing = {
  get exports(){ return blockHelperMissingExports; },
  set exports(v){ blockHelperMissingExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  var _utils = utils$c;
  exports['default'] = function (instance) {
    instance.registerHelper('blockHelperMissing', function (context, options) {
      var inverse = options.inverse,
        fn = options.fn;
      if (context === true) {
        return fn(this);
      } else if (context === false || context == null) {
        return inverse(this);
      } else if (_utils.isArray(context)) {
        if (context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }
          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = _utils.createFrame(options.data);
          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
          options = {
            data: data
          };
        }
        return fn(context, options);
      }
    });
  };
  module.exports = exports['default'];
})(blockHelperMissing, blockHelperMissingExports);

var eachExports = {};
var each = {
  get exports(){ return eachExports; },
  set exports(v){ eachExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
  var _utils = utils$c;
  var _exception = exceptionExports;
  var _exception2 = _interopRequireDefault(_exception);
  exports['default'] = function (instance) {
    instance.registerHelper('each', function (context, options) {
      if (!options) {
        throw new _exception2['default']('Must pass iterator to #each');
      }
      var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;
      if (options.data && options.ids) {
        contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
      }
      if (_utils.isFunction(context)) {
        context = context.call(this);
      }
      if (options.data) {
        data = _utils.createFrame(options.data);
      }
      function execIteration(field, index, last) {
        if (data) {
          data.key = field;
          data.index = index;
          data.first = index === 0;
          data.last = !!last;
          if (contextPath) {
            data.contextPath = contextPath + field;
          }
        }
        ret = ret + fn(context[field], {
          data: data,
          blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
        });
      }
      if (context && typeof context === 'object') {
        if (_utils.isArray(context)) {
          for (var j = context.length; i < j; i++) {
            if (i in context) {
              execIteration(i, i, i === context.length - 1);
            }
          }
        } else if (commonjsGlobal.Symbol && context[commonjsGlobal.Symbol.iterator]) {
          var newContext = [];
          var iterator = context[commonjsGlobal.Symbol.iterator]();
          for (var it = iterator.next(); !it.done; it = iterator.next()) {
            newContext.push(it.value);
          }
          context = newContext;
          for (var j = context.length; i < j; i++) {
            execIteration(i, i, i === context.length - 1);
          }
        } else {
          (function () {
            var priorKey = undefined;
            Object.keys(context).forEach(function (key) {
              // We're running the iterations one step out of sync so we can detect
              // the last iteration without have to scan the object twice and create
              // an itermediate keys array.
              if (priorKey !== undefined) {
                execIteration(priorKey, i - 1);
              }
              priorKey = key;
              i++;
            });
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1, true);
            }
          })();
        }
      }
      if (i === 0) {
        ret = inverse(this);
      }
      return ret;
    });
  };
  module.exports = exports['default'];
})(each, eachExports);

var helperMissingExports = {};
var helperMissing = {
  get exports(){ return helperMissingExports; },
  set exports(v){ helperMissingExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
  var _exception = exceptionExports;
  var _exception2 = _interopRequireDefault(_exception);
  exports['default'] = function (instance) {
    instance.registerHelper('helperMissing', function () /* [args, ]options */{
      if (arguments.length === 1) {
        // A missing field in a {{foo}} construct.
        return undefined;
      } else {
        // Someone is actually trying to call something, blow up.
        throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      }
    });
  };
  module.exports = exports['default'];
})(helperMissing, helperMissingExports);

var _ifExports = {};
var _if = {
  get exports(){ return _ifExports; },
  set exports(v){ _ifExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
  var _utils = utils$c;
  var _exception = exceptionExports;
  var _exception2 = _interopRequireDefault(_exception);
  exports['default'] = function (instance) {
    instance.registerHelper('if', function (conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#if requires exactly one argument');
      }
      if (_utils.isFunction(conditional)) {
        conditional = conditional.call(this);
      }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });
    instance.registerHelper('unless', function (conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#unless requires exactly one argument');
      }
      return instance.helpers['if'].call(this, conditional, {
        fn: options.inverse,
        inverse: options.fn,
        hash: options.hash
      });
    });
  };
  module.exports = exports['default'];
})(_if, _ifExports);

var logExports = {};
var log$2 = {
  get exports(){ return logExports; },
  set exports(v){ logExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  exports['default'] = function (instance) {
    instance.registerHelper('log', function () /* message, options */{
      var args = [undefined],
        options = arguments[arguments.length - 1];
      for (var i = 0; i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }
      var level = 1;
      if (options.hash.level != null) {
        level = options.hash.level;
      } else if (options.data && options.data.level != null) {
        level = options.data.level;
      }
      args[0] = level;
      instance.log.apply(instance, args);
    });
  };
  module.exports = exports['default'];
})(log$2, logExports);

var lookupExports = {};
var lookup$1 = {
  get exports(){ return lookupExports; },
  set exports(v){ lookupExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  exports['default'] = function (instance) {
    instance.registerHelper('lookup', function (obj, field, options) {
      if (!obj) {
        // Note for 5.0: Change to "obj == null" in 5.0
        return obj;
      }
      return options.lookupProperty(obj, field);
    });
  };
  module.exports = exports['default'];
})(lookup$1, lookupExports);

var _withExports = {};
var _with = {
  get exports(){ return _withExports; },
  set exports(v){ _withExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
  var _utils = utils$c;
  var _exception = exceptionExports;
  var _exception2 = _interopRequireDefault(_exception);
  exports['default'] = function (instance) {
    instance.registerHelper('with', function (context, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#with requires exactly one argument');
      }
      if (_utils.isFunction(context)) {
        context = context.call(this);
      }
      var fn = options.fn;
      if (!_utils.isEmpty(context)) {
        var data = options.data;
        if (options.data && options.ids) {
          data = _utils.createFrame(options.data);
          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
        }
        return fn(context, {
          data: data,
          blockParams: _utils.blockParams([context], [data && data.contextPath])
        });
      } else {
        return options.inverse(this);
      }
    });
  };
  module.exports = exports['default'];
})(_with, _withExports);

helpers$1.__esModule = true;
helpers$1.registerDefaultHelpers = registerDefaultHelpers;
helpers$1.moveHelperToHooks = moveHelperToHooks;
// istanbul ignore next

function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _helpersBlockHelperMissing = blockHelperMissingExports;
var _helpersBlockHelperMissing2 = _interopRequireDefault$7(_helpersBlockHelperMissing);
var _helpersEach = eachExports;
var _helpersEach2 = _interopRequireDefault$7(_helpersEach);
var _helpersHelperMissing = helperMissingExports;
var _helpersHelperMissing2 = _interopRequireDefault$7(_helpersHelperMissing);
var _helpersIf = _ifExports;
var _helpersIf2 = _interopRequireDefault$7(_helpersIf);
var _helpersLog = logExports;
var _helpersLog2 = _interopRequireDefault$7(_helpersLog);
var _helpersLookup = lookupExports;
var _helpersLookup2 = _interopRequireDefault$7(_helpersLookup);
var _helpersWith = _withExports;
var _helpersWith2 = _interopRequireDefault$7(_helpersWith);
function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}
function moveHelperToHooks(instance, helperName, keepHelper) {
  if (instance.helpers[helperName]) {
    instance.hooks[helperName] = instance.helpers[helperName];
    if (!keepHelper) {
      delete instance.helpers[helperName];
    }
  }
}

var decorators = {};

var inlineExports = {};
var inline = {
  get exports(){ return inlineExports; },
  set exports(v){ inlineExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  var _utils = utils$c;
  exports['default'] = function (instance) {
    instance.registerDecorator('inline', function (fn, props, container, options) {
      var ret = fn;
      if (!props.partials) {
        props.partials = {};
        ret = function (context, options) {
          // Create a new partials stack frame prior to exec.
          var original = container.partials;
          container.partials = _utils.extend({}, original, props.partials);
          var ret = fn(context, options);
          container.partials = original;
          return ret;
        };
      }
      props.partials[options.args[0]] = options.fn;
      return ret;
    });
  };
  module.exports = exports['default'];
})(inline, inlineExports);

decorators.__esModule = true;
decorators.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _decoratorsInline = inlineExports;
var _decoratorsInline2 = _interopRequireDefault$6(_decoratorsInline);
function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}

var loggerExports = {};
var logger$L = {
  get exports(){ return loggerExports; },
  set exports(v){ loggerExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  var _utils = utils$c;
  var logger = {
    methodMap: ['debug', 'info', 'warn', 'error'],
    level: 'info',
    // Maps a given level value to the `methodMap` indexes above.
    lookupLevel: function lookupLevel(level) {
      if (typeof level === 'string') {
        var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
        if (levelMap >= 0) {
          level = levelMap;
        } else {
          level = parseInt(level, 10);
        }
      }
      return level;
    },
    // Can be overridden in the host environment
    log: function log(level) {
      level = logger.lookupLevel(level);
      if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
        var method = logger.methodMap[level];
        // eslint-disable-next-line no-console
        if (!console[method]) {
          method = 'log';
        }
        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          message[_key - 1] = arguments[_key];
        }
        console[method].apply(console, message); // eslint-disable-line no-console
      }
    }
  };

  exports['default'] = logger;
  module.exports = exports['default'];
})(logger$L, loggerExports);

var protoAccess = {};

var createNewLookupObject$1 = {};

createNewLookupObject$1.__esModule = true;
createNewLookupObject$1.createNewLookupObject = createNewLookupObject;
var _utils$4 = utils$c;

/**
 * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
 * The resulting object can be used with "object[property]" to check if a property exists
 * @param {...object} sources a varargs parameter of source objects that will be merged
 * @returns {object}
 */

function createNewLookupObject() {
  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  return _utils$4.extend.apply(undefined, [Object.create(null)].concat(sources));
}

protoAccess.__esModule = true;
protoAccess.createProtoAccessControl = createProtoAccessControl;
protoAccess.resultIsAllowed = resultIsAllowed;
protoAccess.resetLoggedProperties = resetLoggedProperties;
// istanbul ignore next

function _interopRequireWildcard$2(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj['default'] = obj;
    return newObj;
  }
}
var _createNewLookupObject = createNewLookupObject$1;
var _logger$1 = loggerExports;
var logger$K = _interopRequireWildcard$2(_logger$1);
var loggedProperties = Object.create(null);
function createProtoAccessControl(runtimeOptions) {
  var defaultMethodWhiteList = Object.create(null);
  defaultMethodWhiteList['constructor'] = false;
  defaultMethodWhiteList['__defineGetter__'] = false;
  defaultMethodWhiteList['__defineSetter__'] = false;
  defaultMethodWhiteList['__lookupGetter__'] = false;
  var defaultPropertyWhiteList = Object.create(null);
  // eslint-disable-next-line no-proto
  defaultPropertyWhiteList['__proto__'] = false;
  return {
    properties: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
    },
    methods: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
      defaultValue: runtimeOptions.allowProtoMethodsByDefault
    }
  };
}
function resultIsAllowed(result, protoAccessControl, propertyName) {
  if (typeof result === 'function') {
    return checkWhiteList(protoAccessControl.methods, propertyName);
  } else {
    return checkWhiteList(protoAccessControl.properties, propertyName);
  }
}
function checkWhiteList(protoAccessControlForType, propertyName) {
  if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
    return protoAccessControlForType.whitelist[propertyName] === true;
  }
  if (protoAccessControlForType.defaultValue !== undefined) {
    return protoAccessControlForType.defaultValue;
  }
  logUnexpecedPropertyAccessOnce(propertyName);
  return false;
}
function logUnexpecedPropertyAccessOnce(propertyName) {
  if (loggedProperties[propertyName] !== true) {
    loggedProperties[propertyName] = true;
    logger$K.log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
  }
}
function resetLoggedProperties() {
  Object.keys(loggedProperties).forEach(function (propertyName) {
    delete loggedProperties[propertyName];
  });
}

base$2.__esModule = true;
base$2.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _utils$3 = utils$c;
var _exception$3 = exceptionExports;
var _exception2$3 = _interopRequireDefault$5(_exception$3);
var _helpers$2 = helpers$1;
var _decorators = decorators;
var _logger = loggerExports;
var _logger2 = _interopRequireDefault$5(_logger);
var _internalProtoAccess$1 = protoAccess;
var VERSION = '4.7.7';
base$2.VERSION = VERSION;
var COMPILER_REVISION = 8;
base$2.COMPILER_REVISION = COMPILER_REVISION;
var LAST_COMPATIBLE_COMPILER_REVISION = 7;
base$2.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2',
  // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0 <4.3.0',
  8: '>= 4.3.0'
};
base$2.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';
function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};
  _helpers$2.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}
HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,
  logger: _logger2['default'],
  log: _logger2['default'].log,
  registerHelper: function registerHelper(name, fn) {
    if (_utils$3.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2$3['default']('Arg not supported with multiple helpers');
      }
      _utils$3.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },
  registerPartial: function registerPartial(name, partial) {
    if (_utils$3.toString.call(name) === objectType) {
      _utils$3.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2$3['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },
  registerDecorator: function registerDecorator(name, fn) {
    if (_utils$3.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2$3['default']('Arg not supported with multiple decorators');
      }
      _utils$3.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  },
  /**
   * Reset the memory of illegal property accesses that have already been logged.
   * @deprecated should only be used in handlebars test-cases
   */
  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
    _internalProtoAccess$1.resetLoggedProperties();
  }
};
var log$1 = _logger2['default'].log;
base$2.log = log$1;
base$2.createFrame = _utils$3.createFrame;
base$2.logger = _logger2['default'];

var safeStringExports = {};
var safeString = {
  get exports(){ return safeStringExports; },
  set exports(v){ safeStringExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  function SafeString(string) {
    this.string = string;
  }
  SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
    return '' + this.string;
  };
  exports['default'] = SafeString;
  module.exports = exports['default'];
})(safeString, safeStringExports);

var runtime = {};

var wrapHelper$1 = {};

wrapHelper$1.__esModule = true;
wrapHelper$1.wrapHelper = wrapHelper;
function wrapHelper(helper, transformOptionsFn) {
  if (typeof helper !== 'function') {
    // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
    // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
    return helper;
  }
  var wrapper = function wrapper() /* dynamic arguments */{
    var options = arguments[arguments.length - 1];
    arguments[arguments.length - 1] = transformOptionsFn(options);
    return helper.apply(this, arguments);
  };
  return wrapper;
}

runtime.__esModule = true;
runtime.checkRevision = checkRevision;
runtime.template = template;
runtime.wrapProgram = wrapProgram;
runtime.resolvePartial = resolvePartial;
runtime.invokePartial = invokePartial;
runtime.noop = noop$1;
// istanbul ignore next

function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

// istanbul ignore next

function _interopRequireWildcard$1(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj['default'] = obj;
    return newObj;
  }
}
var _utils$2 = utils$c;
var Utils = _interopRequireWildcard$1(_utils$2);
var _exception$2 = exceptionExports;
var _exception2$2 = _interopRequireDefault$4(_exception$2);
var _base = base$2;
var _helpers$1 = helpers$1;
var _internalWrapHelper = wrapHelper$1;
var _internalProtoAccess = protoAccess;
function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
    currentRevision = _base.COMPILER_REVISION;
  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
    return;
  }
  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
      compilerVersions = _base.REVISION_CHANGES[compilerRevision];
    throw new _exception2$2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
  } else {
    // Use the embedded version info since the runtime doesn't know about this revision yet
    throw new _exception2$2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
  }
}
function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2$2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2$2['default']('Unknown template object: ' + typeof templateSpec);
  }
  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as pseudo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }
    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var extendedOptions = Utils.extend({}, options, {
      hooks: this.hooks,
      protoAccessControl: this.protoAccessControl
    });
    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, extendedOptions);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }
          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2$2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name, loc) {
      if (!obj || !(name in obj)) {
        throw new _exception2$2['default']('"' + name + '" not defined in ' + obj, {
          loc: loc
        });
      }
      return container.lookupProperty(obj, name);
    },
    lookupProperty: function lookupProperty(parent, propertyName) {
      var result = parent[propertyName];
      if (result == null) {
        return result;
      }
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return result;
      }
      if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
        return result;
      }
      return undefined;
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        var result = depths[i] && container.lookupProperty(depths[i], name);
        if (result != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },
    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
        fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },
    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    mergeIfNeeded: function mergeIfNeeded(param, common) {
      var obj = param || common;
      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }
      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),
    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };
  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var data = options.data;
    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
      blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }
    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;
  ret._setup = function (options) {
    if (!options.partial) {
      var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
      wrapHelpersToPassLookupProperty(mergedHelpers, container);
      container.helpers = mergedHelpers;
      if (templateSpec.usePartial) {
        // Use mergeIfNeeded here to prevent compiling global partials multiple times
        container.partials = container.mergeIfNeeded(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = Utils.extend({}, env.decorators, options.decorators);
      }
      container.hooks = {};
      container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
      _helpers$1.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
      _helpers$1.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
    } else {
      container.protoAccessControl = options.protoAccessControl; // internal option
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
      container.hooks = options.hooks;
    }
  };
  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2$2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2$2['default']('must pass parent depths');
    }
    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}
function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }
    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }
  prog = executeDecorators(fn, prog, container, depths, data, blockParams);
  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

/**
 * This is currently part of the official API, therefore implementation details should not be changed.
 */

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}
function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }
  var partialBlock = undefined;
  if (options.fn && options.fn !== noop$1) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }
  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }
  if (partial === undefined) {
    throw new _exception2$2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}
function noop$1() {
  return '';
}
function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}
function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}
function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
  Object.keys(mergedHelpers).forEach(function (helperName) {
    var helper = mergedHelpers[helperName];
    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
  });
}
function passLookupPropertyOption(helper, container) {
  var lookupProperty = container.lookupProperty;
  return _internalWrapHelper.wrapHelper(helper, function (options) {
    return Utils.extend({
      lookupProperty: lookupProperty
    }, options);
  });
}

var noConflictExports = {};
var noConflict = {
  get exports(){ return noConflictExports; },
  set exports(v){ noConflictExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  exports['default'] = function (Handlebars) {
    /* istanbul ignore next */
    var root = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : window,
      $Handlebars = root.Handlebars;
    /* istanbul ignore next */
    Handlebars.noConflict = function () {
      if (root.Handlebars === Handlebars) {
        root.Handlebars = $Handlebars;
      }
      return Handlebars;
    };
  };
  module.exports = exports['default'];
})(noConflict, noConflictExports);

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  // istanbul ignore next

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }
      newObj['default'] = obj;
      return newObj;
    }
  }
  var _handlebarsBase = base$2;
  var base = _interopRequireWildcard(_handlebarsBase);

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)

  var _handlebarsSafeString = safeStringExports;
  var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
  var _handlebarsException = exceptionExports;
  var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
  var _handlebarsUtils = utils$c;
  var Utils = _interopRequireWildcard(_handlebarsUtils);
  var _handlebarsRuntime = runtime;
  var runtime$1 = _interopRequireWildcard(_handlebarsRuntime);
  var _handlebarsNoConflict = noConflictExports;
  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  function create() {
    var hb = new base.HandlebarsEnvironment();
    Utils.extend(hb, base);
    hb.SafeString = _handlebarsSafeString2['default'];
    hb.Exception = _handlebarsException2['default'];
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;
    hb.VM = runtime$1;
    hb.template = function (spec) {
      return runtime$1.template(spec, hb);
    };
    return hb;
  }
  var inst = create();
  inst.create = create;
  _handlebarsNoConflict2['default'](inst);
  inst['default'] = inst;
  exports['default'] = inst;
  module.exports = exports['default'];
})(handlebars_runtime, handlebars_runtimeExports);

var astExports = {};
var ast = {
  get exports(){ return astExports; },
  set exports(v){ astExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  var AST = {
    // Public API used to evaluate derived attributes regarding AST nodes
    helpers: {
      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      helperExpression: function helperExpression(node) {
        return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
      },
      scopedId: function scopedId(path) {
        return /^\.|this\b/.test(path.original);
      },
      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      simpleId: function simpleId(path) {
        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
      }
    }
  };

  // Must be exported as an object rather than the root of the module as the jison lexer
  // must modify the object to operate properly.
  exports['default'] = AST;
  module.exports = exports['default'];
})(ast, astExports);

var base$1 = {};

var parserExports = {};
var parser = {
  get exports(){ return parserExports; },
  set exports(v){ parserExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  var handlebars = function () {
    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "root": 3,
        "program": 4,
        "EOF": 5,
        "program_repetition0": 6,
        "statement": 7,
        "mustache": 8,
        "block": 9,
        "rawBlock": 10,
        "partial": 11,
        "partialBlock": 12,
        "content": 13,
        "COMMENT": 14,
        "CONTENT": 15,
        "openRawBlock": 16,
        "rawBlock_repetition0": 17,
        "END_RAW_BLOCK": 18,
        "OPEN_RAW_BLOCK": 19,
        "helperName": 20,
        "openRawBlock_repetition0": 21,
        "openRawBlock_option0": 22,
        "CLOSE_RAW_BLOCK": 23,
        "openBlock": 24,
        "block_option0": 25,
        "closeBlock": 26,
        "openInverse": 27,
        "block_option1": 28,
        "OPEN_BLOCK": 29,
        "openBlock_repetition0": 30,
        "openBlock_option0": 31,
        "openBlock_option1": 32,
        "CLOSE": 33,
        "OPEN_INVERSE": 34,
        "openInverse_repetition0": 35,
        "openInverse_option0": 36,
        "openInverse_option1": 37,
        "openInverseChain": 38,
        "OPEN_INVERSE_CHAIN": 39,
        "openInverseChain_repetition0": 40,
        "openInverseChain_option0": 41,
        "openInverseChain_option1": 42,
        "inverseAndProgram": 43,
        "INVERSE": 44,
        "inverseChain": 45,
        "inverseChain_option0": 46,
        "OPEN_ENDBLOCK": 47,
        "OPEN": 48,
        "mustache_repetition0": 49,
        "mustache_option0": 50,
        "OPEN_UNESCAPED": 51,
        "mustache_repetition1": 52,
        "mustache_option1": 53,
        "CLOSE_UNESCAPED": 54,
        "OPEN_PARTIAL": 55,
        "partialName": 56,
        "partial_repetition0": 57,
        "partial_option0": 58,
        "openPartialBlock": 59,
        "OPEN_PARTIAL_BLOCK": 60,
        "openPartialBlock_repetition0": 61,
        "openPartialBlock_option0": 62,
        "param": 63,
        "sexpr": 64,
        "OPEN_SEXPR": 65,
        "sexpr_repetition0": 66,
        "sexpr_option0": 67,
        "CLOSE_SEXPR": 68,
        "hash": 69,
        "hash_repetition_plus0": 70,
        "hashSegment": 71,
        "ID": 72,
        "EQUALS": 73,
        "blockParams": 74,
        "OPEN_BLOCK_PARAMS": 75,
        "blockParams_repetition_plus0": 76,
        "CLOSE_BLOCK_PARAMS": 77,
        "path": 78,
        "dataName": 79,
        "STRING": 80,
        "NUMBER": 81,
        "BOOLEAN": 82,
        "UNDEFINED": 83,
        "NULL": 84,
        "DATA": 85,
        "pathSegments": 86,
        "SEP": 87,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        5: "EOF",
        14: "COMMENT",
        15: "CONTENT",
        18: "END_RAW_BLOCK",
        19: "OPEN_RAW_BLOCK",
        23: "CLOSE_RAW_BLOCK",
        29: "OPEN_BLOCK",
        33: "CLOSE",
        34: "OPEN_INVERSE",
        39: "OPEN_INVERSE_CHAIN",
        44: "INVERSE",
        47: "OPEN_ENDBLOCK",
        48: "OPEN",
        51: "OPEN_UNESCAPED",
        54: "CLOSE_UNESCAPED",
        55: "OPEN_PARTIAL",
        60: "OPEN_PARTIAL_BLOCK",
        65: "OPEN_SEXPR",
        68: "CLOSE_SEXPR",
        72: "ID",
        73: "EQUALS",
        75: "OPEN_BLOCK_PARAMS",
        77: "CLOSE_BLOCK_PARAMS",
        80: "STRING",
        81: "NUMBER",
        82: "BOOLEAN",
        83: "UNDEFINED",
        84: "NULL",
        85: "DATA",
        87: "SEP"
      },
      productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 1:
            return $$[$0 - 1];
          case 2:
            this.$ = yy.prepareProgram($$[$0]);
            break;
          case 3:
            this.$ = $$[$0];
            break;
          case 4:
            this.$ = $$[$0];
            break;
          case 5:
            this.$ = $$[$0];
            break;
          case 6:
            this.$ = $$[$0];
            break;
          case 7:
            this.$ = $$[$0];
            break;
          case 8:
            this.$ = $$[$0];
            break;
          case 9:
            this.$ = {
              type: 'CommentStatement',
              value: yy.stripComment($$[$0]),
              strip: yy.stripFlags($$[$0], $$[$0]),
              loc: yy.locInfo(this._$)
            };
            break;
          case 10:
            this.$ = {
              type: 'ContentStatement',
              original: $$[$0],
              value: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;
          case 11:
            this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
            break;
          case 12:
            this.$ = {
              path: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1]
            };
            break;
          case 13:
            this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
            break;
          case 14:
            this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
            break;
          case 15:
            this.$ = {
              open: $$[$0 - 5],
              path: $$[$0 - 4],
              params: $$[$0 - 3],
              hash: $$[$0 - 2],
              blockParams: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 5], $$[$0])
            };
            break;
          case 16:
            this.$ = {
              path: $$[$0 - 4],
              params: $$[$0 - 3],
              hash: $$[$0 - 2],
              blockParams: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 5], $$[$0])
            };
            break;
          case 17:
            this.$ = {
              path: $$[$0 - 4],
              params: $$[$0 - 3],
              hash: $$[$0 - 2],
              blockParams: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 5], $$[$0])
            };
            break;
          case 18:
            this.$ = {
              strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]),
              program: $$[$0]
            };
            break;
          case 19:
            var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
              program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
            program.chained = true;
            this.$ = {
              strip: $$[$0 - 2].strip,
              program: program,
              chain: true
            };
            break;
          case 20:
            this.$ = $$[$0];
            break;
          case 21:
            this.$ = {
              path: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 2], $$[$0])
            };
            break;
          case 22:
            this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
            break;
          case 23:
            this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
            break;
          case 24:
            this.$ = {
              type: 'PartialStatement',
              name: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              indent: '',
              strip: yy.stripFlags($$[$0 - 4], $$[$0]),
              loc: yy.locInfo(this._$)
            };
            break;
          case 25:
            this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
            break;
          case 26:
            this.$ = {
              path: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              strip: yy.stripFlags($$[$0 - 4], $$[$0])
            };
            break;
          case 27:
            this.$ = $$[$0];
            break;
          case 28:
            this.$ = $$[$0];
            break;
          case 29:
            this.$ = {
              type: 'SubExpression',
              path: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              loc: yy.locInfo(this._$)
            };
            break;
          case 30:
            this.$ = {
              type: 'Hash',
              pairs: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;
          case 31:
            this.$ = {
              type: 'HashPair',
              key: yy.id($$[$0 - 2]),
              value: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;
          case 32:
            this.$ = yy.id($$[$0 - 1]);
            break;
          case 33:
            this.$ = $$[$0];
            break;
          case 34:
            this.$ = $$[$0];
            break;
          case 35:
            this.$ = {
              type: 'StringLiteral',
              value: $$[$0],
              original: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;
          case 36:
            this.$ = {
              type: 'NumberLiteral',
              value: Number($$[$0]),
              original: Number($$[$0]),
              loc: yy.locInfo(this._$)
            };
            break;
          case 37:
            this.$ = {
              type: 'BooleanLiteral',
              value: $$[$0] === 'true',
              original: $$[$0] === 'true',
              loc: yy.locInfo(this._$)
            };
            break;
          case 38:
            this.$ = {
              type: 'UndefinedLiteral',
              original: undefined,
              value: undefined,
              loc: yy.locInfo(this._$)
            };
            break;
          case 39:
            this.$ = {
              type: 'NullLiteral',
              original: null,
              value: null,
              loc: yy.locInfo(this._$)
            };
            break;
          case 40:
            this.$ = $$[$0];
            break;
          case 41:
            this.$ = $$[$0];
            break;
          case 42:
            this.$ = yy.preparePath(true, $$[$0], this._$);
            break;
          case 43:
            this.$ = yy.preparePath(false, $$[$0], this._$);
            break;
          case 44:
            $$[$0 - 2].push({
              part: yy.id($$[$0]),
              original: $$[$0],
              separator: $$[$0 - 1]
            });
            this.$ = $$[$0 - 2];
            break;
          case 45:
            this.$ = [{
              part: yy.id($$[$0]),
              original: $$[$0]
            }];
            break;
          case 46:
            this.$ = [];
            break;
          case 47:
            $$[$0 - 1].push($$[$0]);
            break;
          case 48:
            this.$ = [];
            break;
          case 49:
            $$[$0 - 1].push($$[$0]);
            break;
          case 50:
            this.$ = [];
            break;
          case 51:
            $$[$0 - 1].push($$[$0]);
            break;
          case 58:
            this.$ = [];
            break;
          case 59:
            $$[$0 - 1].push($$[$0]);
            break;
          case 64:
            this.$ = [];
            break;
          case 65:
            $$[$0 - 1].push($$[$0]);
            break;
          case 70:
            this.$ = [];
            break;
          case 71:
            $$[$0 - 1].push($$[$0]);
            break;
          case 78:
            this.$ = [];
            break;
          case 79:
            $$[$0 - 1].push($$[$0]);
            break;
          case 82:
            this.$ = [];
            break;
          case 83:
            $$[$0 - 1].push($$[$0]);
            break;
          case 86:
            this.$ = [];
            break;
          case 87:
            $$[$0 - 1].push($$[$0]);
            break;
          case 90:
            this.$ = [];
            break;
          case 91:
            $$[$0 - 1].push($$[$0]);
            break;
          case 94:
            this.$ = [];
            break;
          case 95:
            $$[$0 - 1].push($$[$0]);
            break;
          case 98:
            this.$ = [$$[$0]];
            break;
          case 99:
            $$[$0 - 1].push($$[$0]);
            break;
          case 100:
            this.$ = [$$[$0]];
            break;
          case 101:
            $$[$0 - 1].push($$[$0]);
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        5: [2, 46],
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        1: [3]
      }, {
        5: [1, 4]
      }, {
        5: [2, 2],
        7: 5,
        8: 6,
        9: 7,
        10: 8,
        11: 9,
        12: 10,
        13: 11,
        14: [1, 12],
        15: [1, 20],
        16: 17,
        19: [1, 23],
        24: 15,
        27: 16,
        29: [1, 21],
        34: [1, 22],
        39: [2, 2],
        44: [2, 2],
        47: [2, 2],
        48: [1, 13],
        51: [1, 14],
        55: [1, 18],
        59: 19,
        60: [1, 24]
      }, {
        1: [2, 1]
      }, {
        5: [2, 47],
        14: [2, 47],
        15: [2, 47],
        19: [2, 47],
        29: [2, 47],
        34: [2, 47],
        39: [2, 47],
        44: [2, 47],
        47: [2, 47],
        48: [2, 47],
        51: [2, 47],
        55: [2, 47],
        60: [2, 47]
      }, {
        5: [2, 3],
        14: [2, 3],
        15: [2, 3],
        19: [2, 3],
        29: [2, 3],
        34: [2, 3],
        39: [2, 3],
        44: [2, 3],
        47: [2, 3],
        48: [2, 3],
        51: [2, 3],
        55: [2, 3],
        60: [2, 3]
      }, {
        5: [2, 4],
        14: [2, 4],
        15: [2, 4],
        19: [2, 4],
        29: [2, 4],
        34: [2, 4],
        39: [2, 4],
        44: [2, 4],
        47: [2, 4],
        48: [2, 4],
        51: [2, 4],
        55: [2, 4],
        60: [2, 4]
      }, {
        5: [2, 5],
        14: [2, 5],
        15: [2, 5],
        19: [2, 5],
        29: [2, 5],
        34: [2, 5],
        39: [2, 5],
        44: [2, 5],
        47: [2, 5],
        48: [2, 5],
        51: [2, 5],
        55: [2, 5],
        60: [2, 5]
      }, {
        5: [2, 6],
        14: [2, 6],
        15: [2, 6],
        19: [2, 6],
        29: [2, 6],
        34: [2, 6],
        39: [2, 6],
        44: [2, 6],
        47: [2, 6],
        48: [2, 6],
        51: [2, 6],
        55: [2, 6],
        60: [2, 6]
      }, {
        5: [2, 7],
        14: [2, 7],
        15: [2, 7],
        19: [2, 7],
        29: [2, 7],
        34: [2, 7],
        39: [2, 7],
        44: [2, 7],
        47: [2, 7],
        48: [2, 7],
        51: [2, 7],
        55: [2, 7],
        60: [2, 7]
      }, {
        5: [2, 8],
        14: [2, 8],
        15: [2, 8],
        19: [2, 8],
        29: [2, 8],
        34: [2, 8],
        39: [2, 8],
        44: [2, 8],
        47: [2, 8],
        48: [2, 8],
        51: [2, 8],
        55: [2, 8],
        60: [2, 8]
      }, {
        5: [2, 9],
        14: [2, 9],
        15: [2, 9],
        19: [2, 9],
        29: [2, 9],
        34: [2, 9],
        39: [2, 9],
        44: [2, 9],
        47: [2, 9],
        48: [2, 9],
        51: [2, 9],
        55: [2, 9],
        60: [2, 9]
      }, {
        20: 25,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 36,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        4: 37,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        39: [2, 46],
        44: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        4: 38,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        44: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        15: [2, 48],
        17: 39,
        18: [2, 48]
      }, {
        20: 41,
        56: 40,
        64: 42,
        65: [1, 43],
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        4: 44,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        5: [2, 10],
        14: [2, 10],
        15: [2, 10],
        18: [2, 10],
        19: [2, 10],
        29: [2, 10],
        34: [2, 10],
        39: [2, 10],
        44: [2, 10],
        47: [2, 10],
        48: [2, 10],
        51: [2, 10],
        55: [2, 10],
        60: [2, 10]
      }, {
        20: 45,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 46,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 47,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 41,
        56: 48,
        64: 42,
        65: [1, 43],
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        33: [2, 78],
        49: 49,
        65: [2, 78],
        72: [2, 78],
        80: [2, 78],
        81: [2, 78],
        82: [2, 78],
        83: [2, 78],
        84: [2, 78],
        85: [2, 78]
      }, {
        23: [2, 33],
        33: [2, 33],
        54: [2, 33],
        65: [2, 33],
        68: [2, 33],
        72: [2, 33],
        75: [2, 33],
        80: [2, 33],
        81: [2, 33],
        82: [2, 33],
        83: [2, 33],
        84: [2, 33],
        85: [2, 33]
      }, {
        23: [2, 34],
        33: [2, 34],
        54: [2, 34],
        65: [2, 34],
        68: [2, 34],
        72: [2, 34],
        75: [2, 34],
        80: [2, 34],
        81: [2, 34],
        82: [2, 34],
        83: [2, 34],
        84: [2, 34],
        85: [2, 34]
      }, {
        23: [2, 35],
        33: [2, 35],
        54: [2, 35],
        65: [2, 35],
        68: [2, 35],
        72: [2, 35],
        75: [2, 35],
        80: [2, 35],
        81: [2, 35],
        82: [2, 35],
        83: [2, 35],
        84: [2, 35],
        85: [2, 35]
      }, {
        23: [2, 36],
        33: [2, 36],
        54: [2, 36],
        65: [2, 36],
        68: [2, 36],
        72: [2, 36],
        75: [2, 36],
        80: [2, 36],
        81: [2, 36],
        82: [2, 36],
        83: [2, 36],
        84: [2, 36],
        85: [2, 36]
      }, {
        23: [2, 37],
        33: [2, 37],
        54: [2, 37],
        65: [2, 37],
        68: [2, 37],
        72: [2, 37],
        75: [2, 37],
        80: [2, 37],
        81: [2, 37],
        82: [2, 37],
        83: [2, 37],
        84: [2, 37],
        85: [2, 37]
      }, {
        23: [2, 38],
        33: [2, 38],
        54: [2, 38],
        65: [2, 38],
        68: [2, 38],
        72: [2, 38],
        75: [2, 38],
        80: [2, 38],
        81: [2, 38],
        82: [2, 38],
        83: [2, 38],
        84: [2, 38],
        85: [2, 38]
      }, {
        23: [2, 39],
        33: [2, 39],
        54: [2, 39],
        65: [2, 39],
        68: [2, 39],
        72: [2, 39],
        75: [2, 39],
        80: [2, 39],
        81: [2, 39],
        82: [2, 39],
        83: [2, 39],
        84: [2, 39],
        85: [2, 39]
      }, {
        23: [2, 43],
        33: [2, 43],
        54: [2, 43],
        65: [2, 43],
        68: [2, 43],
        72: [2, 43],
        75: [2, 43],
        80: [2, 43],
        81: [2, 43],
        82: [2, 43],
        83: [2, 43],
        84: [2, 43],
        85: [2, 43],
        87: [1, 50]
      }, {
        72: [1, 35],
        86: 51
      }, {
        23: [2, 45],
        33: [2, 45],
        54: [2, 45],
        65: [2, 45],
        68: [2, 45],
        72: [2, 45],
        75: [2, 45],
        80: [2, 45],
        81: [2, 45],
        82: [2, 45],
        83: [2, 45],
        84: [2, 45],
        85: [2, 45],
        87: [2, 45]
      }, {
        52: 52,
        54: [2, 82],
        65: [2, 82],
        72: [2, 82],
        80: [2, 82],
        81: [2, 82],
        82: [2, 82],
        83: [2, 82],
        84: [2, 82],
        85: [2, 82]
      }, {
        25: 53,
        38: 55,
        39: [1, 57],
        43: 56,
        44: [1, 58],
        45: 54,
        47: [2, 54]
      }, {
        28: 59,
        43: 60,
        44: [1, 58],
        47: [2, 56]
      }, {
        13: 62,
        15: [1, 20],
        18: [1, 61]
      }, {
        33: [2, 86],
        57: 63,
        65: [2, 86],
        72: [2, 86],
        80: [2, 86],
        81: [2, 86],
        82: [2, 86],
        83: [2, 86],
        84: [2, 86],
        85: [2, 86]
      }, {
        33: [2, 40],
        65: [2, 40],
        72: [2, 40],
        80: [2, 40],
        81: [2, 40],
        82: [2, 40],
        83: [2, 40],
        84: [2, 40],
        85: [2, 40]
      }, {
        33: [2, 41],
        65: [2, 41],
        72: [2, 41],
        80: [2, 41],
        81: [2, 41],
        82: [2, 41],
        83: [2, 41],
        84: [2, 41],
        85: [2, 41]
      }, {
        20: 64,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        26: 65,
        47: [1, 66]
      }, {
        30: 67,
        33: [2, 58],
        65: [2, 58],
        72: [2, 58],
        75: [2, 58],
        80: [2, 58],
        81: [2, 58],
        82: [2, 58],
        83: [2, 58],
        84: [2, 58],
        85: [2, 58]
      }, {
        33: [2, 64],
        35: 68,
        65: [2, 64],
        72: [2, 64],
        75: [2, 64],
        80: [2, 64],
        81: [2, 64],
        82: [2, 64],
        83: [2, 64],
        84: [2, 64],
        85: [2, 64]
      }, {
        21: 69,
        23: [2, 50],
        65: [2, 50],
        72: [2, 50],
        80: [2, 50],
        81: [2, 50],
        82: [2, 50],
        83: [2, 50],
        84: [2, 50],
        85: [2, 50]
      }, {
        33: [2, 90],
        61: 70,
        65: [2, 90],
        72: [2, 90],
        80: [2, 90],
        81: [2, 90],
        82: [2, 90],
        83: [2, 90],
        84: [2, 90],
        85: [2, 90]
      }, {
        20: 74,
        33: [2, 80],
        50: 71,
        63: 72,
        64: 75,
        65: [1, 43],
        69: 73,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        72: [1, 79]
      }, {
        23: [2, 42],
        33: [2, 42],
        54: [2, 42],
        65: [2, 42],
        68: [2, 42],
        72: [2, 42],
        75: [2, 42],
        80: [2, 42],
        81: [2, 42],
        82: [2, 42],
        83: [2, 42],
        84: [2, 42],
        85: [2, 42],
        87: [1, 50]
      }, {
        20: 74,
        53: 80,
        54: [2, 84],
        63: 81,
        64: 75,
        65: [1, 43],
        69: 82,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        26: 83,
        47: [1, 66]
      }, {
        47: [2, 55]
      }, {
        4: 84,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        39: [2, 46],
        44: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        47: [2, 20]
      }, {
        20: 85,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        4: 86,
        6: 3,
        14: [2, 46],
        15: [2, 46],
        19: [2, 46],
        29: [2, 46],
        34: [2, 46],
        47: [2, 46],
        48: [2, 46],
        51: [2, 46],
        55: [2, 46],
        60: [2, 46]
      }, {
        26: 87,
        47: [1, 66]
      }, {
        47: [2, 57]
      }, {
        5: [2, 11],
        14: [2, 11],
        15: [2, 11],
        19: [2, 11],
        29: [2, 11],
        34: [2, 11],
        39: [2, 11],
        44: [2, 11],
        47: [2, 11],
        48: [2, 11],
        51: [2, 11],
        55: [2, 11],
        60: [2, 11]
      }, {
        15: [2, 49],
        18: [2, 49]
      }, {
        20: 74,
        33: [2, 88],
        58: 88,
        63: 89,
        64: 75,
        65: [1, 43],
        69: 90,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        65: [2, 94],
        66: 91,
        68: [2, 94],
        72: [2, 94],
        80: [2, 94],
        81: [2, 94],
        82: [2, 94],
        83: [2, 94],
        84: [2, 94],
        85: [2, 94]
      }, {
        5: [2, 25],
        14: [2, 25],
        15: [2, 25],
        19: [2, 25],
        29: [2, 25],
        34: [2, 25],
        39: [2, 25],
        44: [2, 25],
        47: [2, 25],
        48: [2, 25],
        51: [2, 25],
        55: [2, 25],
        60: [2, 25]
      }, {
        20: 92,
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 74,
        31: 93,
        33: [2, 60],
        63: 94,
        64: 75,
        65: [1, 43],
        69: 95,
        70: 76,
        71: 77,
        72: [1, 78],
        75: [2, 60],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 74,
        33: [2, 66],
        36: 96,
        63: 97,
        64: 75,
        65: [1, 43],
        69: 98,
        70: 76,
        71: 77,
        72: [1, 78],
        75: [2, 66],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 74,
        22: 99,
        23: [2, 52],
        63: 100,
        64: 75,
        65: [1, 43],
        69: 101,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        20: 74,
        33: [2, 92],
        62: 102,
        63: 103,
        64: 75,
        65: [1, 43],
        69: 104,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        33: [1, 105]
      }, {
        33: [2, 79],
        65: [2, 79],
        72: [2, 79],
        80: [2, 79],
        81: [2, 79],
        82: [2, 79],
        83: [2, 79],
        84: [2, 79],
        85: [2, 79]
      }, {
        33: [2, 81]
      }, {
        23: [2, 27],
        33: [2, 27],
        54: [2, 27],
        65: [2, 27],
        68: [2, 27],
        72: [2, 27],
        75: [2, 27],
        80: [2, 27],
        81: [2, 27],
        82: [2, 27],
        83: [2, 27],
        84: [2, 27],
        85: [2, 27]
      }, {
        23: [2, 28],
        33: [2, 28],
        54: [2, 28],
        65: [2, 28],
        68: [2, 28],
        72: [2, 28],
        75: [2, 28],
        80: [2, 28],
        81: [2, 28],
        82: [2, 28],
        83: [2, 28],
        84: [2, 28],
        85: [2, 28]
      }, {
        23: [2, 30],
        33: [2, 30],
        54: [2, 30],
        68: [2, 30],
        71: 106,
        72: [1, 107],
        75: [2, 30]
      }, {
        23: [2, 98],
        33: [2, 98],
        54: [2, 98],
        68: [2, 98],
        72: [2, 98],
        75: [2, 98]
      }, {
        23: [2, 45],
        33: [2, 45],
        54: [2, 45],
        65: [2, 45],
        68: [2, 45],
        72: [2, 45],
        73: [1, 108],
        75: [2, 45],
        80: [2, 45],
        81: [2, 45],
        82: [2, 45],
        83: [2, 45],
        84: [2, 45],
        85: [2, 45],
        87: [2, 45]
      }, {
        23: [2, 44],
        33: [2, 44],
        54: [2, 44],
        65: [2, 44],
        68: [2, 44],
        72: [2, 44],
        75: [2, 44],
        80: [2, 44],
        81: [2, 44],
        82: [2, 44],
        83: [2, 44],
        84: [2, 44],
        85: [2, 44],
        87: [2, 44]
      }, {
        54: [1, 109]
      }, {
        54: [2, 83],
        65: [2, 83],
        72: [2, 83],
        80: [2, 83],
        81: [2, 83],
        82: [2, 83],
        83: [2, 83],
        84: [2, 83],
        85: [2, 83]
      }, {
        54: [2, 85]
      }, {
        5: [2, 13],
        14: [2, 13],
        15: [2, 13],
        19: [2, 13],
        29: [2, 13],
        34: [2, 13],
        39: [2, 13],
        44: [2, 13],
        47: [2, 13],
        48: [2, 13],
        51: [2, 13],
        55: [2, 13],
        60: [2, 13]
      }, {
        38: 55,
        39: [1, 57],
        43: 56,
        44: [1, 58],
        45: 111,
        46: 110,
        47: [2, 76]
      }, {
        33: [2, 70],
        40: 112,
        65: [2, 70],
        72: [2, 70],
        75: [2, 70],
        80: [2, 70],
        81: [2, 70],
        82: [2, 70],
        83: [2, 70],
        84: [2, 70],
        85: [2, 70]
      }, {
        47: [2, 18]
      }, {
        5: [2, 14],
        14: [2, 14],
        15: [2, 14],
        19: [2, 14],
        29: [2, 14],
        34: [2, 14],
        39: [2, 14],
        44: [2, 14],
        47: [2, 14],
        48: [2, 14],
        51: [2, 14],
        55: [2, 14],
        60: [2, 14]
      }, {
        33: [1, 113]
      }, {
        33: [2, 87],
        65: [2, 87],
        72: [2, 87],
        80: [2, 87],
        81: [2, 87],
        82: [2, 87],
        83: [2, 87],
        84: [2, 87],
        85: [2, 87]
      }, {
        33: [2, 89]
      }, {
        20: 74,
        63: 115,
        64: 75,
        65: [1, 43],
        67: 114,
        68: [2, 96],
        69: 116,
        70: 76,
        71: 77,
        72: [1, 78],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        33: [1, 117]
      }, {
        32: 118,
        33: [2, 62],
        74: 119,
        75: [1, 120]
      }, {
        33: [2, 59],
        65: [2, 59],
        72: [2, 59],
        75: [2, 59],
        80: [2, 59],
        81: [2, 59],
        82: [2, 59],
        83: [2, 59],
        84: [2, 59],
        85: [2, 59]
      }, {
        33: [2, 61],
        75: [2, 61]
      }, {
        33: [2, 68],
        37: 121,
        74: 122,
        75: [1, 120]
      }, {
        33: [2, 65],
        65: [2, 65],
        72: [2, 65],
        75: [2, 65],
        80: [2, 65],
        81: [2, 65],
        82: [2, 65],
        83: [2, 65],
        84: [2, 65],
        85: [2, 65]
      }, {
        33: [2, 67],
        75: [2, 67]
      }, {
        23: [1, 123]
      }, {
        23: [2, 51],
        65: [2, 51],
        72: [2, 51],
        80: [2, 51],
        81: [2, 51],
        82: [2, 51],
        83: [2, 51],
        84: [2, 51],
        85: [2, 51]
      }, {
        23: [2, 53]
      }, {
        33: [1, 124]
      }, {
        33: [2, 91],
        65: [2, 91],
        72: [2, 91],
        80: [2, 91],
        81: [2, 91],
        82: [2, 91],
        83: [2, 91],
        84: [2, 91],
        85: [2, 91]
      }, {
        33: [2, 93]
      }, {
        5: [2, 22],
        14: [2, 22],
        15: [2, 22],
        19: [2, 22],
        29: [2, 22],
        34: [2, 22],
        39: [2, 22],
        44: [2, 22],
        47: [2, 22],
        48: [2, 22],
        51: [2, 22],
        55: [2, 22],
        60: [2, 22]
      }, {
        23: [2, 99],
        33: [2, 99],
        54: [2, 99],
        68: [2, 99],
        72: [2, 99],
        75: [2, 99]
      }, {
        73: [1, 108]
      }, {
        20: 74,
        63: 125,
        64: 75,
        65: [1, 43],
        72: [1, 35],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        5: [2, 23],
        14: [2, 23],
        15: [2, 23],
        19: [2, 23],
        29: [2, 23],
        34: [2, 23],
        39: [2, 23],
        44: [2, 23],
        47: [2, 23],
        48: [2, 23],
        51: [2, 23],
        55: [2, 23],
        60: [2, 23]
      }, {
        47: [2, 19]
      }, {
        47: [2, 77]
      }, {
        20: 74,
        33: [2, 72],
        41: 126,
        63: 127,
        64: 75,
        65: [1, 43],
        69: 128,
        70: 76,
        71: 77,
        72: [1, 78],
        75: [2, 72],
        78: 26,
        79: 27,
        80: [1, 28],
        81: [1, 29],
        82: [1, 30],
        83: [1, 31],
        84: [1, 32],
        85: [1, 34],
        86: 33
      }, {
        5: [2, 24],
        14: [2, 24],
        15: [2, 24],
        19: [2, 24],
        29: [2, 24],
        34: [2, 24],
        39: [2, 24],
        44: [2, 24],
        47: [2, 24],
        48: [2, 24],
        51: [2, 24],
        55: [2, 24],
        60: [2, 24]
      }, {
        68: [1, 129]
      }, {
        65: [2, 95],
        68: [2, 95],
        72: [2, 95],
        80: [2, 95],
        81: [2, 95],
        82: [2, 95],
        83: [2, 95],
        84: [2, 95],
        85: [2, 95]
      }, {
        68: [2, 97]
      }, {
        5: [2, 21],
        14: [2, 21],
        15: [2, 21],
        19: [2, 21],
        29: [2, 21],
        34: [2, 21],
        39: [2, 21],
        44: [2, 21],
        47: [2, 21],
        48: [2, 21],
        51: [2, 21],
        55: [2, 21],
        60: [2, 21]
      }, {
        33: [1, 130]
      }, {
        33: [2, 63]
      }, {
        72: [1, 132],
        76: 131
      }, {
        33: [1, 133]
      }, {
        33: [2, 69]
      }, {
        15: [2, 12],
        18: [2, 12]
      }, {
        14: [2, 26],
        15: [2, 26],
        19: [2, 26],
        29: [2, 26],
        34: [2, 26],
        47: [2, 26],
        48: [2, 26],
        51: [2, 26],
        55: [2, 26],
        60: [2, 26]
      }, {
        23: [2, 31],
        33: [2, 31],
        54: [2, 31],
        68: [2, 31],
        72: [2, 31],
        75: [2, 31]
      }, {
        33: [2, 74],
        42: 134,
        74: 135,
        75: [1, 120]
      }, {
        33: [2, 71],
        65: [2, 71],
        72: [2, 71],
        75: [2, 71],
        80: [2, 71],
        81: [2, 71],
        82: [2, 71],
        83: [2, 71],
        84: [2, 71],
        85: [2, 71]
      }, {
        33: [2, 73],
        75: [2, 73]
      }, {
        23: [2, 29],
        33: [2, 29],
        54: [2, 29],
        65: [2, 29],
        68: [2, 29],
        72: [2, 29],
        75: [2, 29],
        80: [2, 29],
        81: [2, 29],
        82: [2, 29],
        83: [2, 29],
        84: [2, 29],
        85: [2, 29]
      }, {
        14: [2, 15],
        15: [2, 15],
        19: [2, 15],
        29: [2, 15],
        34: [2, 15],
        39: [2, 15],
        44: [2, 15],
        47: [2, 15],
        48: [2, 15],
        51: [2, 15],
        55: [2, 15],
        60: [2, 15]
      }, {
        72: [1, 137],
        77: [1, 136]
      }, {
        72: [2, 100],
        77: [2, 100]
      }, {
        14: [2, 16],
        15: [2, 16],
        19: [2, 16],
        29: [2, 16],
        34: [2, 16],
        44: [2, 16],
        47: [2, 16],
        48: [2, 16],
        51: [2, 16],
        55: [2, 16],
        60: [2, 16]
      }, {
        33: [1, 138]
      }, {
        33: [2, 75]
      }, {
        33: [2, 32]
      }, {
        72: [2, 101],
        77: [2, 101]
      }, {
        14: [2, 17],
        15: [2, 17],
        19: [2, 17],
        29: [2, 17],
        34: [2, 17],
        39: [2, 17],
        44: [2, 17],
        47: [2, 17],
        48: [2, 17],
        51: [2, 17],
        55: [2, 17],
        60: [2, 17]
      }],
      defaultActions: {
        4: [2, 1],
        54: [2, 55],
        56: [2, 20],
        60: [2, 57],
        73: [2, 81],
        82: [2, 85],
        86: [2, 18],
        90: [2, 89],
        101: [2, 53],
        104: [2, 93],
        110: [2, 19],
        111: [2, 77],
        116: [2, 97],
        119: [2, 63],
        122: [2, 69],
        135: [2, 75],
        136: [2, 32]
      },
      parseError: function parseError(str, hash) {
        throw new Error(str);
      },
      parse: function parse(input) {
        var self = this,
          stack = [0],
          vstack = [null],
          lstack = [],
          table = this.table,
          yytext = "",
          yylineno = 0,
          yyleng = 0;
        this.lexer.setInput(input);
        this.lexer.yy = this.yy;
        this.yy.lexer = this.lexer;
        this.yy.parser = this;
        if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
        var yyloc = this.lexer.yylloc;
        lstack.push(yyloc);
        var ranges = this.lexer.options && this.lexer.options.ranges;
        if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
        function lex() {
          var token;
          token = self.lexer.lex() || 1;
          if (typeof token !== "number") {
            token = self.symbols_[token] || token;
          }
          return token;
        }
        var symbol,
          state,
          action,
          r,
          yyval = {},
          p,
          len,
          newState,
          expected;
        while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            {
              expected = [];
              for (p in table[state]) if (this.terminals_[p] && p > 2) {
                expected.push("'" + this.terminals_[p] + "'");
              }
              if (this.lexer.showPosition) {
                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
              } else {
                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
              }
              this.parseError(errStr, {
                text: this.lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: this.lexer.yylineno,
                loc: yyloc,
                expected: expected
              });
            }
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    /* Jison generated lexer */
    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function setInput(input) {
          this._input = input;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) this.yylloc.range = [0, 0];
          this.offset = 0;
          return this;
        },
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) this.yylloc.range[1]++;
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) this.yylineno -= lines.length - 1;
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          return this;
        },
        more: function more() {
          this._more = true;
          return this;
        },
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function upcomingInput() {
          var next = this.match;
          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }
          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        next: function next() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) this.done = true;
          var token, match, tempMatch, index, lines;
          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;
              if (!this.options.flex) break;
            }
          }
          if (match) {
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) this.yylineno += lines.length;
            this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
            };
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input) this.done = false;
            if (token) return token;else return;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (typeof r !== 'undefined') {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          return this.conditionStack.pop();
        },
        _currentRules: function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        },
        topState: function topState() {
          return this.conditionStack[this.conditionStack.length - 2];
        },
        pushState: function begin(condition) {
          this.begin(condition);
        }
      };
      lexer.options = {};
      lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        function strip(start, end) {
          return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
        }
        switch ($avoiding_name_collisions) {
          case 0:
            if (yy_.yytext.slice(-2) === "\\\\") {
              strip(0, 1);
              this.begin("mu");
            } else if (yy_.yytext.slice(-1) === "\\") {
              strip(0, 1);
              this.begin("emu");
            } else {
              this.begin("mu");
            }
            if (yy_.yytext) return 15;
            break;
          case 1:
            return 15;
          case 2:
            this.popState();
            return 15;
          case 3:
            this.begin('raw');
            return 15;
          case 4:
            this.popState();
            // Should be using `this.topState()` below, but it currently
            // returns the second top instead of the first top. Opened an
            // issue about it at https://github.com/zaach/jison/issues/291
            if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
              return 15;
            } else {
              strip(5, 9);
              return 'END_RAW_BLOCK';
            }
          case 5:
            return 15;
          case 6:
            this.popState();
            return 14;
          case 7:
            return 65;
          case 8:
            return 68;
          case 9:
            return 19;
          case 10:
            this.popState();
            this.begin('raw');
            return 23;
          case 11:
            return 55;
          case 12:
            return 60;
          case 13:
            return 29;
          case 14:
            return 47;
          case 15:
            this.popState();
            return 44;
          case 16:
            this.popState();
            return 44;
          case 17:
            return 34;
          case 18:
            return 39;
          case 19:
            return 51;
          case 20:
            return 48;
          case 21:
            this.unput(yy_.yytext);
            this.popState();
            this.begin('com');
            break;
          case 22:
            this.popState();
            return 14;
          case 23:
            return 48;
          case 24:
            return 73;
          case 25:
            return 72;
          case 26:
            return 72;
          case 27:
            return 87;
          case 28:
            // ignore whitespace
            break;
          case 29:
            this.popState();
            return 54;
          case 30:
            this.popState();
            return 33;
          case 31:
            yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
            return 80;
          case 32:
            yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
            return 80;
          case 33:
            return 85;
          case 34:
            return 82;
          case 35:
            return 82;
          case 36:
            return 83;
          case 37:
            return 84;
          case 38:
            return 81;
          case 39:
            return 75;
          case 40:
            return 77;
          case 41:
            return 72;
          case 42:
            yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');
            return 72;
          case 43:
            return 'INVALID';
          case 44:
            return 5;
        }
      };
      lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
      lexer.conditions = {
        "mu": {
          "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
          "inclusive": false
        },
        "emu": {
          "rules": [2],
          "inclusive": false
        },
        "com": {
          "rules": [6],
          "inclusive": false
        },
        "raw": {
          "rules": [3, 4, 5],
          "inclusive": false
        },
        "INITIAL": {
          "rules": [0, 1, 44],
          "inclusive": true
        }
      };
      return lexer;
    }();
    parser.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();
  exports["default"] = handlebars;
  module.exports = exports["default"];
})(parser, parserExports);

var whitespaceControlExports = {};
var whitespaceControl = {
  get exports(){ return whitespaceControlExports; },
  set exports(v){ whitespaceControlExports = v; },
};

var visitorExports = {};
var visitor = {
  get exports(){ return visitorExports; },
  set exports(v){ visitorExports = v; },
};

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
  var _exception = exceptionExports;
  var _exception2 = _interopRequireDefault(_exception);
  function Visitor() {
    this.parents = [];
  }
  Visitor.prototype = {
    constructor: Visitor,
    mutating: false,
    // Visits a given value. If mutating, will replace the value if necessary.
    acceptKey: function acceptKey(node, name) {
      var value = this.accept(node[name]);
      if (this.mutating) {
        // Hacky sanity check: This may have a few false positives for type for the helper
        // methods but will generally do the right thing without a lot of overhead.
        if (value && !Visitor.prototype[value.type]) {
          throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
        }
        node[name] = value;
      }
    },
    // Performs an accept operation with added sanity check to ensure
    // required keys are not removed.
    acceptRequired: function acceptRequired(node, name) {
      this.acceptKey(node, name);
      if (!node[name]) {
        throw new _exception2['default'](node.type + ' requires ' + name);
      }
    },
    // Traverses a given array. If mutating, empty respnses will be removed
    // for child elements.
    acceptArray: function acceptArray(array) {
      for (var i = 0, l = array.length; i < l; i++) {
        this.acceptKey(array, i);
        if (!array[i]) {
          array.splice(i, 1);
          i--;
          l--;
        }
      }
    },
    accept: function accept(object) {
      if (!object) {
        return;
      }

      /* istanbul ignore next: Sanity code */
      if (!this[object.type]) {
        throw new _exception2['default']('Unknown type: ' + object.type, object);
      }
      if (this.current) {
        this.parents.unshift(this.current);
      }
      this.current = object;
      var ret = this[object.type](object);
      this.current = this.parents.shift();
      if (!this.mutating || ret) {
        return ret;
      } else if (ret !== false) {
        return object;
      }
    },
    Program: function Program(program) {
      this.acceptArray(program.body);
    },
    MustacheStatement: visitSubExpression,
    Decorator: visitSubExpression,
    BlockStatement: visitBlock,
    DecoratorBlock: visitBlock,
    PartialStatement: visitPartial,
    PartialBlockStatement: function PartialBlockStatement(partial) {
      visitPartial.call(this, partial);
      this.acceptKey(partial, 'program');
    },
    ContentStatement: function ContentStatement() /* content */{},
    CommentStatement: function CommentStatement() /* comment */{},
    SubExpression: visitSubExpression,
    PathExpression: function PathExpression() /* path */{},
    StringLiteral: function StringLiteral() /* string */{},
    NumberLiteral: function NumberLiteral() /* number */{},
    BooleanLiteral: function BooleanLiteral() /* bool */{},
    UndefinedLiteral: function UndefinedLiteral() /* literal */{},
    NullLiteral: function NullLiteral() /* literal */{},
    Hash: function Hash(hash) {
      this.acceptArray(hash.pairs);
    },
    HashPair: function HashPair(pair) {
      this.acceptRequired(pair, 'value');
    }
  };
  function visitSubExpression(mustache) {
    this.acceptRequired(mustache, 'path');
    this.acceptArray(mustache.params);
    this.acceptKey(mustache, 'hash');
  }
  function visitBlock(block) {
    visitSubExpression.call(this, block);
    this.acceptKey(block, 'program');
    this.acceptKey(block, 'inverse');
  }
  function visitPartial(partial) {
    this.acceptRequired(partial, 'name');
    this.acceptArray(partial.params);
    this.acceptKey(partial, 'hash');
  }
  exports['default'] = Visitor;
  module.exports = exports['default'];
})(visitor, visitorExports);

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
  var _visitor = visitorExports;
  var _visitor2 = _interopRequireDefault(_visitor);
  function WhitespaceControl() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    this.options = options;
  }
  WhitespaceControl.prototype = new _visitor2['default']();
  WhitespaceControl.prototype.Program = function (program) {
    var doStandalone = !this.options.ignoreStandalone;
    var isRoot = !this.isRootSeen;
    this.isRootSeen = true;
    var body = program.body;
    for (var i = 0, l = body.length; i < l; i++) {
      var current = body[i],
        strip = this.accept(current);
      if (!strip) {
        continue;
      }
      var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
        openStandalone = strip.openStandalone && _isPrevWhitespace,
        closeStandalone = strip.closeStandalone && _isNextWhitespace,
        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
      if (strip.close) {
        omitRight(body, i, true);
      }
      if (strip.open) {
        omitLeft(body, i, true);
      }
      if (doStandalone && inlineStandalone) {
        omitRight(body, i);
        if (omitLeft(body, i)) {
          // If we are on a standalone node, save the indent info for partials
          if (current.type === 'PartialStatement') {
            // Pull out the whitespace from the final line
            current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
          }
        }
      }
      if (doStandalone && openStandalone) {
        omitRight((current.program || current.inverse).body);

        // Strip out the previous content node if it's whitespace only
        omitLeft(body, i);
      }
      if (doStandalone && closeStandalone) {
        // Always strip the next node
        omitRight(body, i);
        omitLeft((current.inverse || current.program).body);
      }
    }
    return program;
  };
  WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
    this.accept(block.program);
    this.accept(block.inverse);

    // Find the inverse program that is involed with whitespace stripping.
    var program = block.program || block.inverse,
      inverse = block.program && block.inverse,
      firstInverse = inverse,
      lastInverse = inverse;
    if (inverse && inverse.chained) {
      firstInverse = inverse.body[0].program;

      // Walk the inverse chain to find the last inverse that is actually in the chain.
      while (lastInverse.chained) {
        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
      }
    }
    var strip = {
      open: block.openStrip.open,
      close: block.closeStrip.close,
      // Determine the standalone candiacy. Basically flag our content as being possibly standalone
      // so our parent can determine if we actually are standalone
      openStandalone: isNextWhitespace(program.body),
      closeStandalone: isPrevWhitespace((firstInverse || program).body)
    };
    if (block.openStrip.close) {
      omitRight(program.body, null, true);
    }
    if (inverse) {
      var inverseStrip = block.inverseStrip;
      if (inverseStrip.open) {
        omitLeft(program.body, null, true);
      }
      if (inverseStrip.close) {
        omitRight(firstInverse.body, null, true);
      }
      if (block.closeStrip.open) {
        omitLeft(lastInverse.body, null, true);
      }

      // Find standalone else statments
      if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
        omitLeft(program.body);
        omitRight(firstInverse.body);
      }
    } else if (block.closeStrip.open) {
      omitLeft(program.body, null, true);
    }
    return strip;
  };
  WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
    return mustache.strip;
  };
  WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
    /* istanbul ignore next */
    var strip = node.strip || {};
    return {
      inlineStandalone: true,
      open: strip.open,
      close: strip.close
    };
  };
  function isPrevWhitespace(body, i, isRoot) {
    if (i === undefined) {
      i = body.length;
    }

    // Nodes that end with newlines are considered whitespace (but are special
    // cased for strip operations)
    var prev = body[i - 1],
      sibling = body[i - 2];
    if (!prev) {
      return isRoot;
    }
    if (prev.type === 'ContentStatement') {
      return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
    }
  }
  function isNextWhitespace(body, i, isRoot) {
    if (i === undefined) {
      i = -1;
    }
    var next = body[i + 1],
      sibling = body[i + 2];
    if (!next) {
      return isRoot;
    }
    if (next.type === 'ContentStatement') {
      return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
    }
  }

  // Marks the node to the right of the position as omitted.
  // I.e. {{foo}}' ' will mark the ' ' node as omitted.
  //
  // If i is undefined, then the first child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitRight(body, i, multiple) {
    var current = body[i == null ? 0 : i + 1];
    if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
      return;
    }
    var original = current.value;
    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
    current.rightStripped = current.value !== original;
  }

  // Marks the node to the left of the position as omitted.
  // I.e. ' '{{foo}} will mark the ' ' node as omitted.
  //
  // If i is undefined then the last child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitLeft(body, i, multiple) {
    var current = body[i == null ? body.length - 1 : i - 1];
    if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
      return;
    }

    // We omit the last node if it's whitespace only and not preceded by a non-content node.
    var original = current.value;
    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
    current.leftStripped = current.value !== original;
    return current.leftStripped;
  }
  exports['default'] = WhitespaceControl;
  module.exports = exports['default'];
})(whitespaceControl, whitespaceControlExports);

var helpers = {};

helpers.__esModule = true;
helpers.SourceLocation = SourceLocation;
helpers.id = id$1;
helpers.stripFlags = stripFlags;
helpers.stripComment = stripComment;
helpers.preparePath = preparePath;
helpers.prepareMustache = prepareMustache;
helpers.prepareRawBlock = prepareRawBlock;
helpers.prepareBlock = prepareBlock;
helpers.prepareProgram = prepareProgram;
helpers.preparePartialBlock = preparePartialBlock;
// istanbul ignore next

function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _exception$1 = exceptionExports;
var _exception2$1 = _interopRequireDefault$3(_exception$1);
function validateClose(open, close) {
  close = close.path ? close.path.original : close;
  if (open.path.original !== close) {
    var errorNode = {
      loc: open.path.loc
    };
    throw new _exception2$1['default'](open.path.original + " doesn't match " + close, errorNode);
  }
}
function SourceLocation(source, locInfo) {
  this.source = source;
  this.start = {
    line: locInfo.first_line,
    column: locInfo.first_column
  };
  this.end = {
    line: locInfo.last_line,
    column: locInfo.last_column
  };
}
function id$1(token) {
  if (/^\[.*\]$/.test(token)) {
    return token.substring(1, token.length - 1);
  } else {
    return token;
  }
}
function stripFlags(open, close) {
  return {
    open: open.charAt(2) === '~',
    close: close.charAt(close.length - 3) === '~'
  };
}
function stripComment(comment) {
  return comment.replace(/^\{\{~?!-?-?/, '').replace(/-?-?~?\}\}$/, '');
}
function preparePath(data, parts, loc) {
  loc = this.locInfo(loc);
  var original = data ? '@' : '',
    dig = [],
    depth = 0;
  for (var i = 0, l = parts.length; i < l; i++) {
    var part = parts[i].part,
      // If we have [] syntax then we do not treat path references as operators,
      // i.e. foo.[this] resolves to approximately context.foo['this']
      isLiteral = parts[i].original !== part;
    original += (parts[i].separator || '') + part;
    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
      if (dig.length > 0) {
        throw new _exception2$1['default']('Invalid path: ' + original, {
          loc: loc
        });
      } else if (part === '..') {
        depth++;
      }
    } else {
      dig.push(part);
    }
  }
  return {
    type: 'PathExpression',
    data: data,
    depth: depth,
    parts: dig,
    original: original,
    loc: loc
  };
}
function prepareMustache(path, params, hash, open, strip, locInfo) {
  // Must use charAt to support IE pre-10
  var escapeFlag = open.charAt(3) || open.charAt(2),
    escaped = escapeFlag !== '{' && escapeFlag !== '&';
  var decorator = /\*/.test(open);
  return {
    type: decorator ? 'Decorator' : 'MustacheStatement',
    path: path,
    params: params,
    hash: hash,
    escaped: escaped,
    strip: strip,
    loc: this.locInfo(locInfo)
  };
}
function prepareRawBlock(openRawBlock, contents, close, locInfo) {
  validateClose(openRawBlock, close);
  locInfo = this.locInfo(locInfo);
  var program = {
    type: 'Program',
    body: contents,
    strip: {},
    loc: locInfo
  };
  return {
    type: 'BlockStatement',
    path: openRawBlock.path,
    params: openRawBlock.params,
    hash: openRawBlock.hash,
    program: program,
    openStrip: {},
    inverseStrip: {},
    closeStrip: {},
    loc: locInfo
  };
}
function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
  if (close && close.path) {
    validateClose(openBlock, close);
  }
  var decorator = /\*/.test(openBlock.open);
  program.blockParams = openBlock.blockParams;
  var inverse = undefined,
    inverseStrip = undefined;
  if (inverseAndProgram) {
    if (decorator) {
      throw new _exception2$1['default']('Unexpected inverse block on decorator', inverseAndProgram);
    }
    if (inverseAndProgram.chain) {
      inverseAndProgram.program.body[0].closeStrip = close.strip;
    }
    inverseStrip = inverseAndProgram.strip;
    inverse = inverseAndProgram.program;
  }
  if (inverted) {
    inverted = inverse;
    inverse = program;
    program = inverted;
  }
  return {
    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
    path: openBlock.path,
    params: openBlock.params,
    hash: openBlock.hash,
    program: program,
    inverse: inverse,
    openStrip: openBlock.strip,
    inverseStrip: inverseStrip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}
function prepareProgram(statements, loc) {
  if (!loc && statements.length) {
    var firstLoc = statements[0].loc,
      lastLoc = statements[statements.length - 1].loc;

    /* istanbul ignore else */
    if (firstLoc && lastLoc) {
      loc = {
        source: firstLoc.source,
        start: {
          line: firstLoc.start.line,
          column: firstLoc.start.column
        },
        end: {
          line: lastLoc.end.line,
          column: lastLoc.end.column
        }
      };
    }
  }
  return {
    type: 'Program',
    body: statements,
    strip: {},
    loc: loc
  };
}
function preparePartialBlock(open, program, close, locInfo) {
  validateClose(open, close);
  return {
    type: 'PartialBlockStatement',
    name: open.path,
    params: open.params,
    hash: open.hash,
    program: program,
    openStrip: open.strip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}

base$1.__esModule = true;
base$1.parseWithoutProcessing = parseWithoutProcessing;
base$1.parse = parse$1;
// istanbul ignore next

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj['default'] = obj;
    return newObj;
  }
}

// istanbul ignore next

function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _parser = parserExports;
var _parser2 = _interopRequireDefault$2(_parser);
var _whitespaceControl = whitespaceControlExports;
var _whitespaceControl2 = _interopRequireDefault$2(_whitespaceControl);
var _helpers = helpers;
var Helpers = _interopRequireWildcard(_helpers);
var _utils$1 = utils$c;
base$1.parser = _parser2['default'];
var yy = {};
_utils$1.extend(yy, Helpers);
function parseWithoutProcessing(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }
  _parser2['default'].yy = yy;

  // Altering the shared object here, but this is ok as parser is a sync operation
  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };
  var ast = _parser2['default'].parse(input);
  return ast;
}
function parse$1(input, options) {
  var ast = parseWithoutProcessing(input, options);
  var strip = new _whitespaceControl2['default'](options);
  return strip.accept(ast);
}

var compiler = {};

/* eslint-disable new-cap */
compiler.__esModule = true;
compiler.Compiler = Compiler;
compiler.precompile = precompile;
compiler.compile = compile;
// istanbul ignore next

function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _exception = exceptionExports;
var _exception2 = _interopRequireDefault$1(_exception);
var _utils = utils$c;
var _ast = astExports;
var _ast2 = _interopRequireDefault$1(_ast);
var slice = [].slice;
function Compiler() {}

// the foundHelper register will disambiguate helper lookup from finding a
// function in a context. This is necessary for mustache compatibility, which
// requires that context functions in blocks are evaluated by blockHelperMissing,
// and then proceed as if the resulting value was provided to blockHelperMissing.

Compiler.prototype = {
  compiler: Compiler,
  equals: function equals(other) {
    var len = this.opcodes.length;
    if (other.opcodes.length !== len) {
      return false;
    }
    for (var i = 0; i < len; i++) {
      var opcode = this.opcodes[i],
        otherOpcode = other.opcodes[i];
      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
        return false;
      }
    }

    // We know that length is the same between the two arrays because they are directly tied
    // to the opcode behavior above.
    len = this.children.length;
    for (var i = 0; i < len; i++) {
      if (!this.children[i].equals(other.children[i])) {
        return false;
      }
    }
    return true;
  },
  guid: 0,
  compile: function compile(program, options) {
    this.sourceNode = [];
    this.opcodes = [];
    this.children = [];
    this.options = options;
    this.stringParams = options.stringParams;
    this.trackIds = options.trackIds;
    options.blockParams = options.blockParams || [];
    options.knownHelpers = _utils.extend(Object.create(null), {
      helperMissing: true,
      blockHelperMissing: true,
      each: true,
      'if': true,
      unless: true,
      'with': true,
      log: true,
      lookup: true
    }, options.knownHelpers);
    return this.accept(program);
  },
  compileProgram: function compileProgram(program) {
    var childCompiler = new this.compiler(),
      // eslint-disable-line new-cap
      result = childCompiler.compile(program, this.options),
      guid = this.guid++;
    this.usePartial = this.usePartial || result.usePartial;
    this.children[guid] = result;
    this.useDepths = this.useDepths || result.useDepths;
    return guid;
  },
  accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
      throw new _exception2['default']('Unknown type: ' + node.type, node);
    }
    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
  },
  Program: function Program(program) {
    this.options.blockParams.unshift(program.blockParams);
    var body = program.body,
      bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
      this.accept(body[i]);
    }
    this.options.blockParams.shift();
    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;
    return this;
  },
  BlockStatement: function BlockStatement(block) {
    transformLiteralToPath(block);
    var program = block.program,
      inverse = block.inverse;
    program = program && this.compileProgram(program);
    inverse = inverse && this.compileProgram(inverse);
    var type = this.classifySexpr(block);
    if (type === 'helper') {
      this.helperSexpr(block, program, inverse);
    } else if (type === 'simple') {
      this.simpleSexpr(block);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('blockValue', block.path.original);
    } else {
      this.ambiguousSexpr(block, program, inverse);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('ambiguousBlockValue');
    }
    this.opcode('append');
  },
  DecoratorBlock: function DecoratorBlock(decorator) {
    var program = decorator.program && this.compileProgram(decorator.program);
    var params = this.setupFullMustacheParams(decorator, program, undefined),
      path = decorator.path;
    this.useDecorators = true;
    this.opcode('registerDecorator', params.length, path.original);
  },
  PartialStatement: function PartialStatement(partial) {
    this.usePartial = true;
    var program = partial.program;
    if (program) {
      program = this.compileProgram(partial.program);
    }
    var params = partial.params;
    if (params.length > 1) {
      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
    } else if (!params.length) {
      if (this.options.explicitPartialContext) {
        this.opcode('pushLiteral', 'undefined');
      } else {
        params.push({
          type: 'PathExpression',
          parts: [],
          depth: 0
        });
      }
    }
    var partialName = partial.name.original,
      isDynamic = partial.name.type === 'SubExpression';
    if (isDynamic) {
      this.accept(partial.name);
    }
    this.setupFullMustacheParams(partial, program, undefined, true);
    var indent = partial.indent || '';
    if (this.options.preventIndent && indent) {
      this.opcode('appendContent', indent);
      indent = '';
    }
    this.opcode('invokePartial', isDynamic, partialName, indent);
    this.opcode('append');
  },
  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
    this.PartialStatement(partialBlock);
  },
  MustacheStatement: function MustacheStatement(mustache) {
    this.SubExpression(mustache);
    if (mustache.escaped && !this.options.noEscape) {
      this.opcode('appendEscaped');
    } else {
      this.opcode('append');
    }
  },
  Decorator: function Decorator(decorator) {
    this.DecoratorBlock(decorator);
  },
  ContentStatement: function ContentStatement(content) {
    if (content.value) {
      this.opcode('appendContent', content.value);
    }
  },
  CommentStatement: function CommentStatement() {},
  SubExpression: function SubExpression(sexpr) {
    transformLiteralToPath(sexpr);
    var type = this.classifySexpr(sexpr);
    if (type === 'simple') {
      this.simpleSexpr(sexpr);
    } else if (type === 'helper') {
      this.helperSexpr(sexpr);
    } else {
      this.ambiguousSexpr(sexpr);
    }
  },
  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
    var path = sexpr.path,
      name = path.parts[0],
      isBlock = program != null || inverse != null;
    this.opcode('getContext', path.depth);
    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);
    path.strict = true;
    this.accept(path);
    this.opcode('invokeAmbiguous', name, isBlock);
  },
  simpleSexpr: function simpleSexpr(sexpr) {
    var path = sexpr.path;
    path.strict = true;
    this.accept(path);
    this.opcode('resolvePossibleLambda');
  },
  helperSexpr: function helperSexpr(sexpr, program, inverse) {
    var params = this.setupFullMustacheParams(sexpr, program, inverse),
      path = sexpr.path,
      name = path.parts[0];
    if (this.options.knownHelpers[name]) {
      this.opcode('invokeKnownHelper', params.length, name);
    } else if (this.options.knownHelpersOnly) {
      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
    } else {
      path.strict = true;
      path.falsy = true;
      this.accept(path);
      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
    }
  },
  PathExpression: function PathExpression(path) {
    this.addDepth(path.depth);
    this.opcode('getContext', path.depth);
    var name = path.parts[0],
      scoped = _ast2['default'].helpers.scopedId(path),
      blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
    if (blockParamId) {
      this.opcode('lookupBlockParam', blockParamId, path.parts);
    } else if (!name) {
      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
      this.opcode('pushContext');
    } else if (path.data) {
      this.options.data = true;
      this.opcode('lookupData', path.depth, path.parts, path.strict);
    } else {
      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
    }
  },
  StringLiteral: function StringLiteral(string) {
    this.opcode('pushString', string.value);
  },
  NumberLiteral: function NumberLiteral(number) {
    this.opcode('pushLiteral', number.value);
  },
  BooleanLiteral: function BooleanLiteral(bool) {
    this.opcode('pushLiteral', bool.value);
  },
  UndefinedLiteral: function UndefinedLiteral() {
    this.opcode('pushLiteral', 'undefined');
  },
  NullLiteral: function NullLiteral() {
    this.opcode('pushLiteral', 'null');
  },
  Hash: function Hash(hash) {
    var pairs = hash.pairs,
      i = 0,
      l = pairs.length;
    this.opcode('pushHash');
    for (; i < l; i++) {
      this.pushParam(pairs[i].value);
    }
    while (i--) {
      this.opcode('assignToHash', pairs[i].key);
    }
    this.opcode('popHash');
  },
  // HELPERS
  opcode: function opcode(name) {
    this.opcodes.push({
      opcode: name,
      args: slice.call(arguments, 1),
      loc: this.sourceNode[0].loc
    });
  },
  addDepth: function addDepth(depth) {
    if (!depth) {
      return;
    }
    this.useDepths = true;
  },
  classifySexpr: function classifySexpr(sexpr) {
    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);
    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

    // a mustache is an eligible helper if:
    // * its id is simple (a single part, not `this` or `..`)
    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

    // if a mustache is an eligible helper but not a definite
    // helper, it is ambiguous, and will be resolved in a later
    // pass or at runtime.
    var isEligible = !isBlockParam && (isHelper || isSimple);

    // if ambiguous, we can possibly resolve the ambiguity now
    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
    if (isEligible && !isHelper) {
      var _name = sexpr.path.parts[0],
        options = this.options;
      if (options.knownHelpers[_name]) {
        isHelper = true;
      } else if (options.knownHelpersOnly) {
        isEligible = false;
      }
    }
    if (isHelper) {
      return 'helper';
    } else if (isEligible) {
      return 'ambiguous';
    } else {
      return 'simple';
    }
  },
  pushParams: function pushParams(params) {
    for (var i = 0, l = params.length; i < l; i++) {
      this.pushParam(params[i]);
    }
  },
  pushParam: function pushParam(val) {
    var value = val.value != null ? val.value : val.original || '';
    if (this.stringParams) {
      if (value.replace) {
        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
      }
      if (val.depth) {
        this.addDepth(val.depth);
      }
      this.opcode('getContext', val.depth || 0);
      this.opcode('pushStringParam', value, val.type);
      if (val.type === 'SubExpression') {
        // SubExpressions get evaluated and passed in
        // in string params mode.
        this.accept(val);
      }
    } else {
      if (this.trackIds) {
        var blockParamIndex = undefined;
        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
          blockParamIndex = this.blockParamIndex(val.parts[0]);
        }
        if (blockParamIndex) {
          var blockParamChild = val.parts.slice(1).join('.');
          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
        } else {
          value = val.original || value;
          if (value.replace) {
            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
          }
          this.opcode('pushId', val.type, value);
        }
      }
      this.accept(val);
    }
  },
  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
    var params = sexpr.params;
    this.pushParams(params);
    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);
    if (sexpr.hash) {
      this.accept(sexpr.hash);
    } else {
      this.opcode('emptyHash', omitEmpty);
    }
    return params;
  },
  blockParamIndex: function blockParamIndex(name) {
    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
      var blockParams = this.options.blockParams[depth],
        param = blockParams && _utils.indexOf(blockParams, name);
      if (blockParams && param >= 0) {
        return [depth, param];
      }
    }
  }
};
function precompile(input, options, env) {
  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
  }
  options = options || {};
  if (!('data' in options)) {
    options.data = true;
  }
  if (options.compat) {
    options.useDepths = true;
  }
  var ast = env.parse(input, options),
    environment = new env.Compiler().compile(ast, options);
  return new env.JavaScriptCompiler().compile(environment, options);
}
function compile(input, options, env) {
  if (options === undefined) options = {};
  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
  }
  options = _utils.extend({}, options);
  if (!('data' in options)) {
    options.data = true;
  }
  if (options.compat) {
    options.useDepths = true;
  }
  var compiled = undefined;
  function compileInput() {
    var ast = env.parse(input, options),
      environment = new env.Compiler().compile(ast, options),
      templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
    return env.template(templateSpec);
  }

  // Template is only compiled on first use and cached after that point.
  function ret(context, execOptions) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled.call(this, context, execOptions);
  }
  ret._setup = function (setupOptions) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled._setup(setupOptions);
  };
  ret._child = function (i, data, blockParams, depths) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled._child(i, data, blockParams, depths);
  };
  return ret;
}
function argEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (!argEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
}
function transformLiteralToPath(sexpr) {
  if (!sexpr.path.parts) {
    var literal = sexpr.path;
    // Casting to string here to make false and 0 literal values play nicely with the rest
    // of the system.
    sexpr.path = {
      type: 'PathExpression',
      data: false,
      depth: 0,
      parts: [literal.original + ''],
      original: literal.original + '',
      loc: literal.loc
    };
  }
}

var javascriptCompilerExports = {};
var javascriptCompiler = {
  get exports(){ return javascriptCompilerExports; },
  set exports(v){ javascriptCompilerExports = v; },
};

var codeGenExports = {};
var codeGen = {
  get exports(){ return codeGenExports; },
  set exports(v){ codeGenExports = v; },
};

var sourceMap = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  base64.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  base64.decode = function (charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'

    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'

    var zero = 48; // '0'
    var nine = 57; // '9'

    var plus = 43; // '+'
    var slash = 47; // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };
  return base64;
}

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

  var base64 = requireBase64();

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return base64Vlq;
}

var util$2 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$2;
  hasRequiredUtil = 1;
  (function (exports) {
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */

    /**
     * This is a helper function for getting values from parameter/options
     * objects.
     *
     * @param args The object we are extracting values from
     * @param name The name of the property we are getting.
     * @param defaultValue An optional value to return if the property is missing
     * from the object. If this is not specified and the property is missing, an
     * error will be thrown.
     */
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = '';
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
      }
      url += '//';
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;

    /**
     * Normalizes a path, or the path portion of a URL:
     *
     * - Replaces consecutive slashes with one slash.
     * - Removes unnecessary '.' parts.
     * - Removes unnecessary '<dir>/..' parts.
     *
     * Based on code in the Node.js 'path' core module.
     *
     * @param aPath The path or url to normalize.
     */
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === '.') {
          parts.splice(i, 1);
        } else if (part === '..') {
          up++;
        } else if (up > 0) {
          if (part === '') {
            // The first part is blank if the path is absolute. Trying to go
            // above the root is a no-op. Therefore we can remove all '..' parts
            // directly after the root.
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join('/');
      if (path === '') {
        path = isAbsolute ? '/' : '.';
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;

    /**
     * Joins two paths/URLs.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be joined with the root.
     *
     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
     *   first.
     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
     *   is updated with the result and aRoot is returned. Otherwise the result
     *   is returned.
     *   - If aPath is absolute, the result is aPath.
     *   - Otherwise the two paths are joined with a slash.
     * - Joining for example 'http://' and 'www.example.com' is also supported.
     */
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
      }

      // `join(foo, '//www.example.org')`
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }

      // `join('http://', 'www.example.com')`
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
    };

    /**
     * Make a path relative to a URL or another path.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be made relative to aRoot.
     */
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, '');

      // It is possible for the path to be above the root. In this case, simply
      // checking whether the root is a prefix of the path won't work. Instead, we
      // need to remove components from the root one by one, until either we find
      // a prefix that fits, or we run out of components to remove.
      var level = 0;
      while (aPath.indexOf(aRoot + '/') !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }

        // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }

      // Make sure we add a "../" for each component we removed from the root.
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function () {
      var obj = Object.create(null);
      return !('__proto__' in obj);
    }();
    function identity(s) {
      return s;
    }

    /**
     * Because behavior goes wacky when you set `__proto__` on objects, we
     * have to prefix all the strings in our set with an arbitrary character.
     *
     * See https://github.com/mozilla/source-map/pull/31 and
     * https://github.com/mozilla/source-map/issues/30
     *
     * @param String aStr
     */
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return '$' + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9 /* "__proto__".length */) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36 /* '$' */) {
          return false;
        }
      }
      return true;
    }

    /**
     * Comparator between two mappings where the original positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same original source/line/column, but different generated
     * line and column the same. Useful when searching for a mapping with a
     * stubbed out mapping.
     */
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;

    /**
     * Comparator between two mappings with deflated source and name indices where
     * the generated positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same generated line and column, but different
     * source/name/original line and column the same. Useful when searching for a
     * mapping with a stubbed out mapping.
     */
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1; // aStr2 !== null
      }

      if (aStr2 === null) {
        return -1; // aStr1 !== null
      }

      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }

    /**
     * Comparator between two mappings with inflated source and name strings where
     * the generated positions are compared.
     */
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

    /**
     * Strip any JSON XSSI avoidance prefix from the string (as documented
     * in the source maps specification), and then parse the string as
     * JSON.
     */
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
    }
    exports.parseSourceMapInput = parseSourceMapInput;

    /**
     * Compute the URL of a source given the the source root, the source's
     * URL, and the source map's URL.
     */
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || '';
      if (sourceRoot) {
        // This follows what Chrome does.
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
          sourceRoot += '/';
        }
        // The spec says:
        //   Line 4: An optional source root, useful for relocating source
        //   files on a server or removing repeated values in the
        //   “sources” entry.  This value is prepended to the individual
        //   entries in the “source” field.
        sourceURL = sourceRoot + sourceURL;
      }

      // Historically, SourceMapConsumer did not take the sourceMapURL as
      // a parameter.  This mode is still somewhat supported, which is why
      // this code block is conditional.  However, it's preferable to pass
      // the source map URL to SourceMapConsumer, so that this function
      // can implement the source URL resolution algorithm as outlined in
      // the spec.  This block is basically the equivalent of:
      //    new URL(sourceURL, sourceMapURL).toString()
      // ... except it avoids using URL, which wasn't available in the
      // older releases of node still supported by this library.
      //
      // The spec says:
      //   If the sources are not absolute URLs after prepending of the
      //   “sourceRoot”, the sources are resolved relative to the
      //   SourceMap (like resolving script src in a html document).
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          // Strip the last path component, but keep the "/".
          var index = parsed.path.lastIndexOf('/');
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  })(util$2);
  return util$2;
}

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = requireUtil();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet;
  return arraySet;
}

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = requireUtil();

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList;
  return mappingList;
}

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var base64VLQ = requireBase64Vlq();
  var util = requireUtil();
  var ArraySet = requireArraySet().ArraySet;
  var MappingList = requireMappingList().MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
    }
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      // Cases 2 and 3.
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  return sourceMapGenerator;
}

var sourceMapConsumer = {};

var binarySearch = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredBinarySearch;
function requireBinarySearch() {
  if (hasRequiredBinarySearch) return binarySearch;
  hasRequiredBinarySearch = 1;
  (function (exports) {
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */

    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;

    /**
     * Recursive implementation of binary search.
     *
     * @param aLow Indices here and lower do not contain the needle.
     * @param aHigh Indices here and higher do not contain the needle.
     * @param aNeedle The element being searched for.
     * @param aHaystack The non-empty array being searched.
     * @param aCompare Function which takes two elements and returns -1, 0, or 1.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     */
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      // This function terminates when one of the following is true:
      //
      //   1. We find the exact element we are looking for.
      //
      //   2. We did not find the exact element, but we can return the index of
      //      the next-closest element.
      //
      //   3. We did not find the exact element, and there is no next-closest
      //      element than the one we are searching for, so we return -1.
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        // Found the element we are looking for.
        return mid;
      } else if (cmp > 0) {
        // Our needle is greater than aHaystack[mid].
        if (aHigh - mid > 1) {
          // The element is in the upper half.
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }

        // The exact needle element was not found in this haystack. Determine if
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        // Our needle is less than aHaystack[mid].
        if (mid - aLow > 1) {
          // The element is in the lower half.
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }

        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }

    /**
     * This is an implementation of binary search which will always try and return
     * the index of the closest element if there is no exact hit. This is because
     * mappings between original and generated line/col pairs are single points,
     * and there is an implicit region between each of them, so a miss just means
     * that you aren't on the very start of a region.
     *
     * @param aNeedle The element you are looking for.
     * @param aHaystack The array that is being searched.
     * @param aCompare A function which takes the needle and an element in the
     *     array and returns -1, 0, or 1 depending on whether the needle is less
     *     than, equal to, or greater than the element, respectively.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
     */
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }

      // We have found either the exact element, or the next-closest element than
      // the one we are searching for. However, there may be more than one such
      // element. Make sure we always return the smallest of these.
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  })(binarySearch);
  return binarySearch;
}

var quickSort = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort) return quickSort;
  hasRequiredQuickSort = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  quickSort.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
  return quickSort;
}

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = requireUtil();
  var binarySearch = requireBinarySearch();
  var ArraySet = requireArraySet().ArraySet;
  var base64VLQ = requireBase64Vlq();
  var quickSort = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The first parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function (s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._absoluteSources.slice();
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }
          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }
          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The first parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  return sourceMapConsumer;
}

var sourceNode = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode) return sourceNode;
  hasRequiredSourceNode = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  var util = requireUtil();

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function () {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1,
      lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };
  sourceNode.SourceNode = SourceNode;
  return sourceNode;
}

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  sourceMap.SourceNode = requireSourceNode().SourceNode;
  return sourceMap;
}

/* global define */
(function (module, exports) {

  exports.__esModule = true;
  var _utils = utils$c;
  var SourceNode = undefined;
  try {
    /* istanbul ignore next */
    if (typeof undefined !== 'function' || !undefined.amd) {
      // We don't support this in AMD environments. For these environments, we asusme that
      // they are running on the browser and thus have no need for the source-map library.
      var SourceMap = requireSourceMap();
      SourceNode = SourceMap.SourceNode;
    }
  } catch (err) {}
  /* NOP */

  /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
  if (!SourceNode) {
    SourceNode = function (line, column, srcFile, chunks) {
      this.src = '';
      if (chunks) {
        this.add(chunks);
      }
    };
    /* istanbul ignore next */
    SourceNode.prototype = {
      add: function add(chunks) {
        if (_utils.isArray(chunks)) {
          chunks = chunks.join('');
        }
        this.src += chunks;
      },
      prepend: function prepend(chunks) {
        if (_utils.isArray(chunks)) {
          chunks = chunks.join('');
        }
        this.src = chunks + this.src;
      },
      toStringWithSourceMap: function toStringWithSourceMap() {
        return {
          code: this.toString()
        };
      },
      toString: function toString() {
        return this.src;
      }
    };
  }
  function castChunk(chunk, codeGen, loc) {
    if (_utils.isArray(chunk)) {
      var ret = [];
      for (var i = 0, len = chunk.length; i < len; i++) {
        ret.push(codeGen.wrap(chunk[i], loc));
      }
      return ret;
    } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
      // Handle primitives that the SourceNode will throw up on
      return chunk + '';
    }
    return chunk;
  }
  function CodeGen(srcFile) {
    this.srcFile = srcFile;
    this.source = [];
  }
  CodeGen.prototype = {
    isEmpty: function isEmpty() {
      return !this.source.length;
    },
    prepend: function prepend(source, loc) {
      this.source.unshift(this.wrap(source, loc));
    },
    push: function push(source, loc) {
      this.source.push(this.wrap(source, loc));
    },
    merge: function merge() {
      var source = this.empty();
      this.each(function (line) {
        source.add(['  ', line, '\n']);
      });
      return source;
    },
    each: function each(iter) {
      for (var i = 0, len = this.source.length; i < len; i++) {
        iter(this.source[i]);
      }
    },
    empty: function empty() {
      var loc = this.currentLocation || {
        start: {}
      };
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
    },
    wrap: function wrap(chunk) {
      var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || {
        start: {}
      } : arguments[1];
      if (chunk instanceof SourceNode) {
        return chunk;
      }
      chunk = castChunk(chunk, this, loc);
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
    },
    functionCall: function functionCall(fn, type, params) {
      params = this.generateList(params);
      return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
    },
    quotedString: function quotedString(str) {
      return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
      .replace(/\u2029/g, '\\u2029') + '"';
    },
    objectLiteral: function objectLiteral(obj) {
      // istanbul ignore next

      var _this = this;
      var pairs = [];
      Object.keys(obj).forEach(function (key) {
        var value = castChunk(obj[key], _this);
        if (value !== 'undefined') {
          pairs.push([_this.quotedString(key), ':', value]);
        }
      });
      var ret = this.generateList(pairs);
      ret.prepend('{');
      ret.add('}');
      return ret;
    },
    generateList: function generateList(entries) {
      var ret = this.empty();
      for (var i = 0, len = entries.length; i < len; i++) {
        if (i) {
          ret.add(',');
        }
        ret.add(castChunk(entries[i], this));
      }
      return ret;
    },
    generateArray: function generateArray(entries) {
      var ret = this.generateList(entries);
      ret.prepend('[');
      ret.add(']');
      return ret;
    }
  };
  exports['default'] = CodeGen;
  module.exports = exports['default'];
})(codeGen, codeGenExports);

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
  var _base = base$2;
  var _exception = exceptionExports;
  var _exception2 = _interopRequireDefault(_exception);
  var _utils = utils$c;
  var _codeGen = codeGenExports;
  var _codeGen2 = _interopRequireDefault(_codeGen);
  function Literal(value) {
    this.value = value;
  }
  function JavaScriptCompiler() {}
  JavaScriptCompiler.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function nameLookup(parent, name /*,  type */) {
      return this.internalNameLookup(parent, name);
    },
    depthedLookup: function depthedLookup(name) {
      return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];
    },
    compilerInfo: function compilerInfo() {
      var revision = _base.COMPILER_REVISION,
        versions = _base.REVISION_CHANGES[revision];
      return [revision, versions];
    },
    appendToBuffer: function appendToBuffer(source, location, explicit) {
      // Force a source as this simplifies the merge logic.
      if (!_utils.isArray(source)) {
        source = [source];
      }
      source = this.source.wrap(source, location);
      if (this.environment.isSimple) {
        return ['return ', source, ';'];
      } else if (explicit) {
        // This is a case where the buffer operation occurs as a child of another
        // construct, generally braces. We have to explicitly output these buffer
        // operations to ensure that the emitted code goes in the correct location.
        return ['buffer += ', source, ';'];
      } else {
        source.appendToBuffer = true;
        return source;
      }
    },
    initializeBuffer: function initializeBuffer() {
      return this.quotedString('');
    },
    // END PUBLIC API
    internalNameLookup: function internalNameLookup(parent, name) {
      this.lookupPropertyFunctionIsUsed = true;
      return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];
    },
    lookupPropertyFunctionIsUsed: false,
    compile: function compile(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options;
      this.stringParams = this.options.stringParams;
      this.trackIds = this.options.trackIds;
      this.precompile = !asObject;
      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        decorators: [],
        programs: [],
        environments: []
      };
      this.preamble();
      this.stackSlot = 0;
      this.stackVars = [];
      this.aliases = {};
      this.registers = {
        list: []
      };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];
      this.blockParams = [];
      this.compileChildren(environment, options);
      this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
      this.useBlockParams = this.useBlockParams || environment.useBlockParams;
      var opcodes = environment.opcodes,
        opcode = undefined,
        firstLoc = undefined,
        i = undefined,
        l = undefined;
      for (i = 0, l = opcodes.length; i < l; i++) {
        opcode = opcodes[i];
        this.source.currentLocation = opcode.loc;
        firstLoc = firstLoc || opcode.loc;
        this[opcode.opcode].apply(this, opcode.args);
      }

      // Flush any trailing content that might be pending.
      this.source.currentLocation = firstLoc;
      this.pushSource('');

      /* istanbul ignore next */
      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new _exception2['default']('Compile completed with content left on stack');
      }
      if (!this.decorators.isEmpty()) {
        this.useDecorators = true;
        this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\n']);
        this.decorators.push('return fn;');
        if (asObject) {
          this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
        } else {
          this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
          this.decorators.push('}\n');
          this.decorators = this.decorators.merge();
        }
      } else {
        this.decorators = undefined;
      }
      var fn = this.createFunctionContext(asObject);
      if (!this.isChild) {
        var ret = {
          compiler: this.compilerInfo(),
          main: fn
        };
        if (this.decorators) {
          ret.main_d = this.decorators; // eslint-disable-line camelcase
          ret.useDecorators = true;
        }
        var _context = this.context;
        var programs = _context.programs;
        var decorators = _context.decorators;
        for (i = 0, l = programs.length; i < l; i++) {
          if (programs[i]) {
            ret[i] = programs[i];
            if (decorators[i]) {
              ret[i + '_d'] = decorators[i];
              ret.useDecorators = true;
            }
          }
        }
        if (this.environment.usePartial) {
          ret.usePartial = true;
        }
        if (this.options.data) {
          ret.useData = true;
        }
        if (this.useDepths) {
          ret.useDepths = true;
        }
        if (this.useBlockParams) {
          ret.useBlockParams = true;
        }
        if (this.options.compat) {
          ret.compat = true;
        }
        if (!asObject) {
          ret.compiler = JSON.stringify(ret.compiler);
          this.source.currentLocation = {
            start: {
              line: 1,
              column: 0
            }
          };
          ret = this.objectLiteral(ret);
          if (options.srcName) {
            ret = ret.toStringWithSourceMap({
              file: options.destName
            });
            ret.map = ret.map && ret.map.toString();
          } else {
            ret = ret.toString();
          }
        } else {
          ret.compilerOptions = this.options;
        }
        return ret;
      } else {
        return fn;
      }
    },
    preamble: function preamble() {
      // track the last context pushed into place to allow skipping the
      // getContext opcode when it would be a noop
      this.lastContext = 0;
      this.source = new _codeGen2['default'](this.options.srcName);
      this.decorators = new _codeGen2['default'](this.options.srcName);
    },
    createFunctionContext: function createFunctionContext(asObject) {
      // istanbul ignore next

      var _this = this;
      var varDeclarations = '';
      var locals = this.stackVars.concat(this.registers.list);
      if (locals.length > 0) {
        varDeclarations += ', ' + locals.join(', ');
      }

      // Generate minimizer alias mappings
      //
      // When using true SourceNodes, this will update all references to the given alias
      // as the source nodes are reused in situ. For the non-source node compilation mode,
      // aliases will not be used, but this case is already being run on the client and
      // we aren't concern about minimizing the template size.
      var aliasCount = 0;
      Object.keys(this.aliases).forEach(function (alias) {
        var node = _this.aliases[alias];
        if (node.children && node.referenceCount > 1) {
          varDeclarations += ', alias' + ++aliasCount + '=' + alias;
          node.children[0] = 'alias' + aliasCount;
        }
      });
      if (this.lookupPropertyFunctionIsUsed) {
        varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();
      }
      var params = ['container', 'depth0', 'helpers', 'partials', 'data'];
      if (this.useBlockParams || this.useDepths) {
        params.push('blockParams');
      }
      if (this.useDepths) {
        params.push('depths');
      }

      // Perform a second pass over the output to merge content when possible
      var source = this.mergeSource(varDeclarations);
      if (asObject) {
        params.push(source);
        return Function.apply(this, params);
      } else {
        return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
      }
    },
    mergeSource: function mergeSource(varDeclarations) {
      var isSimple = this.environment.isSimple,
        appendOnly = !this.forceBuffer,
        appendFirst = undefined,
        sourceSeen = undefined,
        bufferStart = undefined,
        bufferEnd = undefined;
      this.source.each(function (line) {
        if (line.appendToBuffer) {
          if (bufferStart) {
            line.prepend('  + ');
          } else {
            bufferStart = line;
          }
          bufferEnd = line;
        } else {
          if (bufferStart) {
            if (!sourceSeen) {
              appendFirst = true;
            } else {
              bufferStart.prepend('buffer += ');
            }
            bufferEnd.add(';');
            bufferStart = bufferEnd = undefined;
          }
          sourceSeen = true;
          if (!isSimple) {
            appendOnly = false;
          }
        }
      });
      if (appendOnly) {
        if (bufferStart) {
          bufferStart.prepend('return ');
          bufferEnd.add(';');
        } else if (!sourceSeen) {
          this.source.push('return "";');
        }
      } else {
        varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());
        if (bufferStart) {
          bufferStart.prepend('return buffer + ');
          bufferEnd.add(';');
        } else {
          this.source.push('return buffer;');
        }
      }
      if (varDeclarations) {
        this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
      }
      return this.source.merge();
    },
    lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
      return '\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    '.trim();
    },
    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function blockValue(name) {
      var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
        params = [this.contextName(0)];
      this.setupHelperArgs(name, 0, params);
      var blockName = this.popStack();
      params.splice(1, 0, blockName);
      this.push(this.source.functionCall(blockHelperMissing, 'call', params));
    },
    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function ambiguousBlockValue() {
      // We're being a bit cheeky and reusing the options value from the prior exec
      var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
        params = [this.contextName(0)];
      this.setupHelperArgs('', 0, params, true);
      this.flushInline();
      var current = this.topStack();
      params.splice(1, 0, current);
      this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
    },
    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function appendContent(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      } else {
        this.pendingLocation = this.source.currentLocation;
      }
      this.pendingContent = content;
    },
    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function append() {
      if (this.isInline()) {
        this.replaceStack(function (current) {
          return [' != null ? ', current, ' : ""'];
        });
        this.pushSource(this.appendToBuffer(this.popStack()));
      } else {
        var local = this.popStack();
        this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
        if (this.environment.isSimple) {
          this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
        }
      }
    },
    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function appendEscaped() {
      this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
    },
    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function getContext(depth) {
      this.lastContext = depth;
    },
    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function pushContext() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },
    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
      var i = 0;
      if (!scoped && this.options.compat && !this.lastContext) {
        // The depthed query is expected to handle the undefined logic for the root level that
        // is implemented below, so we evaluate that directly in compat mode
        this.push(this.depthedLookup(parts[i++]));
      } else {
        this.pushContext();
      }
      this.resolvePath('context', parts, i, falsy, strict);
    },
    // [lookupBlockParam]
    //
    // On stack, before: ...
    // On stack, after: blockParam[name], ...
    //
    // Looks up the value of `parts` on the given block param and pushes
    // it onto the stack.
    lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
      this.useBlockParams = true;
      this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
      this.resolvePath('context', parts, 1);
    },
    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data, ...
    //
    // Push the data lookup operator
    lookupData: function lookupData(depth, parts, strict) {
      if (!depth) {
        this.pushStackLiteral('data');
      } else {
        this.pushStackLiteral('container.data(data, ' + depth + ')');
      }
      this.resolvePath('data', parts, 0, true, strict);
    },
    resolvePath: function resolvePath(type, parts, i, falsy, strict) {
      // istanbul ignore next

      var _this2 = this;
      if (this.options.strict || this.options.assumeObjects) {
        this.push(strictLookup(this.options.strict && strict, this, parts, type));
        return;
      }
      var len = parts.length;
      for (; i < len; i++) {
        /* eslint-disable no-loop-func */
        this.replaceStack(function (current) {
          var lookup = _this2.nameLookup(current, parts[i], type);
          // We want to ensure that zero and false are handled properly if the context (falsy flag)
          // needs to have the special handling for these values.
          if (!falsy) {
            return [' != null ? ', lookup, ' : ', current];
          } else {
            // Otherwise we can use generic falsy handling
            return [' && ', lookup];
          }
        });
        /* eslint-enable no-loop-func */
      }
    },

    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function resolvePossibleLambda() {
      this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
    },
    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function pushStringParam(string, type) {
      this.pushContext();
      this.pushString(type);

      // If it's a subexpression, the string result
      // will be pushed after this opcode.
      if (type !== 'SubExpression') {
        if (typeof string === 'string') {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },
    emptyHash: function emptyHash(omitEmpty) {
      if (this.trackIds) {
        this.push('{}'); // hashIds
      }

      if (this.stringParams) {
        this.push('{}'); // hashContexts
        this.push('{}'); // hashTypes
      }

      this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
    },
    pushHash: function pushHash() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = {
        values: {},
        types: [],
        contexts: [],
        ids: []
      };
    },
    popHash: function popHash() {
      var hash = this.hash;
      this.hash = this.hashes.pop();
      if (this.trackIds) {
        this.push(this.objectLiteral(hash.ids));
      }
      if (this.stringParams) {
        this.push(this.objectLiteral(hash.contexts));
        this.push(this.objectLiteral(hash.types));
      }
      this.push(this.objectLiteral(hash.values));
    },
    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function pushString(string) {
      this.pushStackLiteral(this.quotedString(string));
    },
    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function pushLiteral(value) {
      this.pushStackLiteral(value);
    },
    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function pushProgram(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },
    // [registerDecorator]
    //
    // On stack, before: hash, program, params..., ...
    // On stack, after: ...
    //
    // Pops off the decorator's parameters, invokes the decorator,
    // and inserts the decorator into the decorators list.
    registerDecorator: function registerDecorator(paramSize, name) {
      var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
        options = this.setupHelperArgs(name, paramSize);
      this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
    },
    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function invokeHelper(paramSize, name, isSimple) {
      var nonHelper = this.popStack(),
        helper = this.setupHelper(paramSize, name);
      var possibleFunctionCalls = [];
      if (isSimple) {
        // direct call to helper
        possibleFunctionCalls.push(helper.name);
      }
      // call a function from the input object
      possibleFunctionCalls.push(nonHelper);
      if (!this.options.strict) {
        possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));
      }
      var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];
      var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);
      this.push(functionCall);
    },
    itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
      var result = [];
      result.push(items[0]);
      for (var i = 1; i < items.length; i++) {
        result.push(separator, items[i]);
      }
      return result;
    },
    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
    },
    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
      this.useRegister('helper');
      var nonHelper = this.popStack();
      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);
      var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
      var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
      if (!this.options.strict) {
        lookup[0] = '(helper = ';
        lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));
      }
      this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
    },
    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function invokePartial(isDynamic, name, indent) {
      var params = [],
        options = this.setupParams(name, 1, params);
      if (isDynamic) {
        name = this.popStack();
        delete options.name;
      }
      if (indent) {
        options.indent = JSON.stringify(indent);
      }
      options.helpers = 'helpers';
      options.partials = 'partials';
      options.decorators = 'container.decorators';
      if (!isDynamic) {
        params.unshift(this.nameLookup('partials', name, 'partial'));
      } else {
        params.unshift(name);
      }
      if (this.options.compat) {
        options.depths = 'depths';
      }
      options = this.objectLiteral(options);
      params.push(options);
      this.push(this.source.functionCall('container.invokePartial', '', params));
    },
    // [assignToHash]
    //
    // On stack, before: value, ..., hash, ...
    // On stack, after: ..., hash, ...
    //
    // Pops a value off the stack and assigns it to the current hash
    assignToHash: function assignToHash(key) {
      var value = this.popStack(),
        context = undefined,
        type = undefined,
        id = undefined;
      if (this.trackIds) {
        id = this.popStack();
      }
      if (this.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }
      var hash = this.hash;
      if (context) {
        hash.contexts[key] = context;
      }
      if (type) {
        hash.types[key] = type;
      }
      if (id) {
        hash.ids[key] = id;
      }
      hash.values[key] = value;
    },
    pushId: function pushId(type, name, child) {
      if (type === 'BlockParam') {
        this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
      } else if (type === 'PathExpression') {
        this.pushString(name);
      } else if (type === 'SubExpression') {
        this.pushStackLiteral('true');
      } else {
        this.pushStackLiteral('null');
      }
    },
    // HELPERS

    compiler: JavaScriptCompiler,
    compileChildren: function compileChildren(environment, options) {
      var children = environment.children,
        child = undefined,
        compiler = undefined;
      for (var i = 0, l = children.length; i < l; i++) {
        child = children[i];
        compiler = new this.compiler(); // eslint-disable-line new-cap

        var existing = this.matchExistingProgram(child);
        if (existing == null) {
          this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
          var index = this.context.programs.length;
          child.index = index;
          child.name = 'program' + index;
          this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
          this.context.decorators[index] = compiler.decorators;
          this.context.environments[index] = child;
          this.useDepths = this.useDepths || compiler.useDepths;
          this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
          child.useDepths = this.useDepths;
          child.useBlockParams = this.useBlockParams;
        } else {
          child.index = existing.index;
          child.name = 'program' + existing.index;
          this.useDepths = this.useDepths || existing.useDepths;
          this.useBlockParams = this.useBlockParams || existing.useBlockParams;
        }
      }
    },
    matchExistingProgram: function matchExistingProgram(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return environment;
        }
      }
    },
    programExpression: function programExpression(guid) {
      var child = this.environment.children[guid],
        programParams = [child.index, 'data', child.blockParams];
      if (this.useBlockParams || this.useDepths) {
        programParams.push('blockParams');
      }
      if (this.useDepths) {
        programParams.push('depths');
      }
      return 'container.program(' + programParams.join(', ') + ')';
    },
    useRegister: function useRegister(name) {
      if (!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },
    push: function push(expr) {
      if (!(expr instanceof Literal)) {
        expr = this.source.wrap(expr);
      }
      this.inlineStack.push(expr);
      return expr;
    },
    pushStackLiteral: function pushStackLiteral(item) {
      this.push(new Literal(item));
    },
    pushSource: function pushSource(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
        this.pendingContent = undefined;
      }
      if (source) {
        this.source.push(source);
      }
    },
    replaceStack: function replaceStack(callback) {
      var prefix = ['('],
        stack = undefined,
        createdStack = undefined,
        usedLiteral = undefined;

      /* istanbul ignore next */
      if (!this.isInline()) {
        throw new _exception2['default']('replaceStack on non-inline');
      }

      // We want to merge the inline statement into the replacement statement via ','
      var top = this.popStack(true);
      if (top instanceof Literal) {
        // Literals do not need to be inlined
        stack = [top.value];
        prefix = ['(', stack];
        usedLiteral = true;
      } else {
        // Get or create the current stack name for use by the inline
        createdStack = true;
        var _name = this.incrStack();
        prefix = ['((', this.push(_name), ' = ', top, ')'];
        stack = this.topStack();
      }
      var item = callback.call(this, stack);
      if (!usedLiteral) {
        this.popStack();
      }
      if (createdStack) {
        this.stackSlot--;
      }
      this.push(prefix.concat(item, ')'));
    },
    incrStack: function incrStack() {
      this.stackSlot++;
      if (this.stackSlot > this.stackVars.length) {
        this.stackVars.push('stack' + this.stackSlot);
      }
      return this.topStackName();
    },
    topStackName: function topStackName() {
      return 'stack' + this.stackSlot;
    },
    flushInline: function flushInline() {
      var inlineStack = this.inlineStack;
      this.inlineStack = [];
      for (var i = 0, len = inlineStack.length; i < len; i++) {
        var entry = inlineStack[i];
        /* istanbul ignore if */
        if (entry instanceof Literal) {
          this.compileStack.push(entry);
        } else {
          var stack = this.incrStack();
          this.pushSource([stack, ' = ', entry, ';']);
          this.compileStack.push(stack);
        }
      }
    },
    isInline: function isInline() {
      return this.inlineStack.length;
    },
    popStack: function popStack(wrapped) {
      var inline = this.isInline(),
        item = (inline ? this.inlineStack : this.compileStack).pop();
      if (!wrapped && item instanceof Literal) {
        return item.value;
      } else {
        if (!inline) {
          /* istanbul ignore next */
          if (!this.stackSlot) {
            throw new _exception2['default']('Invalid stack pop');
          }
          this.stackSlot--;
        }
        return item;
      }
    },
    topStack: function topStack() {
      var stack = this.isInline() ? this.inlineStack : this.compileStack,
        item = stack[stack.length - 1];

      /* istanbul ignore if */
      if (item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },
    contextName: function contextName(context) {
      if (this.useDepths && context) {
        return 'depths[' + context + ']';
      } else {
        return 'depth' + context;
      }
    },
    quotedString: function quotedString(str) {
      return this.source.quotedString(str);
    },
    objectLiteral: function objectLiteral(obj) {
      return this.source.objectLiteral(obj);
    },
    aliasable: function aliasable(name) {
      var ret = this.aliases[name];
      if (ret) {
        ret.referenceCount++;
        return ret;
      }
      ret = this.aliases[name] = this.source.wrap(name);
      ret.aliasable = true;
      ret.referenceCount = 1;
      return ret;
    },
    setupHelper: function setupHelper(paramSize, name, blockHelper) {
      var params = [],
        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
      var foundHelper = this.nameLookup('helpers', name, 'helper'),
        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');
      return {
        params: params,
        paramsInit: paramsInit,
        name: foundHelper,
        callParams: [callContext].concat(params)
      };
    },
    setupParams: function setupParams(helper, paramSize, params) {
      var options = {},
        contexts = [],
        types = [],
        ids = [],
        objectArgs = !params,
        param = undefined;
      if (objectArgs) {
        params = [];
      }
      options.name = this.quotedString(helper);
      options.hash = this.popStack();
      if (this.trackIds) {
        options.hashIds = this.popStack();
      }
      if (this.stringParams) {
        options.hashTypes = this.popStack();
        options.hashContexts = this.popStack();
      }
      var inverse = this.popStack(),
        program = this.popStack();

      // Avoid setting fn and inverse if neither are set. This allows
      // helpers to do a check for `if (options.fn)`
      if (program || inverse) {
        options.fn = program || 'container.noop';
        options.inverse = inverse || 'container.noop';
      }

      // The parameters go on to the stack in order (making sure that they are evaluated in order)
      // so we need to pop them off the stack in reverse order
      var i = paramSize;
      while (i--) {
        param = this.popStack();
        params[i] = param;
        if (this.trackIds) {
          ids[i] = this.popStack();
        }
        if (this.stringParams) {
          types[i] = this.popStack();
          contexts[i] = this.popStack();
        }
      }
      if (objectArgs) {
        options.args = this.source.generateArray(params);
      }
      if (this.trackIds) {
        options.ids = this.source.generateArray(ids);
      }
      if (this.stringParams) {
        options.types = this.source.generateArray(types);
        options.contexts = this.source.generateArray(contexts);
      }
      if (this.options.data) {
        options.data = 'data';
      }
      if (this.useBlockParams) {
        options.blockParams = 'blockParams';
      }
      return options;
    },
    setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
      var options = this.setupParams(helper, paramSize, params);
      options.loc = JSON.stringify(this.source.currentLocation);
      options = this.objectLiteral(options);
      if (useRegister) {
        this.useRegister('options');
        params.push('options');
        return ['options=', options];
      } else if (params) {
        params.push(options);
        return '';
      } else {
        return options;
      }
    }
  };
  (function () {
    var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
    for (var i = 0, l = reservedWords.length; i < l; i++) {
      compilerWords[reservedWords[i]] = true;
    }
  })();

  /**
   * @deprecated May be removed in the next major version
   */
  JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
  };
  function strictLookup(requireTerminal, compiler, parts, type) {
    var stack = compiler.popStack(),
      i = 0,
      len = parts.length;
    if (requireTerminal) {
      len--;
    }
    for (; i < len; i++) {
      stack = compiler.nameLookup(stack, parts[i], type);
    }
    if (requireTerminal) {
      return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];
    } else {
      return stack;
    }
  }
  exports['default'] = JavaScriptCompiler;
  module.exports = exports['default'];
})(javascriptCompiler, javascriptCompilerExports);

(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
  var _handlebarsRuntime = handlebars_runtimeExports;
  var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

  // Compiler imports

  var _handlebarsCompilerAst = astExports;
  var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
  var _handlebarsCompilerBase = base$1;
  var _handlebarsCompilerCompiler = compiler;
  var _handlebarsCompilerJavascriptCompiler = javascriptCompilerExports;
  var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
  var _handlebarsCompilerVisitor = visitorExports;
  var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
  var _handlebarsNoConflict = noConflictExports;
  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
  var _create = _handlebarsRuntime2['default'].create;
  function create() {
    var hb = _create();
    hb.compile = function (input, options) {
      return _handlebarsCompilerCompiler.compile(input, options, hb);
    };
    hb.precompile = function (input, options) {
      return _handlebarsCompilerCompiler.precompile(input, options, hb);
    };
    hb.AST = _handlebarsCompilerAst2['default'];
    hb.Compiler = _handlebarsCompilerCompiler.Compiler;
    hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
    hb.Parser = _handlebarsCompilerBase.parser;
    hb.parse = _handlebarsCompilerBase.parse;
    hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
    return hb;
  }
  var inst = create();
  inst.create = create;
  _handlebarsNoConflict2['default'](inst);
  inst.Visitor = _handlebarsCompilerVisitor2['default'];
  inst['default'] = inst;
  exports['default'] = inst;
  module.exports = exports['default'];
})(handlebars$1, handlebarsExports);

var printer$1 = {};

/* eslint-disable new-cap */
printer$1.__esModule = true;
printer$1.print = print;
printer$1.PrintVisitor = PrintVisitor;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _visitor = visitorExports;
var _visitor2 = _interopRequireDefault(_visitor);
function print(ast) {
  return new PrintVisitor().accept(ast);
}
function PrintVisitor() {
  this.padding = 0;
}
PrintVisitor.prototype = new _visitor2['default']();
PrintVisitor.prototype.pad = function (string) {
  var out = '';
  for (var i = 0, l = this.padding; i < l; i++) {
    out += '  ';
  }
  out += string + '\n';
  return out;
};
PrintVisitor.prototype.Program = function (program) {
  var out = '',
    body = program.body,
    i = undefined,
    l = undefined;
  if (program.blockParams) {
    var blockParams = 'BLOCK PARAMS: [';
    for (i = 0, l = program.blockParams.length; i < l; i++) {
      blockParams += ' ' + program.blockParams[i];
    }
    blockParams += ' ]';
    out += this.pad(blockParams);
  }
  for (i = 0, l = body.length; i < l; i++) {
    out += this.accept(body[i]);
  }
  this.padding--;
  return out;
};
PrintVisitor.prototype.MustacheStatement = function (mustache) {
  return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
};
PrintVisitor.prototype.Decorator = function (mustache) {
  return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');
};
PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {
  var out = '';
  out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');
  this.padding++;
  out += this.pad(this.SubExpression(block));
  if (block.program) {
    out += this.pad('PROGRAM:');
    this.padding++;
    out += this.accept(block.program);
    this.padding--;
  }
  if (block.inverse) {
    if (block.program) {
      this.padding++;
    }
    out += this.pad('{{^}}');
    this.padding++;
    out += this.accept(block.inverse);
    this.padding--;
    if (block.program) {
      this.padding--;
    }
  }
  this.padding--;
  return out;
};
PrintVisitor.prototype.PartialStatement = function (partial) {
  var content = 'PARTIAL:' + partial.name.original;
  if (partial.params[0]) {
    content += ' ' + this.accept(partial.params[0]);
  }
  if (partial.hash) {
    content += ' ' + this.accept(partial.hash);
  }
  return this.pad('{{> ' + content + ' }}');
};
PrintVisitor.prototype.PartialBlockStatement = function (partial) {
  var content = 'PARTIAL BLOCK:' + partial.name.original;
  if (partial.params[0]) {
    content += ' ' + this.accept(partial.params[0]);
  }
  if (partial.hash) {
    content += ' ' + this.accept(partial.hash);
  }
  content += ' ' + this.pad('PROGRAM:');
  this.padding++;
  content += this.accept(partial.program);
  this.padding--;
  return this.pad('{{> ' + content + ' }}');
};
PrintVisitor.prototype.ContentStatement = function (content) {
  return this.pad("CONTENT[ '" + content.value + "' ]");
};
PrintVisitor.prototype.CommentStatement = function (comment) {
  return this.pad("{{! '" + comment.value + "' }}");
};
PrintVisitor.prototype.SubExpression = function (sexpr) {
  var params = sexpr.params,
    paramStrings = [],
    hash = undefined;
  for (var i = 0, l = params.length; i < l; i++) {
    paramStrings.push(this.accept(params[i]));
  }
  params = '[' + paramStrings.join(', ') + ']';
  hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';
  return this.accept(sexpr.path) + ' ' + params + hash;
};
PrintVisitor.prototype.PathExpression = function (id) {
  var path = id.parts.join('/');
  return (id.data ? '@' : '') + 'PATH:' + path;
};
PrintVisitor.prototype.StringLiteral = function (string) {
  return '"' + string.value + '"';
};
PrintVisitor.prototype.NumberLiteral = function (number) {
  return 'NUMBER{' + number.value + '}';
};
PrintVisitor.prototype.BooleanLiteral = function (bool) {
  return 'BOOLEAN{' + bool.value + '}';
};
PrintVisitor.prototype.UndefinedLiteral = function () {
  return 'UNDEFINED';
};
PrintVisitor.prototype.NullLiteral = function () {
  return 'NULL';
};
PrintVisitor.prototype.Hash = function (hash) {
  var pairs = hash.pairs,
    joinedPairs = [];
  for (var i = 0, l = pairs.length; i < l; i++) {
    joinedPairs.push(this.accept(pairs[i]));
  }
  return 'HASH{' + joinedPairs.join(', ') + '}';
};
PrintVisitor.prototype.HashPair = function (pair) {
  return pair.key + '=' + this.accept(pair.value);
};

var empty = {};

var empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: empty
});

var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(empty$1);

// USAGE:
// var handlebars = require('handlebars');
/* eslint-disable no-var */

// var local = handlebars.create();

var handlebars = handlebarsExports['default'];
var printer = printer$1;
handlebars.PrintVisitor = printer.PrintVisitor;
handlebars.print = printer.print;
var lib = handlebars;

// Publish a Node.js require() handler for .handlebars and .hbs files
function extension(module, filename) {
  var fs = require$$2$1;
  var templateString = fs.readFileSync(filename, 'utf8');
  module.exports = handlebars.compile(templateString);
}
/* istanbul ignore else */
if (typeof commonjsRequire$1 !== 'undefined' && commonjsRequire$1.extensions) {
  commonjsRequire$1.extensions['.handlebars'] = extension;
  commonjsRequire$1.extensions['.hbs'] = extension;
}
var Handlebars = lib;

class WidgetGlobals {
    static HandlebarsInstance = Handlebars;
    static Network;
    static User;
    static LiminalMarket;
    static elementSelector;
}

var ModalHtml = "<dialog id=\"liminal_market_modal_div\" data-title=\"{{{title}}}\">\n    <article>\n        <header>\n            <span>{{title}}</span>\n            <a href=\"#close\" aria-label=\"Close\" class=\"close\" id=\"liminal_market_modal_close\"></a>\n        </header>\n        {{{content}}}\n    </article>\n\n</dialog>";

class Modal {
    modalId = "liminal_market_modal_div";
    onHide;
    hideModal() {
        let modalDiv = document.getElementById(this.modalId);
        modalDiv?.removeAttribute("open");
        if (this.onHide) {
            this.onHide();
        }
    }
    showModal(title, content, reuseModalIfSameTitle = false, onHide, hideOnOutsideClick = true) {
        let modalDiv = document.getElementById(this.modalId);
        if (modalDiv) {
            let modalTitle = modalDiv.dataset.title;
            if (reuseModalIfSameTitle && modalTitle && modalTitle === title) {
                modalDiv.setAttribute("open", "");
                return false;
            }
        }
        let template = WidgetGlobals.HandlebarsInstance.compile(ModalHtml);
        let obj = {
            title: title,
            content: content,
        };
        let html = template(obj);
        if (modalDiv) {
            document
                .querySelector(WidgetGlobals.elementSelector)
                ?.removeChild(modalDiv);
        }
        document
            .querySelector(WidgetGlobals.elementSelector)
            ?.insertAdjacentHTML("beforeend", html);
        modalDiv = document.getElementById(this.modalId);
        modalDiv.setAttribute("open", "");
        if (hideOnOutsideClick) {
            modalDiv.addEventListener("mousedown", (evt) => {
                if (evt.target &&
                    evt.target.id === "liminal_market_modal_div") {
                    this.hideModal();
                }
            });
        }
        let liminal_market_modal_close = document.getElementById("liminal_market_modal_close");
        if (liminal_market_modal_close)
            liminal_market_modal_close.style.display = "block";
        document
            .getElementById("liminal_market_modal_close")
            ?.addEventListener("click", (evt) => {
            evt.preventDefault();
            this.hideModal();
        });
        this.onHide = onHide;
        return true;
    }
}

class Security {
    Class = "";
    Exchange = "";
    Symbol = "";
    Name = "";
    Status = "";
    Tradable = false;
    Fractionable = false;
    Logo = "";
    Favorite = 0;
    LogoPath = "/img/logos/";
    constructor() {
        this.LogoPath = "/img/logos/";
    }
}

class BaseService {
    constructor() { }
    async get(path, data, options) {
        let url = "";
        let method = "GET";
        if (!options || !options.relativeUrl) {
            url = WidgetGlobals.Network.ServerUrl;
        }
        let params = new URLSearchParams(data);
        if (!params.has("chainId")) {
            params.set("chainId", WidgetGlobals.Network.ChainId.toString());
        }
        if (!params.has("address")) {
            params.set("address", WidgetGlobals.User.address);
        }
        let response = await fetch(this.getUrl(url, path) + "?" + params.toString(), {
            method: method,
            headers: {
                Authentication: "Bearer: " + WidgetGlobals.User.token,
                "Content-Type": "application/json",
            },
        });
        let obj = await response.json();
        return obj.result ? obj.result : undefined;
    }
    async post(path, data) {
        if (!data) {
            data = {};
        }
        data.chainId = data.chainId ? data.chainId : WidgetGlobals.Network.ChainId;
        data.address = data.address ? data.address : WidgetGlobals.User.address;
        let response = await fetch(this.getUrl(WidgetGlobals.Network.ServerUrl, path), {
            method: "POST",
            headers: {
                Authentication: "Bearer: " + WidgetGlobals.User.token,
                "Content-Type": "application/json;charset=UTF-8",
            },
            body: JSON.stringify(data),
        });
        let obj = await response.json();
        if (obj.success)
            return obj.result;
        throw new Error(obj.error);
    }
    getUrl(ServerUrl, path) {
        if (path.startsWith("/"))
            return ServerUrl + path;
        return ServerUrl + "/" + path;
    }
}

class SecuritiesService extends BaseService {
    securities = new Map();
    securitiesArray;
    static instance;
    page;
    symbols = [
        "MSFT",
        "AAPL",
        "AMZN",
        "TSLA",
        "GOOGL",
        "GOOG",
        "GME",
        "META",
        "NVDA",
        "BRK.B",
        "JPM",
        "HD",
        "JNJ",
        "UNH",
        "PG",
        "BAC",
        "V",
        "ADBE",
        "NFLX",
        "CRM",
        "PFE",
        "DIS",
        "MA",
        "XOM",
        "TMO",
        "COST",
    ];
    constructor() {
        super();
        this.securities = new Map();
        this.securitiesArray = [];
        this.page = 1;
    }
    static async getInstance() {
        if (!SecuritiesService.instance) {
            SecuritiesService.instance = new SecuritiesService();
            SecuritiesService.instance.securities =
                await SecuritiesService.instance.getSecurities();
        }
        return SecuritiesService.instance;
    }
    async getSecurities() {
        if (this.securities.size != 0)
            return this.securities;
        const results = await (await fetch("https://app.liminal.market/securities/securities.json")).json();
        for (let i = 0; i < results.length; i++) {
            this.securities.set(results[i].Symbol, Object.assign(new Security(), results[i]));
        }
        this.securitiesArray = Array.from(this.securities);
        return this.securities;
    }
    async getSecurityBySymbol(symbol) {
        let securities = await this.getSecurities();
        let security = securities.get(symbol);
        return security ? security : new Security();
    }
    async getTopSecurities() {
        let securities = await this.getSecurities();
        let topSecurities = new Array();
        for (const symbol of this.symbols) {
            let security = securities.get(symbol);
            if (security) {
                topSecurities.push(security);
            }
        }
        return topSecurities;
    }
    async getPaginatingSecurities(page) {
        if (page == 0)
            return this.getTopSecurities();
        let securitiesOnPage = new Array();
        let i = page * this.symbols.length;
        let pageCount = i + 10;
        for (; i < pageCount && i < this.securitiesArray.length; i++) {
            securitiesOnPage.push(this.securitiesArray[i][1]);
        }
        return securitiesOnPage;
    }
    async find(search) {
        let results = new Array();
        search = search.toLocaleLowerCase();
        this.securities.forEach(function (security) {
            if (security.Symbol.toLowerCase().indexOf(search) != -1 ||
                security.Name.toLowerCase().indexOf(search) != -1) {
                results.push(security);
            }
        });
        return results;
    }
}

class LoadingHelper {
    static lastElement = undefined;
    static setLoading(element) {
        if (LoadingHelper.lastElement) {
            LoadingHelper.lastElement.removeAttribute('aria-busy');
        }
        if (!element)
            return;
        element.setAttribute('aria-busy', 'true');
        LoadingHelper.lastElement = element;
    }
    static removeLoading() {
        if (this.lastElement) {
            this.lastElement.removeAttribute('aria-busy');
        }
    }
}

class GeneralError extends Error {
    code;
    message;
    headers;
    error;
    stack;
    callback;
    constructor(e) {
        super();
        this.code = 0;
        this.stack = "";
        if (!e.message) {
            this.message = e.toString();
        }
        else if (e.message.data) {
            this.code = e.message.data.code;
            this.message = e.message.data.message;
            this.error = e;
            this.headers = e.message.headers;
            this.stack = e.stack;
        }
        else if (typeof (e.data) == 'object') {
            this.code = e.data.code;
            this.message = e.data.message;
            this.stack = e.stack;
        }
        else if (e.message) {
            this.message = e.message;
        }
        else {
            this.message = e.toString();
        }
    }
}

class WalletHelper {
    static addTokenFallbackLoaded = undefined;
    constructor() { }
    getAUsdAsset() {
        return {
            Logo: "../ausd.png",
        };
    }
    async addTokenToWallet(address, symbol, fallbackTimeout) {
        let securitiesService = await SecuritiesService.getInstance();
        const asset = symbol == "aUSD"
            ? this.getAUsdAsset()
            : await securitiesService.getSecurityBySymbol(symbol);
        let connector = await AuthenticateService.enableWeb3();
        if (!connector || !connector.provider || !connector.provider.request) {
            fallbackTimeout();
            return;
        }
        let timeout = WalletHelper.addTokenFallbackLoaded === undefined ? 2 * 1000 : 200;
        setTimeout(() => {
            if (WalletHelper.addTokenFallbackLoaded !== false) {
                WalletHelper.addTokenFallbackLoaded = true;
                if (fallbackTimeout)
                    fallbackTimeout();
            }
        }, timeout);
        // @ts-ignore
        let eth = window.ethereum ? window.ethereum : connector.provider;
        const wasAdded = await eth
            .request({
            method: "wallet_watchAsset",
            params: {
                type: "ERC20",
                options: {
                    address: address,
                    symbol: symbol,
                    decimals: 18,
                    image: "https://app.liminal.market/img/logos/" + asset.Logo,
                },
            },
        })
            .then((result) => {
            WalletHelper.addTokenFallbackLoaded = false;
            return true;
        })
            .catch((error) => {
            console.log(error);
            return false;
        })
            .finally(() => {
            LoadingHelper.removeLoading();
        });
        return wasAdded;
    }
    static isWebview() {
        let ua = navigator.userAgent;
        // if it says it's a webview, let's go with that
        let rules = [
            "WebView",
            // iOS webview will be the same as safari but missing "Safari"
            "(iPhone|iPod|iPad)(?!.*Safari)",
            // Android Lollipop and Above: webview will be the same as native but it will contain "wv"
            // Android KitKat to lollipop webview will put {version}.0.0.0
            "Android.*(wv|.0.0.0)",
            // old chrome android webview agent
            "Linux; U; Android",
            "SDK",
        ];
        let webviewRegExp = new RegExp("(" + rules.join("|") + ")", "ig");
        return !!ua.match(webviewRegExp);
    }
    async isMagic() {
        if (!WidgetGlobals.User.magic || !WidgetGlobals.User.magic.connect)
            return false;
        let walletInfo = await WidgetGlobals.User.magic.connect.getWalletInfo();
        if (walletInfo) {
            return walletInfo.walletType == "magic";
        }
        return false;
    }
    async switchNetwork(network) {
        // @ts-ignore
        let eth = window.ethereum;
        if (!eth || (await this.isMagic())) {
            NetworkInfo.setNetworkByChainId(network.ChainId);
            return true;
        }
        return await eth
            .request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: "0x" + network.ChainId.toString(16) }],
        })
            .then((result) => {
            console.log("switch result:", result);
            return true;
        })
            .catch(async (err) => {
            // This error code indicates that the chain has not been added to MetaMask
            if (err.code === 4902) {
                return await eth
                    .request({
                    method: "wallet_addEthereumChain",
                    params: [
                        {
                            chainName: network.ChainName,
                            chainId: "0x" + network.ChainId.toString(16),
                            nativeCurrency: {
                                name: network.NativeCurrencyName,
                                decimals: network.NativeDecimal,
                                symbol: network.NativeSymbol,
                            },
                            rpcUrls: [network.RpcUrl],
                        },
                    ],
                })
                    .then((result) => {
                    console.log("addChain result:" + result);
                    return true;
                })
                    .catch((error) => {
                    console.log("error on addNetwork:", error);
                    throw new GeneralError(error);
                });
            }
            else {
                throw new GeneralError(err);
            }
        });
    }
    static hideMagicWallet() {
        let magicIframe = document.querySelector(".magic-iframe");
        if (magicIframe && magicIframe.style.display == "block")
            magicIframe.style.display = "none";
        let liminal_market_connect_wallet = document.querySelectorAll(".liminal_market_connect_wallet");
        if (!liminal_market_connect_wallet)
            return;
        liminal_market_connect_wallet.forEach((item) => {
            item.setAttribute("aria-busy", "false");
        });
    }
}

var NetworkType$2;
(function (NetworkType) {
    NetworkType[NetworkType["Mainnet"] = 0] = "Mainnet";
    NetworkType[NetworkType["Testnet"] = 1] = "Testnet";
})(NetworkType$2 || (NetworkType$2 = {}));

class SwitchNetworkModal {
    selectedNetwork;
    constructor() { }
    show() {
        let template = WidgetGlobals.HandlebarsInstance.compile(SwitchNetworkHtml);
        let testNetworks = NetworkInfo.getNetworks(NetworkType$2.Testnet);
        let mainNetworks = NetworkInfo.getNetworks(NetworkType$2.Mainnet);
        let content = template({ testNetworks, mainNetworks });
        let modal = new Modal();
        modal.showModal("Switch network", content, false, undefined, false);
        let setNetworkLinks = document.querySelectorAll(".setNetwork");
        setNetworkLinks.forEach((setNetworkLink) => {
            setNetworkLink.addEventListener("click", async (evt) => {
                evt.preventDefault();
                let dataset = evt.target.dataset;
                this.selectedNetwork = NetworkInfo.getNetworkInfoByChainId(parseInt(dataset.chainid));
                if (!this.selectedNetwork)
                    throw new GeneralError("Could not find chainId:" + dataset.chainid);
                let walletHelper = new WalletHelper();
                let successAddingNetwork = await walletHelper
                    .switchNetwork(this.selectedNetwork)
                    .catch((error) => {
                    let jsSwitchNetworkNotWorking = document.getElementById("jsSwitchNetworkNotWorking");
                    if (!jsSwitchNetworkNotWorking)
                        throw error;
                    if (error.message.toLowerCase().indexOf("user rejected") != -1)
                        return;
                    jsSwitchNetworkNotWorking.classList.remove("d-none");
                    let switchNetworkInfo = document.getElementById("switchNetworkInfo");
                    switchNetworkInfo.classList.add("d-none");
                    document.getElementById("switchChainId").value =
                        dataset.chainid +
                            " or it might be: " +
                            "0x" +
                            parseInt(dataset.chainid).toString(16);
                    document.getElementById("switchChainName").value = this.selectedNetwork.Name;
                    document.getElementById("switchCurrencyName").value = this.selectedNetwork.NativeCurrencyName;
                    document.getElementById("switchSymbol").value = this.selectedNetwork.NativeSymbol;
                    document.getElementById("switchDecimal").value = this.selectedNetwork.NativeDecimal.toString();
                    document.getElementById("switchRpcUrl").value = this.selectedNetwork.RpcUrl;
                });
                if (successAddingNetwork) {
                    modal.hideModal();
                    location.href =
                        location.origin + "/#/chain/" + NetworkInfo.getInstance().Name;
                    location.reload();
                }
            });
        });
    }
}

var bnExports = {};
var bn = {
  get exports(){ return bnExports; },
  set exports(v){ bnExports = v; },
};

var global$2 = typeof global$1 !== "undefined" ? global$1 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

var global$1 = typeof global$2 !== "undefined" ? global$2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }
  parts.push(output);
  return parts.join('');
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
}
var toString = {}.toString;
var isArray$1 = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
var _kMaxLength = kMaxLength();
function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }
  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};
function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};
if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }
  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}
function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = isBuffer$1;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }
  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
        return asciiWrite(this, string, offset, length);
      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex$2(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}
function toHex$2(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}

// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var bufferEs6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Buffer: Buffer,
    INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
    SlowBuffer: SlowBuffer,
    isBuffer: isBuffer$1,
    kMaxLength: _kMaxLength
});

var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(bufferEs6);

(function (module) {
  (function (module, exports) {

    // Utils
    function assert(val, msg) {
      if (!val) throw new Error(msg || 'Assertion failed');
    }

    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }

    // BN

    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;

      // Reduction context
      this.red = null;
      if (number !== null) {
        if (base === 'le' || base === 'be') {
          endian = base;
          base = 10;
        }
        this._init(number || 0, base || 10, endian || 'be');
      }
    }
    if (typeof module === 'object') {
      module.exports = BN;
    } else {
      exports.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
      if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
        Buffer = window.Buffer;
      } else {
        Buffer = require$$0$3.Buffer;
      }
    } catch (e) {}
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };
    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === 'number') {
        return this._initNumber(number, base, endian);
      }
      if (typeof number === 'object') {
        return this._initArray(number, base, endian);
      }
      if (base === 'hex') {
        base = 16;
      }
      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, '');
      var start = 0;
      if (number[0] === '-') {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);
          if (endian === 'le') {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 0x4000000) {
        this.words = [number & 0x3ffffff];
        this.length = 1;
      } else if (number < 0x10000000000000) {
        this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
        this.length = 2;
      } else {
        assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
        this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
        this.length = 3;
      }
      if (endian !== 'le') return;

      // Reverse the bytes
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
      // Perhaps a Uint8Array
      assert(typeof number.length === 'number');
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === 'be') {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 0x3ffffff;
          this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === 'le') {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 0x3ffffff;
          this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index);
      // '0' - '9'
      if (c >= 48 && c <= 57) {
        return c - 48;
        // 'A' - 'F'
      } else if (c >= 65 && c <= 70) {
        return c - 55;
        // 'a' - 'f'
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert(false, 'Invalid character in ' + string);
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      // Create possibly bigger array to ensure that it fits the number
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }

      // 24-bits chunks
      var off = 0;
      var j = 0;
      var w;
      if (endian === 'be') {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 0x3ffffff;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 0x3ffffff;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul) {
      var r = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;

        // 'a'
        if (c >= 49) {
          b = c - 49 + 0xa;

          // 'A'
        } else if (c >= 17) {
          b = c - 17 + 0xa;

          // '0' - '9'
        } else {
          b = c;
        }
        assert(c >= 0 && b < mul, 'Invalid character');
        r += b;
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
      // Initialize as zero
      this.words = [0];
      this.length = 1;

      // Find length of limb in base
      for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for (i = 0; i < mod; i++) {
          pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };

    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      // -0 = 0
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };

    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
      try {
        BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
      } catch (e) {
        BN.prototype.inspect = inspect;
      }
    } else {
      BN.prototype.inspect = inspect;
    }
    function inspect() {
      return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    }

    /*
     var zeros = [];
    var groupSizes = [];
    var groupBases = [];
     var s = '';
    var i = -1;
    while (++i < BN.wordSize) {
      zeros[i] = s;
      s += '0';
    }
    groupSizes[0] = 0;
    groupSizes[1] = 0;
    groupBases[0] = 0;
    groupBases[1] = 0;
    var base = 2 - 1;
    while (++base < 36 + 1) {
      var groupSize = 0;
      var groupBase = 1;
      while (groupBase < (1 << BN.wordSize) / base) {
        groupBase *= base;
        groupSize += 1;
      }
      groupSizes[base] = groupSize;
      groupBases[base] = groupBase;
    }
     */

    var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;
      if (base === 16 || base === 'hex') {
        out = '';
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 0xffffff).toString(16);
          carry = w >>> 24 - off & 0xffffff;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = '0' + out;
        }
        if (this.negative !== 0) {
          out = '-' + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
        var groupSize = groupSizes[base];
        // var groupBase = Math.pow(base, groupSize);
        var groupBase = groupBases[base];
        out = '';
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modrn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = '0' + out;
        }
        while (out.length % padding !== 0) {
          out = '0' + out;
        }
        if (this.negative !== 0) {
          out = '-' + out;
        }
        return out;
      }
      assert(false, 'Base should be between 2 and 36');
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 0x4000000;
      } else if (this.length === 3 && this.words[2] === 0x01) {
        // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
      } else if (this.length > 2) {
        assert(false, 'Number can only safely store up to 53 bits');
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16, 2);
    };
    if (Buffer) {
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
      };
    }
    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, 'byte array longer than desired length');
      assert(reqLength > 0, 'Requested array length <= 0');
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === 'le' ? 'LE' : 'BE';
      this['_toArrayLike' + postfix](res, byteLength);
      return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 0xff;
        if (position < res.length) {
          res[position++] = word >> 8 & 0xff;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 0xff;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 0xff;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 0xff;
        if (position >= 0) {
          res[position--] = word >> 8 & 0xff;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 0xff;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 0xff;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 0x40) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 0x8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 0x02) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      // Short-cut
      if (w === 0) return 26;
      var t = w;
      var r = 0;
      if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 0x1) === 0) {
        r++;
      }
      return r;
    };

    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 0x01;
      }
      return w;
    }

    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };

    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };

    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN.prototype.ior = function ior(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuor(num);
    };

    // Or `num` with `this`
    BN.prototype.or = function or(num) {
      if (this.length > num.length) return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this);
    };

    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
      // b = min-length(num, this)
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN.prototype.iand = function iand(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuand(num);
    };

    // And `num` with `this`
    BN.prototype.and = function and(num) {
      if (this.length > num.length) return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this);
    };

    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
      // a.length > b.length
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };

    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };

    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === 'number' && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;

      // Extend the buffer with leading zeroes
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }

      // Handle complete words
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 0x3ffffff;
      }

      // Handle the residue
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
      }

      // And remove leading zeroes
      return this._strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };

    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === 'number' && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };

    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
      var r;

      // negative + positive
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();

        // positive + negative
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }

      // a.length > b.length
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
        // Copy the rest of the words
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };

    // Add `num` to `this`
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this);
    };

    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
      // this - (-num) = this + num
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();

        // -this - num = -(this + num)
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }

      // At this point both numbers are positive
      var cmp = this.cmp(num);

      // Optimization - zeroify
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }

      // a > b
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }

      // Copy rest of the words
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };

    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      var len = self.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;

      // Peel one iteration (compiler can't do it, because of code complexity)
      var a = self.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 0x3ffffff;
      var carry = r / 0x4000000 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 0x4000000 | 0;
          rword = r & 0x3ffffff;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }

    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
      var a = self.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 0x1fff;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 0x1fff;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 0x1fff;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 0x1fff;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 0x1fff;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 0x1fff;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 0x1fff;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 0x1fff;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 0x1fff;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 0x1fff;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 0x1fff;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 0x1fff;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 0x1fff;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 0x1fff;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 0x1fff;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 0x1fff;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 0x1fff;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 0x1fff;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 0x1fff;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 0x1fff;
      var bh9 = b9 >>> 13;
      out.negative = self.negative ^ num.negative;
      out.length = 19;
      /* k = 0 */
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 0x3ffffff;
      /* k = 1 */
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 0x3ffffff;
      /* k = 2 */
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 0x3ffffff;
      /* k = 3 */
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 0x3ffffff;
      /* k = 4 */
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 0x3ffffff;
      /* k = 5 */
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 0x3ffffff;
      /* k = 6 */
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 0x3ffffff;
      /* k = 7 */
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 0x3ffffff;
      /* k = 8 */
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 0x3ffffff;
      /* k = 9 */
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 0x3ffffff;
      /* k = 10 */
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 0x3ffffff;
      /* k = 11 */
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 0x3ffffff;
      /* k = 12 */
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 0x3ffffff;
      /* k = 13 */
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 0x3ffffff;
      /* k = 14 */
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 0x3ffffff;
      /* k = 15 */
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 0x3ffffff;
      /* k = 16 */
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 0x3ffffff;
      /* k = 17 */
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 0x3ffffff;
      /* k = 18 */
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 0x3ffffff;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };

    // Polyfill comb
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      out.length = self.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 0x3ffffff;
          ncarry = ncarry + (r / 0x4000000 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 0x3ffffff;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self, num, out) {
      // Temporary disable, see https://github.com/indutny/bn.js/issues/211
      // var fftm = new FFTM();
      // return fftm.mulp(self, num, out);
      return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };

    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };

    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };

    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum) num = -num;
      assert(typeof num === 'number');
      assert(num < 0x4000000);

      // Carry
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += w / 0x4000000 | 0;
        // NOTE: lo is 27bit maximum
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };

    // `this` * `this`
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };

    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };

    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN(1);

      // Skip leading zeroes
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
          res = res.mul(q);
        }
      }
      return res;
    };

    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0; i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      // TODO(indutny): implement me
      assert(this.negative === 0);
      return this.iushln(bits);
    };

    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === 'number' && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);

      // Extended mode, copy masked part
      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) ; else if (this.length > s) {
        this.length -= s;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      }

      // Push carried bits as a mask
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      // TODO(indutny): implement me
      assert(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };

    // Shift-left
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };

    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };

    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === 'number' && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;

      // Fast case: bit is much higher than all existing words
      if (this.length <= s) return false;

      // Check bit and return
      var w = this.words[s];
      return !!(w & q);
    };

    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert(this.negative === 0, 'imaskn works only with positive numbers');
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };

    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };

    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      if (num < 0) return this.isubn(-num);

      // Possible sign change
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }

      // Add without checks
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;

      // Carry
      for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
        this.words[i] -= 0x4000000;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };

    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      if (num < 0) return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        // Carry
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 0x4000000;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - (right / 0x4000000 | 0);
        this.words[i + shift] = w & 0x3ffffff;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
      }
      if (carry === 0) return this._strip();

      // Subtraction overflow
      assert(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
      }
      this.negative = 1;
      return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;

      // Normalize
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }

      // Initialize quotient
      var m = a.length - b.length;
      var q;
      if (mode !== 'mod') {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);

        // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
        // (0x7ffffff)
        qj = Math.min(qj / bhi | 0, 0x3ffffff);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();

      // Denormalize
      if (mode !== 'div' && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };

    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== 'mod') {
          div = res.div.neg();
        }
        if (mode !== 'div') {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div: div,
          mod: mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== 'mod') {
          div = res.div.neg();
        }
        return {
          div: div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== 'div') {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod
        };
      }

      // Both numbers are positive at this point

      // Strip both numbers to approximate shift value
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }

      // Very short reduction
      if (num.length === 1) {
        if (mode === 'div') {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === 'mod') {
          return {
            div: null,
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };

    // Find `this` / `num`
    BN.prototype.div = function div(num) {
      return this.divmod(num, 'div', false).div;
    };

    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, 'mod', false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, 'mod', true).mod;
    };

    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);

      // Fast case - exact division
      if (dm.mod.isZero()) return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);

      // Round down
      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

      // Round up
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum) num = -num;
      assert(num <= 0x3ffffff);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };

    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
      return this.modrn(num);
    };

    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum) num = -num;
      assert(num <= 0x3ffffff);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 0x4000000;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }

      // A * x + B * y = x
      var A = new BN(1);
      var B = new BN(0);

      // C * x + D * y = y
      var C = new BN(0);
      var D = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };

    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;

      // Remove common factor of two
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
          // Swap `a` and `b` to make `a` always bigger than `b`
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };

    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };

    // And first word and num
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };

    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === 'number');
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;

      // Fast case: bit is much higher than all existing words
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }

      // Add bit and propagate, if needed
      var carry = q;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative) return -1;
      if (this.negative === 0 && negative) return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert(num <= 0x3ffffff, 'Number is too big');
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0) return -res | 0;
      return res;
    };

    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0) return -1;
      if (this.negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0) return -res | 0;
      return res;
    };

    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
      // At this point both numbers have the same sign
      if (this.length > num.length) return 1;
      if (this.length < num.length) return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };

    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert(!this.red, 'Already a number in reduction context');
      assert(this.negative === 0, 'red works only with positives');
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert(this.red, 'fromRed works only with numbers in reduction context');
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!this.red, 'Already a number in reduction context');
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert(this.red, 'redAdd works only with red numbers');
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert(this.red, 'redIAdd works only with red numbers');
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert(this.red, 'redSub works only with red numbers');
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert(this.red, 'redISub works only with red numbers');
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert(this.red, 'redShl works only with red numbers');
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert(this.red, 'redSqr works only with red numbers');
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert(this.red, 'redISqr works only with red numbers');
      this.red._verify1(this);
      return this.red.isqr(this);
    };

    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
      assert(this.red, 'redSqrt works only with red numbers');
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert(this.red, 'redInvm works only with red numbers');
      this.red._verify1(this);
      return this.red.invm(this);
    };

    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
      assert(this.red, 'redNeg works only with red numbers');
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert(this.red && !num.red, 'redPow(normalNum)');
      this.red._verify1(this);
      return this.red.pow(this, num);
    };

    // Prime numbers with efficient reduction
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };

    // Pseudo-Mersenne prime
    function MPrime(name, p) {
      // P = 2 ^ N - K
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      // Assumes that `num` is less than `P^2`
      // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          // r is a BN v4 instance
          r.strip();
        } else {
          // r is a BN v5 instance
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      // 256 = 9 * 26 + 22
      var mask = 0x3fffff;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }

      // Shift by 9 limbs
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;

      // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 0x3d1;
        num.words[i] = lo & 0x3ffffff;
        lo = w * 0x40 + (lo / 0x4000000 | 0);
      }

      // Fast length reduction
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);
    function P25519() {
      // 2 ^ 255 - 19
      MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      // K = 0x13
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };

    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
      // Cached version of prime
      if (primes[name]) return primes[name];
      var prime;
      if (name === 'k256') {
        prime = new K256();
      } else if (name === 'p224') {
        prime = new P224();
      } else if (name === 'p192') {
        prime = new P192();
      } else if (name === 'p25519') {
        prime = new P25519();
      } else {
        throw new Error('Unknown prime ' + name);
      }
      primes[name] = prime;
      return prime;
    };

    //
    // Base reduction engine
    //
    function Red(m) {
      if (typeof m === 'string') {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert(m.gtn(1), 'modulus must be greater than 1');
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, 'red works only with positives');
      assert(a.red, 'red works only with red numbers');
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert((a.negative | b.negative) === 0, 'red works only with positives');
      assert(a.red && a.red === b.red, 'red works only with red numbers');
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime) return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero()) return a.clone();
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);

      // Fast case
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      }

      // Tonelli-Shanks algorithm (Totally unoptimized and slow)
      //
      // Find Q and S, that Q * 2 ^ S = (P - 1)
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();

      // Find quadratic non-residue
      // NOTE: Max is such because of generalized Riemann hypothesis.
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero()) return new BN(1).toRed(this);
      if (num.cmpn(1) === 0) return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };

    //
    // Montgomery method engine
    //

    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var BN$1 = bnExports;

const version$q = "logger/5.7.0";

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = {
  debug: 1,
  "default": 2,
  info: 2,
  warning: 3,
  error: 4,
  off: 5
};
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    // Make sure all forms of normalization are supported
    ["NFD", "NFC", "NFKD", "NFKC"].forEach(form => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
  LogLevel["DEBUG"] = "DEBUG";
  LogLevel["INFO"] = "INFO";
  LogLevel["WARNING"] = "WARNING";
  LogLevel["ERROR"] = "ERROR";
  LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
  ///////////////////
  // Generic Errors
  // Unknown Error
  ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  // Not Implemented
  ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  // Unsupported Operation
  //   - operation
  ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
  //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
  ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
  // Some sort of bad response from the server
  ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
  // Timeout
  ErrorCode["TIMEOUT"] = "TIMEOUT";
  ///////////////////
  // Operational  Errors
  // Buffer Overrun
  ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  // Numeric Fault
  //   - operation: the operation being executed
  //   - fault: the reason this faulted
  ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ///////////////////
  // Argument Errors
  // Missing new operator to an object
  //  - name: The name of the class
  ErrorCode["MISSING_NEW"] = "MISSING_NEW";
  // Invalid argument (e.g. value is incompatible with type) to a function:
  //   - argument: The argument name that was invalid
  //   - value: The value of the argument
  ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  // Missing argument to a function:
  //   - count: The number of arguments received
  //   - expectedCount: The number of arguments expected
  ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  // Too many arguments
  //   - count: The number of arguments received
  //   - expectedCount: The number of arguments expected
  ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ///////////////////
  // Blockchain Errors
  // Call exception
  //  - transaction: the transaction
  //  - address?: the contract address
  //  - args?: The arguments passed into the function
  //  - method?: The Solidity method signature
  //  - errorSignature?: The EIP848 error signature
  //  - errorArgs?: The EIP848 error parameters
  //  - reason: The reason (only for EIP848 "Error(string)")
  ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  // Insufficient funds (< value + gasLimit * gasPrice)
  //   - transaction: the transaction attempted
  ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  // Nonce has already been used
  //   - transaction: the transaction attempted
  ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  // The replacement fee for the transaction is too low
  //   - transaction: the transaction attempted
  ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  // The gas limit could not be estimated
  //   - transaction: the transaction passed to estimateGas
  ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  // The transaction was replaced by one with a higher gas price
  //   - reason: "cancelled", "replaced" or "repriced"
  //   - cancelled: true if reason == "cancelled" or reason == "replaced")
  //   - hash: original transaction hash
  //   - replacement: the full TransactionsResponse for the replacement
  //   - receipt: the receipt of the replacement
  ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ///////////////////
  // Interaction Errors
  // The user rejected the action, such as signing a message or sending
  // a transaction
  ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    // Errors are being censored
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach(key => {
      const value = params[key];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 0x0f];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT:
        {
          url = "NUMERIC_FAULT";
          const fault = message;
          switch (fault) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              url += "-" + fault;
              break;
            case "negative-power":
            case "negative-width":
              url += "-unsupported";
              break;
            case "unbound-bitwise-result":
              url += "-unbound-result";
              break;
          }
          break;
        }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    // @TODO: Any??
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function (key) {
      error[key] = params[key];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value: value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 0x1fffffffffffff) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value: value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value: value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count,
        expectedCount: expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count,
        expectedCount: expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, {
        name: kind.name
      });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, {
        name: target.name,
        operation: "new"
      });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, {
        name: kind.name
      });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$q);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version) {
    return new Logger(version);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

var lib_esm$l = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get ErrorCode () { return ErrorCode; },
    get LogLevel () { return LogLevel; },
    Logger: Logger
});

const version$p = "bytes/5.7.0";

const logger$J = new Logger(version$p);
///////////////////////////////
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function () {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$J.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 0xff);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger$J.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$J.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map(item => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  // Find the first non-zero entry
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  // If we started with zeros, strip them
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger$J.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$J.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 0xf] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$J.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }
    return result;
  }
  return logger$J.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger$J.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach(item => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, {
    hexPad: "left"
  }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger$J.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger$J.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger$J.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature)) {
    let bytes = arrayify(signature);
    // Get the r, s and v
    if (bytes.length === 64) {
      // EIP-2098; pull the v from the top bit of s and clear it
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 0x7f;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger$J.throwArgumentError("invalid signature string", "signature", signature);
    }
    // Allow a recid to be used as the v
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$J.throwArgumentError("signature invalid v byte", "signature", signature);
      }
    }
    // Compute recoveryParam from v
    result.recoveryParam = 1 - result.v % 2;
    // Compute _vs from recoveryParam and s
    if (result.recoveryParam) {
      bytes[32] |= 0x80;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature.r;
    result.s = signature.s;
    result.v = signature.v;
    result.recoveryParam = signature.recoveryParam;
    result._vs = signature._vs;
    // If the _vs is available, use it to populate missing s, v and recoveryParam
    // and verify non-missing s, v and recoveryParam
    if (result._vs != null) {
      const vs = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs);
      // Set or check the recid
      const recoveryParam = vs[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$J.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
      }
      // Set or check the s
      vs[0] &= 0x7f;
      const s = hexlify(vs);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger$J.throwArgumentError("signature v mismatch _vs", "signature", signature);
      }
    }
    // Use recid and v to populate each other
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$J.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$J.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger$J.throwArgumentError("signature missing or invalid r", "signature", signature);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger$J.throwArgumentError("signature missing or invalid s", "signature", signature);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$J.throwArgumentError("signature s out of range", "signature", signature);
    }
    if (result.recoveryParam) {
      vs[0] |= 0x80;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger$J.throwArgumentError("signature invalid _vs", "signature", signature);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    // Set or check the _vs
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$J.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature) {
  signature = splitSignature(signature);
  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? "0x1c" : "0x1b"]));
}

var lib_esm$k = /*#__PURE__*/Object.freeze({
    __proto__: null,
    arrayify: arrayify,
    concat: concat,
    hexConcat: hexConcat,
    hexDataLength: hexDataLength,
    hexDataSlice: hexDataSlice,
    hexStripZeros: hexStripZeros,
    hexValue: hexValue,
    hexZeroPad: hexZeroPad,
    hexlify: hexlify,
    isBytes: isBytes,
    isBytesLike: isBytesLike,
    isHexString: isHexString,
    joinSignature: joinSignature,
    splitSignature: splitSignature,
    stripZeros: stripZeros,
    zeroPad: zeroPad
});

const version$o = "bignumber/5.7.0";

var BN = BN$1.BN;
const logger$I = new Logger(version$o);
const _constructorGuard$4 = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard$4) {
      logger$I.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault$1("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {}
    return logger$I.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    // Lots of people expect this, which we do not support, so check (See: #889)
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$I.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$I.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$I.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key) {
    return {
      type: "BigNumber",
      hex: this.toHexString()
    };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$4, toHex$1(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$4, toHex$1(new BN(value)));
      }
      return logger$I.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault$1("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      // Hexable interface (takes priority)
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        // For now, handle legacy JSON-ified values (goes away in v6)
        let hex = anyValue._hex;
        // New-form JSON
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger$I.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
// Normalize the hex string
function toHex$1(value) {
  // For BN, call on the hex string
  if (typeof value !== "string") {
    return toHex$1(value.toString(16));
  }
  // If negative, prepend the negative sign to the normalized positive value
  if (value[0] === "-") {
    // Strip off the negative sign
    value = value.substring(1);
    // Cannot have multiple negative signs (e.g. "--0x04")
    if (value[0] === "-") {
      logger$I.throwArgumentError("invalid hex", "value", value);
    }
    // Call toHex on the positive component
    value = toHex$1(value);
    // Do not allow "-0x00"
    if (value === "0x00") {
      return value;
    }
    // Negate the value
    return "-" + value;
  }
  // Add a "0x" prefix if missing
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  // Normalize zero
  if (value === "0x") {
    return "0x00";
  }
  // Make the string even length
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  // Trim to smallest even-length string
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$1(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
  const params = {
    fault: fault,
    operation: operation
  };
  if (value != null) {
    params.value = value;
  }
  return logger$I.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
// value should have no prefix
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}

const logger$H = new Logger(version$o);
const _constructorGuard$3 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  const params = {
    fault: fault,
    operation: operation
  };
  if (value !== undefined) {
    params.value = value;
  }
  return logger$H.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
let zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {}
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger$H.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  // Make sure wei is a big number (convert as necessary)
  value = BigNumber.from(value);
  const negative = value.lt(Zero$2);
  if (negative) {
    value = value.mul(NegativeOne$2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  // Strip training 0
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger$H.throwArgumentError("invalid decimal value", "value", value);
  }
  // Is it negative?
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger$H.throwArgumentError("missing value", "value", value);
  }
  // Split it into a whole and fractional part
  const comps = value.split(".");
  if (comps.length > 2) {
    logger$H.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0],
    fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  // Trim trailing zeros
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  // Check the fraction doesn't exceed our decimals size
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  // If decimals is 0, we have an empty string for fraction
  if (fraction === "") {
    fraction = "0";
  }
  // Fully pad the string with zeros to get to wei
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$H.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") ; else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger$H.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key, type, defaultValue) => {
        if (value[key] == null) {
          return defaultValue;
        }
        if (typeof value[key] !== type) {
          logger$H.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
        }
        return value[key];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger$H.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger$H.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$3, signed, width, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$H.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$H.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    // If we are already in range, we're done
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$H.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger$H.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    // If decimals looks more like a format, and there is no format, shift the parameters
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      // Allow NUMERIC_FAULT to bubble up
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger$H.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");

const version$n = "properties/5.7.0";

var __awaiter$f = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$G = new Logger(version$n);
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value: value,
    writable: false
  });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key]) {
      return ctor[key];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter$f(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map(key => {
      const value = object[key];
      return Promise.resolve(value).then(v => ({
        key: key,
        value: v
      }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger$G.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach(key => {
    if (!properties[key]) {
      logger$G.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key in object) {
    result[key] = object[key];
  }
  return result;
}
const opaque = {
  bigint: true,
  boolean: true,
  "function": true,
  number: true,
  string: true
};
function _isFrozen(object) {
  // Opaque objects are not mutable, so safe to copy by assignment
  if (object === undefined || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        // If accessing a value triggers an error, it is a getter
        // designed to do so (e.g. Result) and is therefore "frozen"
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$G.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  // Arrays are mutable, so we need to create a copy
  if (Array.isArray(object)) {
    return Object.freeze(object.map(item => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key in object) {
      const value = object[key];
      if (value === undefined) {
        continue;
      }
      defineReadOnly(result, key, deepCopy(value));
    }
    return result;
  }
  return logger$G.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key in info) {
      this[key] = deepCopy(info[key]);
    }
  }
}

var lib_esm$j = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Description: Description,
    checkProperties: checkProperties,
    deepCopy: deepCopy,
    defineReadOnly: defineReadOnly,
    getStatic: getStatic,
    resolveProperties: resolveProperties,
    shallowCopy: shallowCopy
});

const version$m = "abi/5.7.0";

const logger$F = new Logger(version$m);
const _constructorGuard$2 = {};
let ModifiersBytes = {
  calldata: true,
  memory: true,
  storage: true
};
let ModifiersNest = {
  calldata: true,
  memory: true
};
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger$F.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i) {
    logger$F.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent) {
    let node = {
      type: "",
      name: "",
      parent: parent,
      state: {
        allowType: true
      }
    };
    if (allowIndexed) {
      node.indexed = false;
    }
    return node;
  }
  let parent = {
    type: "",
    name: "",
    state: {
      allowType: true
    }
  };
  let node = parent;
  for (let i = 0; i < param.length; i++) {
    let c = param[i];
    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      // Hit a space...
      case " ":
        // If reading type, the type is done and may read a param or name
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        // If reading name, the name is done
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node.indexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }
        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }
        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError(i);
        }
    }
  }
  if (node.parent) {
    logger$F.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key in params) {
    defineReadOnly(object, key, params[key]);
  }
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$F.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || undefined
      };
      if (typeof this.indexed === "boolean") {
        result.indexed = this.indexed;
      }
      if (this.components) {
        result.components = this.components.map(comp => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result);
    }
    let result = "";
    // Array
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map(comp => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard$2, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map(param => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$F.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
        return null;
    }
    return logger$F.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$F.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map(input => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$F.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger$F.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach(modifier => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$F.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous: anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$F.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$F.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach(modifier => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    // Set (and check things are consistent) the constant property
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$F.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    // Set (and check things are consistent) the payable property
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$F.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    // If payable we can assume non-constant; otherwise we can't assume
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$F.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$F.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$F.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : undefined,
        inputs: this.inputs.map(input => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger$F.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$F.throwArgumentError("invalid constructor object", "value", value);
    }
    let state = verifyState(value);
    if (state.constant) {
      logger$F.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let params = {
      type: "constructor"
    };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$F.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : undefined,
        inputs: this.inputs.map(input => JSON.parse(input.format(format))),
        outputs: this.outputs.map(output => JSON.parse(output.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map(output => output.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$F.throwArgumentError("invalid function object", "value", value);
    }
    let state = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let params = {
      type: "function"
    };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$F.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$F.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    // We have outputs
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$F.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$F.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$F.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map(input => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$F.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$2, params));
  }
  static fromString(value) {
    let params = {
      type: "error"
    };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$F.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type) {
  // These need to be transformed to their full description
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  // @TODO: more verification
  return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$F.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger$F.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}

const logger$E = new Logger(version$m);
function checkResultErrors(result) {
  // Find the first error (if any)
  const errors = [];
  const checkErrors = function (path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key in object) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object[key]);
      } catch (error) {
        errors.push({
          path: childPath,
          error: error
        });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
class Coder {
  constructor(name, type, localName, dynamic) {
    // @TODO: defineReadOnly these
    this.name = name;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger$E.throwArgumentError(message, this.localName, value);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat(writer._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes = arrayify(value);
    const paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = concat([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  }
  _getValue(value) {
    let bytes = arrayify(BigNumber.from(value));
    if (bytes.length > this.wordSize) {
      logger$E.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return value => {
      this._data[offset] = this._getValue(value);
    };
  }
}
class Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name, value) {
    let match = name.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name, value);
    }
    return Reader.coerce(name, value);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger$E.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes = this._peekBytes(0, length, !!loose);
    this._offset += bytes.length;
    // @TODO: Make sure the length..end bytes are all 0?
    return bytes.slice(0, length);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$l = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};
function noop() {}
var on$1 = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name) {
  throw new Error('process.binding is not supported');
}
function cwd() {
  return '/';
}
function chdir(dir) {
  throw new Error('process.chdir is not supported');
}
function umask() {
  return 0;
}

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
  return new Date().getTime();
};

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}
var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$l,
  versions: versions,
  on: on$1,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};
var process$1 = browser$1;

var sha3Exports = {};
var sha3$1 = {
  get exports(){ return sha3Exports; },
  set exports(v){ sha3Exports = v; },
};

(function (module) {
  /*jslint bitwise: true */
  (function () {

    var INPUT_ERROR = 'input is invalid type';
    var FINALIZE_ERROR = 'finalize already called';
    var WINDOW = typeof window === 'object';
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === 'object';
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process$1 === 'object' && process$1.versions && process$1.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    var HEX_CHARS = '0123456789abcdef'.split('');
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
    var CSHAKE_BYTEPAD = {
      '128': 168,
      '256': 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function (obj) {
        return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function (bits, padding, outputType) {
      return function (message) {
        return new Keccak(bits, padding, bits).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function (bits, padding, outputType) {
      return function (message, outputBits) {
        return new Keccak(bits, padding, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function (bits, padding, outputType) {
      return function (message, outputBits, n, s) {
        return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
      };
    };
    var createKmacOutputMethod = function (bits, padding, outputType) {
      return function (key, message, outputBits, s) {
        return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
      };
    };
    var createOutputMethods = function (method, createMethod, bits, padding) {
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createMethod(bits, padding, type);
      }
      return method;
    };
    var createMethod = function (bits, padding) {
      var method = createOutputMethod(bits, padding, 'hex');
      method.create = function () {
        return new Keccak(bits, padding, bits);
      };
      method.update = function (message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits, padding);
    };
    var createShakeMethod = function (bits, padding) {
      var method = createShakeOutputMethod(bits, padding, 'hex');
      method.create = function (outputBits) {
        return new Keccak(bits, padding, outputBits);
      };
      method.update = function (message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits, padding);
    };
    var createCshakeMethod = function (bits, padding) {
      var w = CSHAKE_BYTEPAD[bits];
      var method = createCshakeOutputMethod(bits, padding, 'hex');
      method.create = function (outputBits, n, s) {
        if (!n && !s) {
          return methods['shake' + bits].create(outputBits);
        } else {
          return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
        }
      };
      method.update = function (message, outputBits, n, s) {
        return method.create(outputBits, n, s).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
    };
    var createKmacMethod = function (bits, padding) {
      var w = CSHAKE_BYTEPAD[bits];
      var method = createKmacOutputMethod(bits, padding, 'hex');
      method.create = function (key, outputBits, s) {
        return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
      };
      method.update = function (key, message, outputBits, s) {
        return method.create(key, outputBits, s).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits, padding);
    };
    var algorithms = [{
      name: 'keccak',
      padding: KECCAK_PADDING,
      bits: BITS,
      createMethod: createMethod
    }, {
      name: 'sha3',
      padding: PADDING,
      bits: BITS,
      createMethod: createMethod
    }, {
      name: 'shake',
      padding: SHAKE_PADDING,
      bits: SHAKE_BITS,
      createMethod: createShakeMethod
    }, {
      name: 'cshake',
      padding: CSHAKE_PADDING,
      bits: SHAKE_BITS,
      createMethod: createCshakeMethod
    }, {
      name: 'kmac',
      padding: CSHAKE_PADDING,
      bits: SHAKE_BITS,
      createMethod: createKmacMethod
    }];
    var methods = {},
      methodNames = [];
    for (var i = 0; i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j = 0; j < bits.length; ++j) {
        var methodName = algorithm.name + '_' + bits[j];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== 'sha3') {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits, padding, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i = 0; i < 50; ++i) {
        this.s[i] = 0;
      }
    }
    Keccak.prototype.update = function (message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString,
        type = typeof message;
      if (type !== 'string') {
        if (type === 'object') {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks,
        byteCount = this.byteCount,
        length = message.length,
        blockCount = this.blockCount,
        index = 0,
        s = this.s,
        i,
        code;
      while (index < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
          }
        }
        if (notString) {
          for (i = this.start; index < length && i < byteCount; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start; index < length && i < byteCount; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 0x800) {
              blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
            } else if (code < 0xd800 || code >= 0xe000) {
              blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
            } else {
              code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
              blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        if (i >= byteCount) {
          this.start = i - byteCount;
          this.block = blocks[blockCount];
          for (i = 0; i < blockCount; ++i) {
            s[i] ^= blocks[i];
          }
          f(s);
          this.reset = true;
        } else {
          this.start = i;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function (x, right) {
      var o = x & 255,
        n = 1;
      var bytes = [o];
      x = x >> 8;
      o = x & 255;
      while (o > 0) {
        bytes.unshift(o);
        x = x >> 8;
        o = x & 255;
        ++n;
      }
      if (right) {
        bytes.push(n);
      } else {
        bytes.unshift(n);
      }
      this.update(bytes);
      return bytes.length;
    };
    Keccak.prototype.encodeString = function (str) {
      var notString,
        type = typeof str;
      if (type !== 'string') {
        if (type === 'object') {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes = 0,
        length = str.length;
      if (notString) {
        bytes = length;
      } else {
        for (var i = 0; i < str.length; ++i) {
          var code = str.charCodeAt(i);
          if (code < 0x80) {
            bytes += 1;
          } else if (code < 0x800) {
            bytes += 2;
          } else if (code < 0xd800 || code >= 0xe000) {
            bytes += 3;
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);
            bytes += 4;
          }
        }
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };
    Keccak.prototype.bytepad = function (strs, w) {
      var bytes = this.encode(w);
      for (var i = 0; i < strs.length; ++i) {
        bytes += this.encodeString(strs[i]);
      }
      var paddingBytes = w - bytes % w;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };
    Keccak.prototype.finalize = function () {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks,
        i = this.lastByteIndex,
        blockCount = this.blockCount,
        s = this.s;
      blocks[i >> 2] |= this.padding[i & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      blocks[blockCount - 1] |= 0x80000000;
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f(s);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function () {
      this.finalize();
      var blockCount = this.blockCount,
        s = this.s,
        outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes,
        i = 0,
        j = 0;
      var hex = '',
        block;
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          block = s[i];
          hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];
        }
        if (j % blockCount === 0) {
          f(s);
          i = 0;
        }
      }
      if (extraBytes) {
        block = s[i];
        hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];
        if (extraBytes > 1) {
          hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];
        }
      }
      return hex;
    };
    Keccak.prototype.arrayBuffer = function () {
      this.finalize();
      var blockCount = this.blockCount,
        s = this.s,
        outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes,
        i = 0,
        j = 0;
      var bytes = this.outputBits >> 3;
      var buffer;
      if (extraBytes) {
        buffer = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer);
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          array[j] = s[i];
        }
        if (j % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        array[i] = s[i];
        buffer = buffer.slice(0, bytes);
      }
      return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function () {
      this.finalize();
      var blockCount = this.blockCount,
        s = this.s,
        outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes,
        i = 0,
        j = 0;
      var array = [],
        offset,
        block;
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          offset = j << 2;
          block = s[i];
          array[offset] = block & 0xFF;
          array[offset + 1] = block >> 8 & 0xFF;
          array[offset + 2] = block >> 16 & 0xFF;
          array[offset + 3] = block >> 24 & 0xFF;
        }
        if (j % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        if (extraBytes > 1) {
          array[offset + 1] = block >> 8 & 0xFF;
        }
        if (extraBytes > 2) {
          array[offset + 2] = block >> 16 & 0xFF;
        }
      }
      return array;
    };
    function Kmac(bits, padding, outputBits) {
      Keccak.call(this, bits, padding, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function () {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f = function (s) {
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = s[11] << 4 | s[10] >>> 28;
        b33 = s[10] << 4 | s[11] >>> 28;
        b14 = s[20] << 3 | s[21] >>> 29;
        b15 = s[21] << 3 | s[20] >>> 29;
        b46 = s[31] << 9 | s[30] >>> 23;
        b47 = s[30] << 9 | s[31] >>> 23;
        b28 = s[40] << 18 | s[41] >>> 14;
        b29 = s[41] << 18 | s[40] >>> 14;
        b20 = s[2] << 1 | s[3] >>> 31;
        b21 = s[3] << 1 | s[2] >>> 31;
        b2 = s[13] << 12 | s[12] >>> 20;
        b3 = s[12] << 12 | s[13] >>> 20;
        b34 = s[22] << 10 | s[23] >>> 22;
        b35 = s[23] << 10 | s[22] >>> 22;
        b16 = s[33] << 13 | s[32] >>> 19;
        b17 = s[32] << 13 | s[33] >>> 19;
        b48 = s[42] << 2 | s[43] >>> 30;
        b49 = s[43] << 2 | s[42] >>> 30;
        b40 = s[5] << 30 | s[4] >>> 2;
        b41 = s[4] << 30 | s[5] >>> 2;
        b22 = s[14] << 6 | s[15] >>> 26;
        b23 = s[15] << 6 | s[14] >>> 26;
        b4 = s[25] << 11 | s[24] >>> 21;
        b5 = s[24] << 11 | s[25] >>> 21;
        b36 = s[34] << 15 | s[35] >>> 17;
        b37 = s[35] << 15 | s[34] >>> 17;
        b18 = s[45] << 29 | s[44] >>> 3;
        b19 = s[44] << 29 | s[45] >>> 3;
        b10 = s[6] << 28 | s[7] >>> 4;
        b11 = s[7] << 28 | s[6] >>> 4;
        b42 = s[17] << 23 | s[16] >>> 9;
        b43 = s[16] << 23 | s[17] >>> 9;
        b24 = s[26] << 25 | s[27] >>> 7;
        b25 = s[27] << 25 | s[26] >>> 7;
        b6 = s[36] << 21 | s[37] >>> 11;
        b7 = s[37] << 21 | s[36] >>> 11;
        b38 = s[47] << 24 | s[46] >>> 8;
        b39 = s[46] << 24 | s[47] >>> 8;
        b30 = s[8] << 27 | s[9] >>> 5;
        b31 = s[9] << 27 | s[8] >>> 5;
        b12 = s[18] << 20 | s[19] >>> 12;
        b13 = s[19] << 20 | s[18] >>> 12;
        b44 = s[29] << 7 | s[28] >>> 25;
        b45 = s[28] << 7 | s[29] >>> 25;
        b26 = s[38] << 8 | s[39] >>> 24;
        b27 = s[39] << 8 | s[38] >>> 24;
        b8 = s[48] << 14 | s[49] >>> 18;
        b9 = s[49] << 14 | s[48] >>> 18;
        s[0] = b0 ^ ~b2 & b4;
        s[1] = b1 ^ ~b3 & b5;
        s[10] = b10 ^ ~b12 & b14;
        s[11] = b11 ^ ~b13 & b15;
        s[20] = b20 ^ ~b22 & b24;
        s[21] = b21 ^ ~b23 & b25;
        s[30] = b30 ^ ~b32 & b34;
        s[31] = b31 ^ ~b33 & b35;
        s[40] = b40 ^ ~b42 & b44;
        s[41] = b41 ^ ~b43 & b45;
        s[2] = b2 ^ ~b4 & b6;
        s[3] = b3 ^ ~b5 & b7;
        s[12] = b12 ^ ~b14 & b16;
        s[13] = b13 ^ ~b15 & b17;
        s[22] = b22 ^ ~b24 & b26;
        s[23] = b23 ^ ~b25 & b27;
        s[32] = b32 ^ ~b34 & b36;
        s[33] = b33 ^ ~b35 & b37;
        s[42] = b42 ^ ~b44 & b46;
        s[43] = b43 ^ ~b45 & b47;
        s[4] = b4 ^ ~b6 & b8;
        s[5] = b5 ^ ~b7 & b9;
        s[14] = b14 ^ ~b16 & b18;
        s[15] = b15 ^ ~b17 & b19;
        s[24] = b24 ^ ~b26 & b28;
        s[25] = b25 ^ ~b27 & b29;
        s[34] = b34 ^ ~b36 & b38;
        s[35] = b35 ^ ~b37 & b39;
        s[44] = b44 ^ ~b46 & b48;
        s[45] = b45 ^ ~b47 & b49;
        s[6] = b6 ^ ~b8 & b0;
        s[7] = b7 ^ ~b9 & b1;
        s[16] = b16 ^ ~b18 & b10;
        s[17] = b17 ^ ~b19 & b11;
        s[26] = b26 ^ ~b28 & b20;
        s[27] = b27 ^ ~b29 & b21;
        s[36] = b36 ^ ~b38 & b30;
        s[37] = b37 ^ ~b39 & b31;
        s[46] = b46 ^ ~b48 & b40;
        s[47] = b47 ^ ~b49 & b41;
        s[8] = b8 ^ ~b0 & b2;
        s[9] = b9 ^ ~b1 & b3;
        s[18] = b18 ^ ~b10 & b12;
        s[19] = b19 ^ ~b11 & b13;
        s[28] = b28 ^ ~b20 & b22;
        s[29] = b29 ^ ~b21 & b23;
        s[38] = b38 ^ ~b30 & b32;
        s[39] = b39 ^ ~b31 & b33;
        s[48] = b48 ^ ~b40 & b42;
        s[49] = b49 ^ ~b41 & b43;
        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i = 0; i < methodNames.length; ++i) {
        root[methodNames[i]] = methods[methodNames[i]];
      }
    }
  })();
})(sha3$1);
var sha3 = sha3Exports;

function keccak256$1(data) {
  return '0x' + sha3.keccak_256(arrayify(data));
}

var lib_esm$i = /*#__PURE__*/Object.freeze({
    __proto__: null,
    keccak256: keccak256$1
});

const version$k = "rlp/5.7.0";

const logger$D = new Logger(version$k);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 0xff);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function (child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(0xc0 + payload.length);
      return payload;
    }
    const length = arrayifyInteger(payload.length);
    length.unshift(0xf7 + length.length);
    return length.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger$D.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 0x7f) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(0x80 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(0xb7 + length.length);
  return length.concat(data);
}
function encode$2(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger$D.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return {
    consumed: 1 + length,
    result: result
  };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
  if (data.length === 0) {
    logger$D.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  // Array with extra length prefix
  if (data[offset] >= 0xf8) {
    const lengthLength = data[offset] - 0xf7;
    if (offset + 1 + lengthLength > data.length) {
      logger$D.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger$D.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 0xc0) {
    const length = data[offset] - 0xc0;
    if (offset + 1 + length > data.length) {
      logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 0xb8) {
    const lengthLength = data[offset] - 0xb7;
    if (offset + 1 + lengthLength > data.length) {
      logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger$D.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return {
      consumed: 1 + lengthLength + length,
      result: result
    };
  } else if (data[offset] >= 0x80) {
    const length = data[offset] - 0x80;
    if (offset + 1 + length > data.length) {
      logger$D.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return {
      consumed: 1 + length,
      result: result
    };
  }
  return {
    consumed: 1,
    result: hexlify(data[offset])
  };
}
function decode$2(data) {
  const bytes = arrayify(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger$D.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

var lib_esm$h = /*#__PURE__*/Object.freeze({
    __proto__: null,
    decode: decode$2,
    encode: encode$2
});

const version$j = "address/5.7.0";

const logger$C = new Logger(version$j);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger$C.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak256$1(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 0x0f) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map(c => {
    return ibanLookup[c];
  }).join("");
  // Javascript can handle integers safely up to 15 (decimal) digits
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$C.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    // Missing the 0x prefix
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    // It is a checksummed address with a bad checksum
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$C.throwArgumentError("bad address checksum", "address", address);
    }
    // Maybe ICAP? (we only support direct mode)
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    // It is an ICAP address with a bad checksum
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$C.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$C.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {}
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
  let from = null;
  try {
    from = getAddress(transaction.from);
  } catch (error) {
    logger$C.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256$1(encode$2([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger$C.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger$C.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256$1(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
}

var lib_esm$g = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getAddress: getAddress,
    getContractAddress: getContractAddress,
    getCreate2Address: getCreate2Address,
    getIcapAddress: getIcapAddress,
    isAddress: isAddress
});

class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
}

// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, undefined, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}

const logger$B = new Logger(version$m);
function pack$1(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map(coder => {
      const name = coder.localName;
      if (!name) {
        logger$B.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: coder,
          value: values
        });
      }
      if (unique[name]) {
        logger$B.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: coder,
          value: values
        });
      }
      unique[name] = true;
      return values[name];
    });
  } else {
    logger$B.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger$B.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      // Get current dynamic offset (for the future pointer)
      let dynamicOffset = dynamicWriter.length;
      // Encode the dynamic value into the dynamicWriter
      coder.encode(dynamicWriter, value);
      // Prepare to populate the correct offset once we are done
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push(baseOffset => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  // Backfill all the dynamic offsets, now that we know the static length
  updateFuncs.forEach(func => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  // A reader anchored to this base
  let baseReader = reader.subReader(0);
  coders.forEach(coder => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        // Cannot recover from this
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        // Cannot recover from this
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != undefined) {
      values.push(value);
    }
  });
  // We only output named properties for uniquely named coders
  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  // Add any named parameters (i.e. tuples)
  coders.forEach((coder, index) => {
    let name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values[name] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    // Verifies the child coder is valid (even if the array is dynamic or 0-length)
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger$B.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack$1(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      // Check that there is *roughly* enough data to ensure
      // stray random data is not being read as a length. Each
      // slot requires at least 32 bytes for their value (or 32
      // bytes as a link to the data). This could use a much
      // tighter bound, but we are erroring on the side of safety.
      if (count * 32 > reader._data.length) {
        logger$B.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count: count
        });
      }
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
}

class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
}

class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
}

// @TODO: Merge this with bytes
class FixedBytesCoder extends Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
}

class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
}

const AddressZero$1 = "0x0000000000000000000000000000000000000000";

const NegativeOne$1 = /*#__PURE__*/BigNumber.from(-1);
const Zero$1 = /*#__PURE__*/BigNumber.from(0);
const One$1 = /*#__PURE__*/BigNumber.from(1);
const Two = /*#__PURE__*/BigNumber.from(2);
const WeiPerEther = /*#__PURE__*/BigNumber.from("1000000000000000000");
const MaxUint256$1 = /*#__PURE__*/BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const MinInt256 = /*#__PURE__*/BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
const MaxInt256 = /*#__PURE__*/BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

// NFKC (composed)             // (decomposed)
const EtherSymbol = "\u039e"; // "\uD835\uDF63";

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AddressZero: AddressZero$1,
    EtherSymbol: EtherSymbol,
    HashZero: HashZero,
    MaxInt256: MaxInt256,
    MaxUint256: MaxUint256$1,
    MinInt256: MinInt256,
    NegativeOne: NegativeOne$1,
    One: One$1,
    Two: Two,
    WeiPerEther: WeiPerEther,
    Zero: Zero$1
});

class NumberCoder extends Coder {
  constructor(size, signed, localName) {
    const name = (signed ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    this.size = size;
    this.signed = signed;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v = BigNumber.from(value);
    // Check bounds are safe for encoding
    let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v.gt(bounds) || v.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v.lt(Zero$1) || v.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v = v.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
}

const version$i = "strings/5.7.0";

const logger$A = new Logger(version$i);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
  UnicodeNormalizationForm["current"] = "";
  UnicodeNormalizationForm["NFC"] = "NFC";
  UnicodeNormalizationForm["NFD"] = "NFD";
  UnicodeNormalizationForm["NFKC"] = "NFKC";
  UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
  // A continuation byte was present where there was nothing to continue
  // - offset = the index the codepoint began in
  Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
  // - offset = the index the codepoint began in
  Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
  // The string is too short to process the expected codepoint
  // - offset = the index the codepoint began in
  Utf8ErrorReason["OVERRUN"] = "string overrun";
  // A missing continuation byte was expected but not found
  // - offset = the index the continuation byte was expected at
  Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
  // The computed code point is outside the range for UTF-8
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; outside the UTF-8 range
  Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
  // UTF-8 strings may not contain UTF-16 surrogate pairs
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
  Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
  // The string is an overlong representation
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; already bounds checked
  Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger$A.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 0x02) {
        break;
      }
      i++;
    }
    return i;
  }
  // This byte runs us past the end of the string, so just jump to the end
  // (but the first byte was read already read and therefore skipped)
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  // Nothing to skip
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  // Overlong representations are otherwise "valid" code points; just non-deistingtished
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  // Put the replacement character into the output
  output.push(0xfffd);
  // Otherwise, process as if ignoring errors
  return ignoreFunc(reason, offset, bytes);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i = 0;
  // Invalid bytes are ignored
  while (i < bytes.length) {
    const c = bytes[i++];
    // 0xxx xxxx
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    // Multibyte; how many bytes left for this character?
    let extraLength = null;
    let overlongMask = null;
    // 110x xxxx 10xx xxxx
    if ((c & 0xe0) === 0xc0) {
      extraLength = 1;
      overlongMask = 0x7f;
      // 1110 xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf0) === 0xe0) {
      extraLength = 2;
      overlongMask = 0x7ff;
      // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf8) === 0xf0) {
      extraLength = 3;
      overlongMask = 0xffff;
    } else {
      if ((c & 0xc0) === 0x80) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
      }
      continue;
    }
    // Do we have enough bytes in our data?
    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
      continue;
    }
    // Remove the length prefix from the char
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i];
      // Invalid continuation byte
      if ((nextChar & 0xc0) != 0x80) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 0x3f;
      i++;
    }
    // See above loop for invalid continuation byte
    if (res === null) {
      continue;
    }
    // Maximum code point
    if (res > 0x10ffff) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    // Reserved for UTF-16 surrogate halves
    if (res >= 0xd800 && res <= 0xdfff) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    // Check for overlong sequences (more bytes than needed)
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$A.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 0x80) {
      result.push(c);
    } else if (c < 0x800) {
      result.push(c >> 6 | 0xc0);
      result.push(c & 0x3f | 0x80);
    } else if ((c & 0xfc00) == 0xd800) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
        throw new Error("invalid utf-8 string");
      }
      // Surrogate Pair
      const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
      result.push(pair >> 18 | 0xf0);
      result.push(pair >> 12 & 0x3f | 0x80);
      result.push(pair >> 6 & 0x3f | 0x80);
      result.push(pair & 0x3f | 0x80);
    } else {
      result.push(c >> 12 | 0xe0);
      result.push(c >> 6 & 0x3f | 0x80);
      result.push(c & 0x3f | 0x80);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map(codePoint => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return "\\\"";
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 0xffff) {
      return escapeChar(codePoint);
    }
    codePoint -= 0x10000;
    return escapeChar((codePoint >> 10 & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map(codePoint => {
    if (codePoint <= 0xffff) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 0x10000;
    return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

function formatBytes32String(text) {
  // Get the bytes
  const bytes = toUtf8Bytes(text);
  // Check we have room for null-termination
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  // Zero-pad (implicitly null-terminates)
  return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
  const data = arrayify(bytes);
  // Must be 32 bytes with a null-termination
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  // Find the null termination
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  // Determine the string value
  return toUtf8String(data.slice(0, length));
}

function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function (value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach(pair => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map(v => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return {
      l: lo,
      h: hi
    };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i = 0; i < ranges.length; i++) {
    let range = ranges[i];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
// @TODO: Make this relative...
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(v => parseInt(v, 16));
const Table_B_2_ranges = [{
  h: 25,
  s: 32,
  l: 65
}, {
  h: 30,
  s: 32,
  e: [23],
  l: 127
}, {
  h: 54,
  s: 1,
  e: [48],
  l: 64,
  d: 2
}, {
  h: 14,
  s: 1,
  l: 57,
  d: 2
}, {
  h: 44,
  s: 1,
  l: 17,
  d: 2
}, {
  h: 10,
  s: 1,
  e: [2, 6, 8],
  l: 61,
  d: 2
}, {
  h: 16,
  s: 1,
  l: 68,
  d: 2
}, {
  h: 84,
  s: 1,
  e: [18, 24, 66],
  l: 19,
  d: 2
}, {
  h: 26,
  s: 32,
  e: [17],
  l: 435
}, {
  h: 22,
  s: 1,
  l: 71,
  d: 2
}, {
  h: 15,
  s: 80,
  l: 40
}, {
  h: 31,
  s: 32,
  l: 16
}, {
  h: 32,
  s: 1,
  l: 80,
  d: 2
}, {
  h: 52,
  s: 1,
  l: 42,
  d: 2
}, {
  h: 12,
  s: 1,
  l: 55,
  d: 2
}, {
  h: 40,
  s: 1,
  e: [38],
  l: 15,
  d: 2
}, {
  h: 14,
  s: 1,
  l: 48,
  d: 2
}, {
  h: 37,
  s: 48,
  l: 49
}, {
  h: 148,
  s: 1,
  l: 6351,
  d: 2
}, {
  h: 88,
  s: 1,
  l: 160,
  d: 2
}, {
  h: 15,
  s: 16,
  l: 704
}, {
  h: 25,
  s: 26,
  l: 854
}, {
  h: 25,
  s: 32,
  l: 55915
}, {
  h: 37,
  s: 40,
  l: 1247
}, {
  h: 25,
  s: -119711,
  l: 53248
}, {
  h: 25,
  s: -119763,
  l: 52
}, {
  h: 25,
  s: -119815,
  l: 52
}, {
  h: 25,
  s: -119867,
  e: [1, 4, 5, 7, 8, 11, 12, 17],
  l: 52
}, {
  h: 25,
  s: -119919,
  l: 52
}, {
  h: 24,
  s: -119971,
  e: [2, 7, 8, 17],
  l: 52
}, {
  h: 24,
  s: -120023,
  e: [2, 7, 13, 15, 16, 17],
  l: 52
}, {
  h: 25,
  s: -120075,
  l: 52
}, {
  h: 25,
  s: -120127,
  l: 52
}, {
  h: 25,
  s: -120179,
  l: 52
}, {
  h: 25,
  s: -120231,
  l: 52
}, {
  h: 25,
  s: -120283,
  l: 52
}, {
  h: 25,
  s: -120335,
  l: 52
}, {
  h: 24,
  s: -119543,
  e: [17],
  l: 56
}, {
  h: 24,
  s: -119601,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119659,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119717,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119775,
  e: [17],
  l: 58
}];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach(value => {
      accum.push(value);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  // This allows platforms with incomplete normalize to bypass
  // it for very basic names which the built-in toLowerCase
  // will certainly handle correctly
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  // Get the code points (keeping the current normalization)
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map(code => {
    // Substitute Table B.1 (Maps to Nothing)
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 0xfe00 && code <= 0xfe0f) {
      return [];
    }
    // Substitute Table B.2 (Case Folding)
    let codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    // No Substitution
    return [code];
  }));
  // Normalize using form KC
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9
  codes.forEach(code => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  // Prohibit Unassigned Code Points (Table A.1)
  codes.forEach(code => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  // IDNA extras
  let name = _toUtf8String(codes);
  // IDNA: 4.2.3.1
  if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name;
}

var lib_esm$f = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get UnicodeNormalizationForm () { return UnicodeNormalizationForm; },
    Utf8ErrorFuncs: Utf8ErrorFuncs,
    get Utf8ErrorReason () { return Utf8ErrorReason; },
    _toEscapedUtf8String: _toEscapedUtf8String,
    formatBytes32String: formatBytes32String,
    nameprep: nameprep,
    parseBytes32String: parseBytes32String,
    toUtf8Bytes: toUtf8Bytes,
    toUtf8CodePoints: toUtf8CodePoints,
    toUtf8String: toUtf8String
});

class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}

class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach(coder => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach(coder => {
      values.push(coder.defaultValue());
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    // Add named values
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack$1(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
}

const logger$z = new Logger(version$m);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map(component => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    // u?int[0-9]*
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger$z.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    // bytes[0-9]+
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger$z.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger$z.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map(type => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger$z.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: {
          types: types.length,
          values: values.length
        },
        value: {
          types: types,
          values: values
        }
      });
    }
    const coders = types.map(type => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data, loose) {
    const coders = types.map(type => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
}
const defaultAbiCoder = new AbiCoder();

function id(text) {
  return keccak256$1(toUtf8Bytes(text));
}

const version$h = "hash/5.7.0";

function decode$1(textData) {
  textData = atob(textData);
  const data = [];
  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return arrayify(data);
}
function encode$1(data) {
  data = arrayify(data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}

var lib_esm$e = /*#__PURE__*/Object.freeze({
    __proto__: null,
    decode: decode$1,
    encode: encode$1
});

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = function (arr, depth) {
    forEach.call(arr, function (val) {
      if (depth > 0 && Array.isArray(val)) {
        flatDeep(val, depth - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  // decode the frequency table
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1]; // first symbol has frequency 1
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  // skip the sized-payload that the last 3 symbols index into
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      // this will read beyond end of buffer
      // but (undefined|0) => zero pad
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N = 31;
  const FULL = Math.pow(2, N);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  // fill register
  let register = 0;
  for (let i = 0; i < N; i++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL; // treat like a float
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      // binary search
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break; // first symbol is end mark
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map(x => {
    switch (x - offset) {
      case 3:
        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}
// returns an iterator which returns the next symbol
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(bytes) {
  return read_payload(decode_arithmetic(bytes));
}
// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n, next) {
  let v = Array(n);
  for (let i = 0; i < n; i++) v[i] = 1 + next();
  return v;
}
function read_ascending(n, next) {
  let v = Array(n);
  for (let i = 0, x = -1; i < n; i++) v[i] = x += 1 + next();
  return v;
}
function read_deltas(n, next) {
  let v = Array(n);
  for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
  return v;
}
function read_member_array(next, lookup) {
  let v = read_ascending(next(), next);
  let n = next();
  let vX = read_ascending(n, next);
  let vN = read_counts(n, next);
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < vN[i]; j++) {
      v.push(vX[i] + j);
    }
  }
  return lookup ? v.map(x => lookup[x]) : v;
}
// returns array of 
// [x, ys] => single replacement rule
// [x, ys, n, dx, dx] => linear map
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v = [];
  while (true) {
    let i = next();
    if (i == 0) break;
    v.push(i);
  }
  return v;
}
function read_transposed(n, w, next) {
  let m = Array(n).fill(undefined).map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return flat(m.map((v, i) => {
    const x = v[0],
      ys = v.slice(1);
    //let [x, ...ys] = v;
    //return Array(vN[i]).fill().map((_, j) => {
    return Array(vN[i]).fill(undefined).map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map(y => y + j_dy)];
    });
  }));
}
function read_replacement_table(w, next) {
  let n = 1 + next();
  let m = read_transposed(n, 1 + w, next);
  return m.map(v => [v[0], v.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a, b) => a - b);
  return read();
  function read() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0) break;
      branches.push({
        set: new Set(keys),
        node: read()
      });
    }
    branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return {
      branches,
      valid,
      fe0f,
      save,
      check
    };
  }
}

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
function getData() {
  return read_compressed_payload(decode$1('AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=='));
}

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
const r$1 = getData();
// @TODO: This should be lazily loaded
const VALID = new Set(read_member_array(r$1));
const IGNORED = new Set(read_member_array(r$1));
const MAPPED = read_mapped_map(r$1);
const EMOJI_ROOT = read_emoji_trie(r$1);
//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));
//const STOP = 0x2E;
const HYPHEN = 0x2D;
const UNDERSCORE = 0x5F;
function explode_cp(name) {
  return toUtf8CodePoints(name);
}
function filter_fe0f(cps) {
  return cps.filter(cp => cp != 0xFE0F);
}
function ens_normalize_post_check(name) {
  for (let label of name.split('.')) {
    let cps = explode_cp(label);
    try {
      for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
        if (cps[i] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name;
}
function ens_normalize(name) {
  return ens_normalize_post_check(normalize(name, filter_fe0f));
}
function normalize(name, emoji_filter) {
  let input = explode_cp(name).reverse(); // flip for pop
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s) {
  return s.normalize('NFC');
}
function consume_emoji_reversed(cps, eaten) {
  var _a;
  let node = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten) eaten.length = 0; // clear input buffer (if needed)
  while (pos) {
    let cp = cps[--pos];
    node = (_a = node.branches.find(x => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
    if (!node) break;
    if (node.save) {
      // remember
      saved = cp;
    } else if (node.check) {
      // check exclusion
      if (cp === saved) break;
    }
    stack.push(cp);
    if (node.fe0f) {
      stack.push(0xFE0F);
      if (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F
    }

    if (node.valid) {
      // this is a valid emoji (so far)
      emoji = stack.slice(); // copy stack
      if (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)
      if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)
      cps.length = pos; // truncate
    }
  }

  return emoji;
}

const logger$y = new Logger(version$h);
const Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name) {
  const bytes = toUtf8Bytes(ens_normalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes.length; i++) {
    const d = bytes[i];
    // A separator (i.e. "."); copy this component
    if (d === 0x2e) {
      comps.push(checkComponent(bytes.slice(last, i)));
      last = i + 1;
    }
  }
  // There was a stray separator at the end of the name
  if (last >= bytes.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
function ensNormalize(name) {
  return ensNameSplit(name).map(comp => toUtf8String(comp)).join(".");
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {}
  return false;
}
function namehash(name) {
  /* istanbul ignore if */
  if (typeof name !== "string") {
    logger$y.throwArgumentError("invalid ENS name; not a string", "name", name);
  }
  let result = Zeros$1;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256$1(concat([result, keccak256$1(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name) {
  return hexlify(concat(ensNameSplit(name).map(comp => {
    // DNS does not allow components over 63 bytes in length
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}

const messagePrefix = "\x19Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256$1(concat([toUtf8Bytes(messagePrefix), toUtf8Bytes(String(message.length)), message]));
}

var __awaiter$e = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$x = new Logger(version$h);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
function checkString(key) {
  return function (value) {
    if (typeof value !== "string") {
      logger$x.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function (value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {}
    return logger$x.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function (value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {}
    return logger$x.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function (value) {
    try {
      const bytes = arrayify(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes);
    } catch (error) {}
    return logger$x.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  // intXX and uintXX
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$x.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function (value) {
        const v = BigNumber.from(value);
        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger$x.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v.toTwos(256).toHexString(), 32);
      };
    }
  }
  // bytesXX
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$x.throwArgumentError("invalid bytes width", "type", type);
      }
      return function (value) {
        const bytes = arrayify(value);
        if (bytes.length !== width) {
          logger$x.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function (value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function (value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function (value) {
        return keccak256$1(value);
      };
    case "string":
      return function (value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({
    name,
    type
  }) => type + " " + name).join(",")})`;
}
class TypedDataEncoder {
  constructor(types) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    // Link struct types to their direct child structs
    const links = {};
    // Link structs to structs which contain them as a child
    const parents = {};
    // Link all subtypes within a given struct
    const subtypes = {};
    Object.keys(types).forEach(type => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name in types) {
      const uniqueNames = {};
      types[name].forEach(field => {
        // Check each field has a unique name
        if (uniqueNames[field.name]) {
          logger$x.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        // Get the base type (drop any array specifiers)
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name) {
          logger$x.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        // Is this a base encoding type?
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger$x.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        // Add linkage
        parents[baseType].push(name);
        links[name][baseType] = true;
      });
    }
    // Deduce the primary type
    const primaryTypes = Object.keys(parents).filter(n => parents[n].length === 0);
    if (primaryTypes.length === 0) {
      logger$x.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger$x.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(", ")}`, "types", types);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    // Check for circular type references
    function checkCircular(type, found) {
      if (found[type]) {
        logger$x.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach(child => {
        if (!parents[child]) {
          return;
        }
        // Recursively check children
        checkCircular(child, found);
        // Mark all ancestors as having this decendant
        Object.keys(found).forEach(subtype => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    // Compute each fully describe type
    for (const name in subtypes) {
      const st = Object.keys(subtypes[name]);
      st.sort();
      this._types[name] = encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    // Basic encoder type (address, bool, uint256, etc)
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    // Array
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return value => {
        if (length >= 0 && value.length !== length) {
          logger$x.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256$1);
        }
        return keccak256$1(hexConcat(result));
      };
    }
    // Struct
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return value => {
        const values = fields.map(({
          name,
          type
        }) => {
          const result = this.getEncoder(type)(value[name]);
          if (this._types[type]) {
            return keccak256$1(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$x.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name) {
    const result = this._types[name];
    if (!result) {
      logger$x.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name, value) {
    return keccak256$1(this.encodeData(name, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    // Basic encoder type (address, bool, uint256, etc)
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    // Array
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger$x.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map(v => this._visit(subtype, v, callback));
    }
    // Struct
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, {
        name,
        type
      }) => {
        accum[name] = this._visit(type, value[name], callback);
        return accum;
      }, {});
    }
    return logger$x.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      const type = domainFieldTypes[name];
      if (!type) {
        logger$x.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      }
      domainFields.push({
        name,
        type
      });
    }
    domainFields.sort((a, b) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", {
      EIP712Domain: domainFields
    }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
  }
  static hash(domain, types, value) {
    return keccak256$1(TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(domain, types, value, resolveName) {
    return __awaiter$e(this, void 0, void 0, function* () {
      // Make a copy to isolate it from the object passed in
      domain = shallowCopy(domain);
      // Look up all ENS names
      const ensCache = {};
      // Do we need to look up the domain's verifyingContract?
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      // We are going to use the encoder to visit all the base values
      const encoder = TypedDataEncoder.from(types);
      // Get a list of all the addresses
      encoder.visit(value, (type, value) => {
        if (type === "address" && !isHexString(value, 20)) {
          ensCache[value] = "0x";
        }
        return value;
      });
      // Lookup each name
      for (const name in ensCache) {
        ensCache[name] = yield resolveName(name);
      }
      // Replace the domain verifyingContract if needed
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      // Replace all ENS names with their address
      value = encoder.visit(value, (type, value) => {
        if (type === "address" && ensCache[value]) {
          return ensCache[value];
        }
        return value;
      });
      return {
        domain,
        value
      };
    });
  }
  static getPayload(domain, types, value) {
    // Validate the domain fields
    TypedDataEncoder.hashDomain(domain);
    // Derive the EIP712Domain Struct reference type
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach(name => {
      const value = domain[name];
      if (value == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value);
      domainTypes.push({
        name,
        type: domainFieldTypes[name]
      });
    });
    const encoder = TypedDataEncoder.from(types);
    const typesWithDomain = shallowCopy(types);
    if (typesWithDomain.EIP712Domain) {
      logger$x.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    // Validate the data structures and types
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value) => {
        // bytes
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value));
        }
        // uint or int
        if (type.match(/^u?int/)) {
          return BigNumber.from(value).toString();
        }
        switch (type) {
          case "address":
            return value.toLowerCase();
          case "bool":
            return !!value;
          case "string":
            if (typeof value !== "string") {
              logger$x.throwArgumentError(`invalid string`, "value", value);
            }
            return value;
        }
        return logger$x.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}

var lib_esm$d = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _TypedDataEncoder: TypedDataEncoder,
    dnsEncode: dnsEncode,
    ensNormalize: ensNormalize,
    hashMessage: hashMessage,
    id: id,
    isValidName: isValidName,
    messagePrefix: messagePrefix,
    namehash: namehash
});

const logger$w = new Logger(version$m);
class LogDescription extends Description {}
class TransactionDescription extends Description {}
class ErrorDescription extends Description {}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: true
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"]
  }
};
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly(this, "fragments", abi.map(fragment => {
      return Fragment.from(fragment);
    }).filter(fragment => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    // Add all fragments by their signature
    this.fragments.forEach(fragment => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$w.warn("duplicate definition - constructor");
            return;
          }
          //checkNames(fragment, "input", fragment.inputs);
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          //checkNames(fragment, "input", fragment.inputs);
          //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
          bucket = this.functions;
          break;
        case "event":
          //checkNames(fragment, "input", fragment.inputs);
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature = fragment.format();
      if (bucket[signature]) {
        logger$w.warn("duplicate definition - " + signature);
        return;
      }
      bucket[signature] = fragment;
    });
    // If we do not have a constructor add a default
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger$w.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi = this.fragments.map(fragment => fragment.format(format));
    // We need to re-bundle the JSON fragments a bit
    if (format === FormatTypes.json) {
      return JSON.stringify(abi.map(j => JSON.parse(j)));
    }
    return abi;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name)) {
          return this.functions[name];
        }
      }
      logger$w.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    // It is a bare name, look up the function (will return null if ambiguous)
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter(f => f.split("(" /* fix:) */)[0] === name);
      if (matching.length === 0) {
        logger$w.throwArgumentError("no matching function", "name", name);
      } else if (matching.length > 1) {
        logger$w.throwArgumentError("multiple matching functions", "name", name);
      }
      return this.functions[matching[0]];
    }
    // Normalize the signature and lookup the function
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$w.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name in this.events) {
        if (topichash === this.getEventTopic(name)) {
          return this.events[name];
        }
      }
      logger$w.throwArgumentError("no matching event", "topichash", topichash);
    }
    // It is a bare name, look up the function (will return null if ambiguous)
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter(f => f.split("(" /* fix:) */)[0] === name);
      if (matching.length === 0) {
        logger$w.throwArgumentError("no matching event", "name", name);
      } else if (matching.length > 1) {
        logger$w.throwArgumentError("multiple matching events", "name", name);
      }
      return this.events[matching[0]];
    }
    // Normalize the signature and lookup the function
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$w.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name in this.errors) {
        const error = this.errors[name];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name];
        }
      }
      logger$w.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    // It is a bare name, look up the function (will return null if ambiguous)
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter(f => f.split("(" /* fix:) */)[0] === name);
      if (matching.length === 0) {
        logger$w.throwArgumentError("no matching error", "name", name);
      } else if (matching.length > 1) {
        logger$w.throwArgumentError("multiple matching errors", "name", name);
      }
      return this.errors[matching[0]];
    }
    // Normalize the signature and lookup the function
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$w.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes = arrayify(data);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$w.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat([this.getSighash(fragment), this._encodeParams(fragment.inputs, values || [])]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes = arrayify(data);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$w.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat([this.getSighash(functionFragment), this._encodeParams(functionFragment.inputs, values || [])]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes = arrayify(data);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {}
        break;
      case 4:
        {
          const selector = hexlify(bytes.slice(0, 4));
          const builtin = BuiltinErrors[selector];
          if (builtin) {
            errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
            errorName = builtin.name;
            errorSignature = builtin.signature;
            if (builtin.reason) {
              reason = errorArgs[0];
            }
            if (errorName === "Error") {
              message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
            } else if (errorName === "Panic") {
              message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
            }
          } else {
            try {
              const error = this.getError(selector);
              errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
              errorName = error.name;
              errorSignature = error.format();
            } catch (error) {}
          }
          break;
        }
    }
    return logger$w.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$w.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256$1(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      // Check addresses are valid
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      let param = eventFragment.inputs[index];
      if (!param.indexed) {
        if (value != null) {
          logger$w.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$w.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map(value => encodeTopic(param, value)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    // Trim off trailing nulls
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$w.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256$1(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          // @TODO
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics: topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$w.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: topicHash,
          value: topics[0]
        });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({
            type: "bytes32",
            name: param.name
          }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0,
      indexedIndex = 0;
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed({
            _isIndexed: true,
            hash: null
          });
        } else if (dynamic[index]) {
          result[index] = new Indexed({
            _isIndexed: true,
            hash: resultIndexed[indexedIndex++]
          });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      }
      // Add the keyword argument if named and safe
      if (param.name && result[param.name] == null) {
        const value = result[index];
        // Make error named values throw on access
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    // Make all error indexed values throw on access
    for (let i = 0; i < result.length; i++) {
      const value = result[i];
      if (value instanceof Error) {
        Object.defineProperty(result, i, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
    //        Probably not, because just because it is the only event in the ABI does
    //        not mean we have the full ABI; maybe just a fragment?
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}

var lib_esm$c = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AbiCoder: AbiCoder,
    ConstructorFragment: ConstructorFragment,
    ErrorFragment: ErrorFragment,
    EventFragment: EventFragment,
    FormatTypes: FormatTypes,
    Fragment: Fragment,
    FunctionFragment: FunctionFragment,
    Indexed: Indexed,
    Interface: Interface,
    LogDescription: LogDescription,
    ParamType: ParamType,
    TransactionDescription: TransactionDescription,
    checkResultErrors: checkResultErrors,
    defaultAbiCoder: defaultAbiCoder
});

const version$g = "abstract-provider/5.7.0";

var __awaiter$d = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$v = new Logger(version$g);
//export type CallTransactionable = {
//    call(transaction: TransactionRequest): Promise<TransactionResponse>;
//};
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
///////////////////////////////
// Exported Abstracts
class Provider {
  constructor() {
    logger$v.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$d(this, void 0, void 0, function* () {
      const {
        block,
        gasPrice
      } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch(error => {
          // @TODO: Why is this now failing on Calaveras?
          //console.log(error);
          return null;
        })
      });
      let lastBaseFeePerGas = null,
        maxFeePerGas = null,
        maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        // We may want to compute this more accurately in the future,
        // using the formula "check if the base fee is correct".
        // See: https://eips.ethereum.org/EIPS/eip-1559
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return {
        lastBaseFeePerGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        gasPrice
      };
    });
  }
  // Alias for "on"
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  // Alias for "off"
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}

const version$f = "abstract-signer/5.7.0";

var __awaiter$c = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$u = new Logger(version$f);
const allowedTransactionKeys$3 = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"];
const forwardErrors = [Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED];
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$u.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(transaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(transaction, blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(transaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(transaction) {
    for (const key in transaction) {
      if (allowedTransactionKeys$3.indexOf(key) === -1) {
        logger$u.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      // Make sure any provided address matches this signer
      tx.from = Promise.all([Promise.resolve(tx.from), this.getAddress()]).then(result => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$u.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(transaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then(to => __awaiter$c(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$u.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        // Prevent this error from causing an UnhandledPromiseException
        tx.to.catch(error => {});
      }
      // Do not allow mixing pre-eip-1559 and eip-1559 properties
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$u.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$u.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null) {
        // Fully-formed EIP-1559 transaction (skip getFeeData)
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        // Explicit Legacy or EIP-2930 transaction
        // Populate missing gasPrice
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        // We need to get fee data to determine things
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          // We need to auto-detect the intended type of this transaction...
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            // The network supports EIP-1559!
            // Upgrade transaction from null to eip-1559
            tx.type = 2;
            if (tx.gasPrice != null) {
              // Using legacy gasPrice property on an eip-1559 network,
              // so use gasPrice as both fee properties
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              // Populate missing fee data
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            // Network doesn't support EIP-1559...
            // ...but they are trying to use EIP-1559 properties
            if (hasEip1559) {
              logger$u.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            // Populate missing fee data
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            // Explicitly set untyped transaction to legacy
            tx.type = 0;
          } else {
            // getFeeData has failed us.
            logger$u.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          // Explicitly using EIP-1559
          // Populate missing fee data
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch(error => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$u.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error: error,
            tx: tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([Promise.resolve(tx.chainId), this.getChainId()]).then(results => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger$u.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(operation) {
    if (!this.provider) {
      logger$u.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(address, provider) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger$u.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation
      });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
}

var hash = {};

var utils$b = {};

var minimalisticAssert$1 = assert$b;
function assert$b(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}
assert$b.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};

var inheritsExports = {};
var inherits$3 = {
  get exports(){ return inheritsExports; },
  set exports(v){ inheritsExports = v; },
};

var inherits$1;
if (typeof Object.create === 'function') {
  inherits$1 = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits$1 = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$2 = inherits$1;

var formatRegExp = /%[sdj%]/g;
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
}

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
function deprecate(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global$1.process)) {
    return function () {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process$1.throwDeprecation) {
        throw new Error(msg);
      } else if (process$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron)) debugEnviron = process$1.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function () {
        var msg = format.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
}

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = '',
    array = false,
    braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp$1(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }
  return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function (prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === 'number';
}
function isString(arg) {
  return typeof arg === 'string';
}
function isSymbol(arg) {
  return typeof arg === 'symbol';
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp$1(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === 'function';
}
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
function isBuffer(maybeBuf) {
  return Buffer.isBuffer(maybeBuf);
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
function log() {
  console.log('%s - %s', timestamp(), format.apply(null, arguments));
}
function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var util = {
  inherits: inherits$2,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive,
  isFunction: isFunction,
  isError: isError,
  isDate: isDate,
  isObject: isObject,
  isRegExp: isRegExp$1,
  isUndefined: isUndefined,
  isSymbol: isSymbol,
  isString: isString,
  isNumber: isNumber,
  isNullOrUndefined: isNullOrUndefined,
  isNull: isNull,
  isBoolean: isBoolean,
  isArray: isArray,
  inspect: inspect,
  deprecate: deprecate,
  format: format,
  debuglog: debuglog
};

var util$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _extend: _extend,
    debuglog: debuglog,
    default: util,
    deprecate: deprecate,
    format: format,
    inherits: inherits$2,
    inspect: inspect,
    isArray: isArray,
    isBoolean: isBoolean,
    isBuffer: isBuffer,
    isDate: isDate,
    isError: isError,
    isFunction: isFunction,
    isNull: isNull,
    isNullOrUndefined: isNullOrUndefined,
    isNumber: isNumber,
    isObject: isObject,
    isPrimitive: isPrimitive,
    isRegExp: isRegExp$1,
    isString: isString,
    isSymbol: isSymbol,
    isUndefined: isUndefined,
    log: log
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(util$1);

var inherits_browserExports = {};
var inherits_browser$1 = {
  get exports(){ return inherits_browserExports; },
  set exports(v){ inherits_browserExports = v; },
};

var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browserExports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    inherits_browser$1.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    inherits_browser$1.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browserExports;
}

(function (module) {
  try {
    var util = require$$0$2;
    /* istanbul ignore next */
    if (typeof util.inherits !== 'function') throw '';
    module.exports = util.inherits;
  } catch (e) {
    /* istanbul ignore next */
    module.exports = requireInherits_browser();
  }
})(inherits$3);

var assert$a = minimalisticAssert$1;
var inherits = inheritsExports;
utils$b.inherits = inherits;
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = c >> 6 | 192;
          res[p++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = c >> 18 | 240;
          res[p++] = c >> 12 & 63 | 128;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        } else {
          res[p++] = c >> 12 | 224;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
  }
  return res;
}
utils$b.toArray = toArray;
function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
  return res;
}
utils$b.toHex = toHex;
function htonl(w) {
  var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
  return res >>> 0;
}
utils$b.htonl = htonl;
function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little') w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils$b.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}
utils$b.zero2 = zero2;
function zero8(word) {
  if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
}
utils$b.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$a(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils$b.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = m >>> 16 & 0xff;
      res[k + 2] = m >>> 8 & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = m >>> 16 & 0xff;
      res[k + 1] = m >>> 8 & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils$b.split32 = split32;
function rotr32$1(w, b) {
  return w >>> b | w << 32 - b;
}
utils$b.rotr32 = rotr32$1;
function rotl32$2(w, b) {
  return w << b | w >>> 32 - b;
}
utils$b.rotl32 = rotl32$2;
function sum32$3(a, b) {
  return a + b >>> 0;
}
utils$b.sum32 = sum32$3;
function sum32_3$1(a, b, c) {
  return a + b + c >>> 0;
}
utils$b.sum32_3 = sum32_3$1;
function sum32_4$2(a, b, c, d) {
  return a + b + c + d >>> 0;
}
utils$b.sum32_4 = sum32_4$2;
function sum32_5$2(a, b, c, d, e) {
  return a + b + c + d + e >>> 0;
}
utils$b.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$b.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$b.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$b.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$b.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$b.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$b.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$b.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r = al << 32 - num | ah >>> num;
  return r >>> 0;
}
utils$b.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}
utils$b.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$b.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}
utils$b.shr64_lo = shr64_lo$1;

var common$5 = {};

var utils$a = utils$b;
var assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils$a.toArray(msg, enc);
  if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0) this.pending = null;
    msg = utils$a.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++) res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++) res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t = 8; t < this.padLength; t++) res[i++] = 0;
  }
  return res;
};

var sha = {};

var common$4 = {};

var utils$9 = utils$b;
var rotr32 = utils$9.rotr32;
function ft_1$1(s, x, y, z) {
  if (s === 0) return ch32$1(x, y, z);
  if (s === 1 || s === 3) return p32(x, y, z);
  if (s === 2) return maj32$1(x, y, z);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x, y, z) {
  return x & y ^ ~x & z;
}
common$4.ch32 = ch32$1;
function maj32$1(x, y, z) {
  return x & y ^ x & z ^ y & z;
}
common$4.maj32 = maj32$1;
function p32(x, y, z) {
  return x ^ y ^ z;
}
common$4.p32 = p32;
function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
common$4.g1_256 = g1_256$1;

var utils$8 = utils$b;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$8.rotl32;
var sum32$2 = utils$8.sum32;
var sum32_5$1 = utils$8.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
function SHA1() {
  if (!(this instanceof SHA1)) return new SHA1();
  BlockHash$3.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.W = new Array(80);
}
utils$8.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;
  for (var i = 0; i < 16; i++) W[i] = msg[start + i];
  for (; i < W.length; i++) W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32$1(b, 30);
    b = a;
    a = t;
  }
  this.h[0] = sum32$2(this.h[0], a);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c);
  this.h[3] = sum32$2(this.h[3], d);
  this.h[4] = sum32$2(this.h[4], e);
};
SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils$8.toHex32(this.h, 'big');else return utils$8.split32(this.h, 'big');
};

var utils$7 = utils$b;
var common$2 = common$5;
var shaCommon = common$4;
var assert$8 = minimalisticAssert$1;
var sum32$1 = utils$7.sum32;
var sum32_4$1 = utils$7.sum32_4;
var sum32_5 = utils$7.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
function SHA256$1() {
  if (!(this instanceof SHA256$1)) return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$7.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update(msg, start) {
  var W = this.W;
  for (var i = 0; i < 16; i++) W[i] = msg[start + i];
  for (; i < W.length; i++) W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  assert$8(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32$1(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32$1(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d);
  this.h[4] = sum32$1(this.h[4], e);
  this.h[5] = sum32$1(this.h[5], f);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h);
};
SHA256$1.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils$7.toHex32(this.h, 'big');else return utils$7.split32(this.h, 'big');
};

var utils$6 = utils$b;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224)) return new SHA224();
  SHA256.call(this);
  this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
}
utils$6.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex') return utils$6.toHex32(this.h.slice(0, 7), 'big');else return utils$6.split32(this.h.slice(0, 7), 'big');
};

var utils$5 = utils$b;
var common$1 = common$5;
var assert$7 = minimalisticAssert$1;
var rotr64_hi = utils$5.rotr64_hi;
var rotr64_lo = utils$5.rotr64_lo;
var shr64_hi = utils$5.shr64_hi;
var shr64_lo = utils$5.shr64_lo;
var sum64 = utils$5.sum64;
var sum64_hi = utils$5.sum64_hi;
var sum64_lo = utils$5.sum64_lo;
var sum64_4_hi = utils$5.sum64_4_hi;
var sum64_4_lo = utils$5.sum64_4_lo;
var sum64_5_hi = utils$5.sum64_5_hi;
var sum64_5_lo = utils$5.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
function SHA512$1() {
  if (!(this instanceof SHA512$1)) return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$5.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++) W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14]; // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32]; // i - 16
    var c3_lo = W[i - 31];
    W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};
SHA512$1.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);
  var W = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert$7(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};
SHA512$1.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils$5.toHex32(this.h, 'big');else return utils$5.split32(this.h, 'big');
};
function ch64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ ~xh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ ~xl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}
function maj64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ xh & zh ^ yh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ xl & zl ^ yl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2); // 34
  var c2_hi = rotr64_hi(xl, xh, 7); // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2); // 34
  var c2_lo = rotr64_lo(xl, xh, 7); // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9); // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9); // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29); // 61
  var c2_hi = shr64_hi(xh, xl, 6);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29); // 61
  var c2_lo = shr64_lo(xh, xl, 6);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

var utils$4 = utils$b;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384)) return new SHA384();
  SHA512.call(this);
  this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
}
utils$4.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils$4.toHex32(this.h.slice(0, 12), 'big');else return utils$4.split32(this.h.slice(0, 12), 'big');
};

sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;

var ripemd = {};

var utils$3 = utils$b;
var common = common$5;
var rotl32 = utils$3.rotl32;
var sum32 = utils$3.sum32;
var sum32_3 = utils$3.sum32_3;
var sum32_4 = utils$3.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160)) return new RIPEMD160();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.endian = 'little';
}
utils$3.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(rotl32(sum32_4(A, f$1(j, B, C, D), msg[r[j] + start], K$1(j)), s$1[j]), E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(rotl32(sum32_4(Ah, f$1(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils$3.toHex32(this.h, 'little');else return utils$3.split32(this.h, 'little');
};
function f$1(j, x, y, z) {
  if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);
}
function K$1(j) {
  if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;
}
function Kh(j) {
  if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;
}
var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var s$1 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

var utils$2 = utils$b;
var assert$6 = minimalisticAssert$1;
function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$2.toArray(key, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
  assert$6(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++) key.push(0);
  for (i = 0; i < key.length; i++) key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++) key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

(function (exports) {
  var hash = exports;
  hash.utils = utils$b;
  hash.common = common$5;
  hash.sha = sha;
  hash.ripemd = ripemd;
  hash.hmac = hmac;

  // Proxy hash functions to the main object
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
})(hash);

function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function (path, base) {
      return commonjsRequire(path, base === undefined || base === null ? module.path : base);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}
assert.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};
var utils_1 = createCommonjsModule(function (module, exports) {

  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg !== 'string') {
      for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
      return res;
    }
    if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi) res.push(hi, lo);else res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1) return '0' + word;else return word;
  }
  utils.zero2 = zero2;
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  utils.encode = function encode(arr, enc) {
    if (enc === 'hex') return toHex(arr);else return arr;
  };
});
var utils_1$1 = createCommonjsModule(function (module, exports) {

  var utils = exports;
  utils.assert = minimalisticAssert;
  utils.toArray = utils_1.toArray;
  utils.zero2 = utils_1.zero2;
  utils.toHex = utils_1.toHex;
  utils.encode = utils_1.encode;

  // Represent num in a w-NAF form
  function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF;

  // Represent k1, k2 in a Joint Sparse Form
  function getJSF(k1, k2) {
    var jsf = [[], []];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      // First phase
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3) m14 = -1;
      if (m24 === 3) m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
      }
      jsf[1].push(u2);

      // Second phase
      if (2 * d1 === u1 + 1) d1 = 1 - d1;
      if (2 * d2 === u2 + 1) d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF;
  function cachedProperty(obj, name, computer) {
    var key = '_' + name;
    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new BN$1(bytes, 'hex', 'le');
  }
  utils.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$1(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN$1.red(conf.prime) : BN$1.mont(this.p);

  // Useful for many curves
  this.zero = new BN$1(0).toRed(this.red);
  this.one = new BN$1(1).toRed(this.red);
  this.two = new BN$1(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN$1(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};
BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$1(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--) nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i) b = b.mixedAdd(doubles.points[j]);else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--) l++;
    if (i >= 0) l++;
    acc = acc.dblp(l);
    if (i < 0) break;
    var z = naf[i];
    assert$1(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      // J +- J
      if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [points[a], /* 1 */
    null, /* 3 */
    null, /* 5 */
    points[b] /* 7 */];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index = [-3, /* -1 -1 */
    -1, /* -1 0 */
    -5, /* -1 1 */
    -7, /* 0 -1 */
    0, /* 0 0 */
    7, /* 0 1 */
    5, /* 1 -1 */
    1, /* 1 0 */
    3 /* 1 1 */];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0) zero = false;
      }
      if (!zero) break;
      k++;
      i--;
    }
    if (i >= 0) k++;
    acc = acc.dblp(k);
    if (i < 0) break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0) continue;else if (z > 0) p = wnd[j][z - 1 >> 1];else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === 'affine') acc = acc.mixedAdd(p);else acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++) wnd[i] = null;
  if (jacobianResult) return acc;else return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq( /*other*/
) {
  throw new Error('Not implemented');
};
BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06) assert$1(bytes[bytes.length - 1] % 2 === 0);else if (bytes[0] === 0x07) assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);
  if (compact) return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
  return [0x04].concat(x, this.getY().toArray('be', len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed) return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed) return false;
  var doubles = this.precomputed.doubles;
  if (!doubles) return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++) acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++) r = r.dbl();
  return r;
};
var inherits_browser = createCommonjsModule(function (module) {
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, 'short', conf);
  this.a = new BN$1(conf.a, 16).toRed(this.red);
  this.b = new BN$1(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$1(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$1(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function (vec) {
      return {
        a: new BN$1(vec.a, 16),
        b: new BN$1(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN$1.mont(num);
  var tinv = new BN$1(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new BN$1(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN$1(1);
  var y1 = new BN$1(0);
  var x2 = new BN$1(0);
  var y2 = new BN$1(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [{
    a: a1,
    b: b1
  }, {
    a: a2,
    b: b2
  }];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return {
    k1: k1,
    k2: k2
  };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$1(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};
ShortCurve.prototype.validate = function validate(point) {
  if (point.inf) return true;
  var x = point.x;
  var y = point.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point(curve, x, y, isRed) {
  base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$1(x, 16);
    this.y = new BN$1(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo) return;
  var pre = this.precomputed;
  if (pre && pre.beta) return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function (p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed) return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string') obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2]) return res;
  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf) return p;

  // P + O = P
  if (p.inf) return this;

  // P + P = 2P
  if (this.eq(p)) return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p)) return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf) return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k) {
  k = new BN$1(k, 16);
  if (this.isInfinity()) return this;else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [k]);else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf) return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function (p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x, y, z) {
  base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$1(0);
  } else {
    this.x = new BN$1(x, 16);
    this.y = new BN$1(y, 16);
    this.z = new BN$1(z, 16);
  }
  if (!this.x.red) this.x = this.x.toRed(this.curve.red);
  if (!this.y.red) this.y = this.y.toRed(this.curve.red);
  if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity()) return p;

  // P + O = P
  if (p.isInfinity()) return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity()) return p.toJ();

  // P + O = P
  if (p.isInfinity()) return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0) return this;
  if (this.isInfinity()) return this;
  if (!pow) return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++) r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this;
  if (this.curve.zeroA) return this._zeroDbl();else if (this.curve.threeA) return this._threeDbl();else return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA) return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN$1(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine') return this.eq(p.toJ());
  if (this === p) return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
};
JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};
JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function (module, exports) {

  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = /*RicMoo:ethers:require(./mont)*/null;
  curve.edwards = /*RicMoo:ethers:require(./edwards)*/null;
});
var curves_1 = createCommonjsModule(function (module, exports) {

  var curves = exports;
  var assert = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === 'short') this.curve = new curve_1.short(options);else if (options.type === 'edwards') this.curve = new curve_1.edwards(options);else this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), 'Invalid curve');
    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function () {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve('p192', {
    type: 'short',
    prime: 'p192',
    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    hash: hash.sha256,
    gRed: false,
    g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
  });
  defineCurve('p224', {
    type: 'short',
    prime: 'p224',
    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    hash: hash.sha256,
    gRed: false,
    g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
  });
  defineCurve('p256', {
    type: 'short',
    prime: null,
    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    hash: hash.sha256,
    gRed: false,
    g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
  });
  defineCurve('p384', {
    type: 'short',
    prime: null,
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
    a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
    b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
    n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
    hash: hash.sha384,
    gRed: false,
    g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
  });
  defineCurve('p521', {
    type: 'short',
    prime: null,
    p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
    a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
    b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
    n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
    hash: hash.sha512,
    gRed: false,
    g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
  });
  defineCurve('curve25519', {
    type: 'mont',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '76d06',
    b: '1',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: ['9']
  });
  defineCurve('ed25519', {
    type: 'edwards',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '-1',
    c: '1',
    // -121665 * (121666^(-1)) (mod P)
    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658']
  });
  var pre;
  try {
    pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/null.crash();
  } catch (e) {
    pre = undefined;
  }
  defineCurve('secp256k1', {
    type: 'short',
    prime: 'k256',
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    a: '0',
    b: '7',
    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    h: '1',
    hash: hash.sha256,
    // Precomputed endomorphism
    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    basis: [{
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    }, {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }],
    gRed: false,
    g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');
  minimalisticAssert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000; // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0x00]);
  if (seed) kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed) return;
  this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add = utils_1.toArray(add, addEnc);
  minimalisticAssert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._update(entropy.concat(add || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils_1.toArray(add, addEnc || 'hex');
    this._update(add);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv) this._importPrivate(options.priv, options.privEnc);
  if (options.pub) this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair) return priv;
  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();
  if (pub.isInfinity()) return {
    result: false,
    reason: 'Invalid public key'
  };
  if (!pub.validate()) return {
    result: false,
    reason: 'Public key is not a point'
  };
  if (!pub.mul(this.ec.curve.n).isInfinity()) return {
    result: false,
    reason: 'Public key * N != O'
  };
  return {
    result: true,
    reason: null
  };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }
  if (!this.pub) this.pub = this.ec.g.mul(this.priv);
  if (!enc) return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN$1(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert$3(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
      assert$3(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};
KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature) return options;
  if (this._importDER(options, enc)) return;
  assert$4(options.r && options.s, 'Signature without r or s');
  this.r = new BN$1(options.r, 16);
  this.s = new BN$1(options.s, 16);
  if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  this.r = new BN$1(r);
  this.s = new BN$1(s);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 0xff);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80) r = [0].concat(r);
  // Pad values
  if (s[0] & 0x80) s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);
  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [0x02];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [0x30];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = /*RicMoo:ethers:require(brorand)*/function () {
  throw new Error('unsupported');
};
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC)) return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), 'Unknown curve ' + options);
    options = curves_1[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves_1.PresetCurve) options = {
    curve: options
  };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options) options = {};

  // Instantiate Hmac_DRBG
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$1(2));
  for (;;) {
    var priv = new BN$1(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0) continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0) msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;
};
EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options) options = {};
  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN$1(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN$1(1));
  for (var iter = 0;; iter++) {
    var k = options.k ? options.k(iter) : new BN$1(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity()) continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0) continue;
    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0) continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new signature({
      r: r,
      s: s,
      recoveryParam: recoveryParam
    });
  }
};
EC.prototype.verify = function verify(msg, signature$1, key, enc) {
  msg = this._truncateToN(new BN$1(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature$1 = new signature(signature$1, 'hex');

  // Perform primitive values validation
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity()) return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};
EC.prototype.recoverPubKey = function (msg, signature$1, j, enc) {
  assert$5((3 & j) === j, 'The recovery param is more than two bits');
  signature$1 = new signature(signature$1, enc);
  var n = this.n;
  var e = new BN$1(msg);
  var r = signature$1.r;
  var s = signature$1.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function (e, signature$1, Q, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null) return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e) {
      continue;
    }
    if (Qprime.eq(Q)) return i;
  }
  throw new Error('Unable to find valid recovery factor');
};
var elliptic_1 = createCommonjsModule(function (module, exports) {

  var elliptic = exports;
  elliptic.version = /*RicMoo:ethers*/{
    version: "6.5.4"
  }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = /*RicMoo:ethers:require(brorand)*/function () {
    throw new Error('unsupported');
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;

  // Protocols
  elliptic.ec = ec;
  elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/null;
});
var EC$1 = elliptic_1.ec;

const version$e = "signing-key/5.7.0";

const logger$t = new Logger(version$e);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$t.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest);
    if (digestBytes.length !== 32) {
      logger$t.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature = keyPair.sign(digestBytes, {
      canonical: true
    });
    return splitSignature({
      recoveryParam: signature.recoveryParam,
      r: hexZeroPad("0x" + signature.r.toString(16), 32),
      s: hexZeroPad("0x" + signature.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest, signature) {
  const sig = splitSignature(signature);
  const rs = {
    r: arrayify(sig.r),
    s: arrayify(sig.s)
  };
  return "0x" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key, compressed) {
  const bytes = arrayify(key);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger$t.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

var lib_esm$b = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SigningKey: SigningKey,
    computePublicKey: computePublicKey,
    recoverPublicKey: recoverPublicKey
});

const version$d = "transactions/5.7.0";

const logger$s = new Logger(version$d);
var TransactionTypes;
(function (TransactionTypes) {
  TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
  TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
  TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
///////////////////////////////
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
// Legacy Transaction Fields
const transactionFields = [{
  name: "nonce",
  maxLength: 32,
  numeric: true
}, {
  name: "gasPrice",
  maxLength: 32,
  numeric: true
}, {
  name: "gasLimit",
  maxLength: 32,
  numeric: true
}, {
  name: "to",
  length: 20
}, {
  name: "value",
  maxLength: 32,
  numeric: true
}, {
  name: "data"
}];
const allowedTransactionKeys$2 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key) {
  const publicKey = computePublicKey(key);
  return getAddress(hexDataSlice(keccak256$1(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest, signature) {
  return computeAddress(recoverPublicKey(arrayify(digest), signature));
}
function formatNumber(value, name) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$s.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$s.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger$s.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map(addr => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b) => a.address.localeCompare(b.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map(set => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature) {
  // If there is an explicit gasPrice, make sure it matches the
  // EIP-1559 fees; otherwise they may not understand what they
  // think they are setting in terms of fee.
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$s.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [formatNumber(transaction.chainId || 0, "chainId"), formatNumber(transaction.nonce || 0, "nonce"), formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(transaction.gasLimit || 0, "gasLimit"), transaction.to != null ? getAddress(transaction.to) : "0x", formatNumber(transaction.value || 0, "value"), transaction.data || "0x", formatAccessList(transaction.accessList || [])];
  if (signature) {
    const sig = splitSignature(signature);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$2(fields)]);
}
function _serializeEip2930(transaction, signature) {
  const fields = [formatNumber(transaction.chainId || 0, "chainId"), formatNumber(transaction.nonce || 0, "nonce"), formatNumber(transaction.gasPrice || 0, "gasPrice"), formatNumber(transaction.gasLimit || 0, "gasLimit"), transaction.to != null ? getAddress(transaction.to) : "0x", formatNumber(transaction.value || 0, "value"), transaction.data || "0x", formatAccessList(transaction.accessList || [])];
  if (signature) {
    const sig = splitSignature(signature);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$2(fields)]);
}
// Legacy Transactions and EIP-155
function _serialize(transaction, signature) {
  checkProperties(transaction, allowedTransactionKeys$2);
  const raw = [];
  transactionFields.forEach(function (fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    // Fixed-width field
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger$s.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    // Variable-width (with a maximum)
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger$s.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    // A chainId was provided; if non-zero we'll use EIP-155
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger$s.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature && !isBytesLike(signature) && signature.v > 28) {
    // No chainId provided, but the signature is signing with EIP-155; derive chainId
    chainId = Math.floor((signature.v - 35) / 2);
  }
  // We have an EIP-155 transaction (chainId was specified and non-zero)
  if (chainId !== 0) {
    raw.push(hexlify(chainId)); // @TODO: hexValue?
    raw.push("0x");
    raw.push("0x");
  }
  // Requesting an unsigned transaction
  if (!signature) {
    return encode$2(raw);
  }
  // The splitSignature will ensure the transaction has a recoveryParam in the
  // case that the signTransaction function only adds a v.
  const sig = splitSignature(signature);
  // We pushed a chainId and null r, s on for hashing only; remove those
  let v = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v += chainId * 2 + 8;
    // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!
    if (sig.v > 28 && sig.v !== v) {
      logger$s.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    }
  } else if (sig.v !== v) {
    logger$s.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
  }
  raw.push(hexlify(v));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode$2(raw);
}
function serialize$1(transaction, signature) {
  // Legacy and EIP-155 Transactions
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger$s.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature);
  }
  // Typed Transactions (EIP-2718)
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature);
    case 2:
      return _serializeEip1559(transaction, signature);
  }
  return logger$s.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$s.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest = keccak256$1(serialize(tx));
    tx.from = recoverAddress(digest, {
      r: tx.r,
      s: tx.s,
      recoveryParam: tx.v
    });
  } catch (error) {}
}
function _parseEip1559(payload) {
  const transaction = decode$2(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$s.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas: maxPriorityFeePerGas,
    maxFeePerGas: maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  // Unsigned EIP-1559 Transaction
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$2(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$s.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  // Unsigned EIP-2930 Transaction
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
// Legacy Transactions and EIP-155
function _parse(rawTransaction) {
  const transaction = decode$2(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$s.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  // Legacy unsigned transaction
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    // @TODO: What makes snese to do? The v is too big
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    // EIP-155 unsigned transaction
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    // Signed Transaction
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak256$1(encode$2(raw));
    try {
      tx.from = recoverAddress(digest, {
        r: hexlify(tx.r),
        s: hexlify(tx.s),
        recoveryParam: recoveryParam
      });
    } catch (error) {}
    tx.hash = keccak256$1(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  // Legacy and EIP-155 Transactions
  if (payload[0] > 0x7f) {
    return _parse(payload);
  }
  // Typed Transaction (EIP-2718)
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$s.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}

var lib_esm$a = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get TransactionTypes () { return TransactionTypes; },
    accessListify: accessListify,
    computeAddress: computeAddress,
    parse: parse,
    recoverAddress: recoverAddress,
    serialize: serialize$1
});

const version$c = "contracts/5.7.0";

var __awaiter$b = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$r = new Logger(version$c);
///////////////////////////////
const allowedTransactionKeys$1 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter$b(this, void 0, void 0, function* () {
    const name = yield nameOrPromise;
    if (typeof name !== "string") {
      logger$r.throwArgumentError("invalid address or ENS name", "name", name);
    }
    // If it is already an address, just use it (after adding checksum)
    try {
      return getAddress(name);
    } catch (error) {}
    if (!resolver) {
      logger$r.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name);
    if (address == null) {
      logger$r.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }
    return address;
  });
}
// Recursively replaces ENS names with promises to resolve the name and resolves all properties
function resolveAddresses(resolver, value, paramType) {
  return __awaiter$b(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType.name], paramType);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger$r.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map(v => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter$b(this, void 0, void 0, function* () {
    // If an extra argument is given, it is overrides
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    // Make sure the parameter count matches
    logger$r.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    // Populate "from" override (allow promises)
    if (contract.signer) {
      if (overrides.from) {
        // Contracts with a Signer are from the Signer's frame-of-reference;
        // but we allow overriding "from" if it matches the signer
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then(check => __awaiter$b(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger$r.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
      //} else {
      // Contracts without a signer can override "from", and if
      // unspecified the zero address is used
      //overrides.from = AddressZero;
    }
    // Wait for all dependencies to be resolved (prefer the signer over the provider)
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    // The ABI coded transaction
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data,
      to: resolved.address
    };
    // Resolved Overrides
    const ro = resolved.overrides;
    // Populate simple overrides
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    // If there was no "gasLimit" override, but the ABI specifies a default, use it
    if (tx.gasLimit == null && fragment.gas != null) {
      // Compute the intrinsic gas cost for this transaction
      // @TODO: This is based on the yellow paper as of Petersburg; this is something
      // we may wish to parameterize in v6 as part of the Network object. Since this
      // is always a non-nil to address, we can ignore G_create, but may wish to add
      // similar logic to the ContractFactory.
      let intrinsic = 21000;
      const bytes = arrayify(data);
      for (let i = 0; i < bytes.length; i++) {
        intrinsic += 4;
        if (bytes[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    // Populate "value" override
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger$r.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    // Remove the overrides
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    // Make sure there are no stray overrides, which may indicate a
    // typo or using an unsupported key.
    const leftovers = Object.keys(overrides).filter(key => overrides[key] != null);
    if (leftovers.length) {
      logger$r.throwError(`cannot override ${leftovers.map(l => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function (...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function (...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger$r.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = confirmations => {
    return wait(confirmations).then(receipt => {
      receipt.events = receipt.logs.map(log => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {}
        // Successfully parsed the event log; include it
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        // Useful operations
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function (...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      // Extract the "blockTag" override if present
      let blockTag = undefined;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      // If the contract was just deployed, wait until it is mined
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      // Call a node and get the result
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function (...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger$r.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      // If the contract was just deployed, wait until it is mined
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      // Tweak the tx.wait so the receipt has extra properties
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag$1(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map(topic => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
class RunningEvent {
  constructor(tag, filter) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({
      listener: listener,
      once: once
    });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter(item => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map(i => i.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter(item => {
      const argsCopy = args.slice();
      // Call the callback in the next event loop
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      // Reschedule it if it not "once"
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {}
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
// @TODO Fragment should inherit Wildcard? and just override getEmit?
//       or have a common abstract super class, with enough constructor
//       options to configure both.
// A Fragment Event will populate all the properties that Wildcard
// will, and additionally dereference the arguments when emitting
class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter = {
      address: address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger$r.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter.topics = topics.slice();
    } else {
      filter.topics = [topic];
    }
    super(getEventTag$1(filter), filter);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}
// A Wildcard Event will attempt to populate:
//  - event            The name of the event name
//  - eventSignature   The full signature of the event
//  - decode           A function to decode data and topics
//  - args             The decoded data and topics
class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", {
      address: address
    });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
      // No matching event
    }
  }
}
class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    // @TODO: Maybe still check the addressOrName looks like a valid address or name?
    //address = getAddress(address);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger$r.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach(eventSignature => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach(name => {
        const filters = uniqueFilters[name];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name, this.filters[filters[0]]);
        } else {
          logger$r.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger$r.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        // Without a provider, we cannot use ENS names
        logger$r.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    // Swallow bad ENS names to prevent Unhandled Exceptions
    this.resolvedAddress.catch(e => {});
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach(signature => {
      const fragment = this.interface.functions[signature];
      // Check that the signature is unique; if not the ABI generation has
      // not been cleaned or may be incorrectly generated
      if (uniqueSignatures[signature]) {
        logger$r.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
        return;
      }
      uniqueSignatures[signature] = true;
      // Track unique names; we only expose bare named functions if they
      // are ambiguous
      {
        const name = fragment.name;
        if (!uniqueNames[`%${name}`]) {
          uniqueNames[`%${name}`] = [];
        }
        uniqueNames[`%${name}`].push(signature);
      }
      if (this[signature] == null) {
        defineReadOnly(this, signature, buildDefault(this, fragment, true));
      }
      // We do not collapse simple calls on this bucket, which allows
      // frameworks to safely use this without introspection as well as
      // allows decoding error recovery.
      if (this.functions[signature] == null) {
        defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature] == null) {
        defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature] == null) {
        defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature] == null) {
        defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach(name => {
      // Ambiguous names to not get attached as bare names
      const signatures = uniqueNames[name];
      if (signatures.length > 1) {
        return;
      }
      // Strip off the leading "%" used for prototype protection
      name = name.substring(1);
      const signature = signatures[0];
      // If overwriting a member property that is null, swallow the error
      try {
        if (this[name] == null) {
          defineReadOnly(this, name, this[signature]);
        }
      } catch (e) {}
      if (this.functions[name] == null) {
        defineReadOnly(this.functions, name, this.functions[signature]);
      }
      if (this.callStatic[name] == null) {
        defineReadOnly(this.callStatic, name, this.callStatic[signature]);
      }
      if (this.populateTransaction[name] == null) {
        defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);
      }
      if (this.estimateGas[name] == null) {
        defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      // If we were just deployed, we know the transaction we should occur in
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        // @TODO: Once we allow a timeout to be passed in, we will wait
        // up to that many blocks for getCode
        // Otherwise, poll for our code to be deployed
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then(code => {
          if (code === "0x") {
            logger$r.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger$r.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction(fallback)"
      });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function (key) {
      if (tx[key] == null) {
        return;
      }
      logger$r.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: key
      });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    // Already have an instance of this event running; we can re-use it
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      // Listen for "error" events (if your contract has an error event, include
      // the full signature to bypass this special event keyword)
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      // Listen for any event that is registered
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      // Listen for any event
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      // Get the event Fragment (throws if ambiguous/unknown event)
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    // We have topics to filter by...
    if (eventName.topics && eventName.topics.length > 0) {
      // Is it a known topichash? (throws if no matching topichash)
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic"); // @TODO: May happen for anonymous events
        }

        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {}
      // Filter by the unknown topichash
      const filter = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(filter), filter));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      // If we have a poller for this, remove it
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    // This may throw if the topics and data mismatch the signature
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger$r.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "once"
      });
    }
    runningEvent.addListener(listener, once);
    // Track this running event and its listeners (may already be there; but no hard in updating)
    this._runningEvents[runningEvent.tag] = runningEvent;
    // If we are not polling the provider, start polling
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = log => {
        let event = this._wrapEvent(runningEvent, log, listener);
        // Try to emit the result for the parameterized event...
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        // Always emit "event" for fragment-base events
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        // Emit "error" if there was an error
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      // Special events, like "error" do not have a filter
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger$r.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter.blockHash = fromBlockOrBlockhash;
    } else {
      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter).then(logs => {
      return logs.map(log => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    // May have drained all the "once" events; check for living events
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key) => {
        return accum + this._runningEvents[key].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach(listener => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent = this._runningEvents[tag];
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
      }
      return this;
    }
    // Delete any listeners
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}
class Contract extends BaseContract {}
class ContractFactory {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      // Allow the bytecode object from the Solidity compiler
      bytecodeHex = bytecode.object;
    } else {
      // Crash in the next verification step
      bytecodeHex = "!";
    }
    // Make sure it is 0x prefixed
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    // Make sure the final result is valid bytecode
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger$r.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    // If we have a signer, make sure it is valid
    if (signer && !Signer.isSigner(signer)) {
      logger$r.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  // @TODO: Future; rename to populateTransaction?
  getDeployTransaction(...args) {
    let tx = {};
    // If we have 1 additional argument, we allow transaction overrides
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key in tx) {
        if (!allowedTransactionKeys$1[key]) {
          throw new Error("unknown transaction override " + key);
        }
      }
    }
    // Do not allow these to be overridden in a deployment transaction
    ["data", "from", "to"].forEach(key => {
      if (tx[key] == null) {
        return;
      }
      logger$r.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: key
      });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger$r.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    // Make sure the call matches the constructor signature
    logger$r.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    // Set the data to the bytecode + the encoded constructor arguments
    tx.data = hexlify(concat([this.bytecode, this.interface.encodeDeploy(args)]));
    return tx;
  }
  deploy(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let overrides = {};
      // If 1 extra parameter was passed in, it contains overrides
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      // Make sure the call matches the constructor signature
      logger$r.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      // Resolve ENS names and promises in the arguments
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      // Get the deployment transaction (with optional overrides)
      const unsignedTx = this.getDeployTransaction(...params);
      // Send the deployment transaction
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      // Add the modified wait that wraps events
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger$r.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, {
        argument: "compilerOutput"
      });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
}

/**
 * var basex = require("base-x");
 *
 * This implementation is heavily based on base-x. The main reason to
 * deviate was to prevent the dependency of Buffer.
 *
 * Contributors:
 *
 * base-x encoding
 * Forked from https://github.com/cryptocoinjs/bs58
 * Originally written by Mike Hearn for BitcoinJ
 * Copyright (c) 2011 Google Inc
 * Ported to JavaScript by Stefan Thomas
 * Merged Buffer refactorings from base58-native by Stephen Pair
 * Copyright (c) 2013 BitPay Inc
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */
class BaseX {
  constructor(alphabet) {
    defineReadOnly(this, "alphabet", alphabet);
    defineReadOnly(this, "base", alphabet.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet.charAt(0));
    // pre-compute lookup table
    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    // deal with leading zeros
    for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      string += this._leader;
    }
    // convert digits to a string
    for (let q = digits.length - 1; q >= 0; --q) {
      string += this.alphabet[digits[q]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];
      if (byte === undefined) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes.length; ++j) {
        carry += bytes[j] * this.base;
        bytes[j] = carry & 0xff;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 0xff);
        carry >>= 8;
      }
    }
    // deal with leading zeros
    for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
      bytes.push(0);
    }
    return arrayify(new Uint8Array(bytes.reverse()));
  }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
//console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))
//console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))

var lib_esm$9 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Base32: Base32,
    Base58: Base58,
    BaseX: BaseX
});

var SupportedAlgorithm;
(function (SupportedAlgorithm) {
  SupportedAlgorithm["sha256"] = "sha256";
  SupportedAlgorithm["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

const version$b = "sha2/5.7.0";

const logger$q = new Logger(version$b);
function ripemd160(data) {
  return "0x" + hash.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256$1(data) {
  return "0x" + hash.sha256().update(arrayify(data)).digest("hex");
}
function sha512(data) {
  return "0x" + hash.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm, key, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger$q.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm: algorithm
    });
  }
  return "0x" + hash.hmac(hash[algorithm], arrayify(key)).update(arrayify(data)).digest("hex");
}

var lib_esm$8 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get SupportedAlgorithm () { return SupportedAlgorithm; },
    computeHmac: computeHmac,
    ripemd160: ripemd160,
    sha256: sha256$1,
    sha512: sha512
});

function pbkdf2$1(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  //salt.copy(block1, 0, 0, salt.length)
  let r;
  let T;
  for (let i = 1; i <= l; i++) {
    //block1.writeUInt32BE(i, salt.length)
    block1[salt.length] = i >> 24 & 0xff;
    block1[salt.length + 1] = i >> 16 & 0xff;
    block1[salt.length + 2] = i >> 8 & 0xff;
    block1[salt.length + 3] = i & 0xff;
    //let U = createHmac(password).update(block1).digest();
    let U = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U.length;
      T = new Uint8Array(hLen);
      l = Math.ceil(keylen / hLen);
      r = keylen - (l - 1) * hLen;
    }
    //U.copy(T, 0, 0, hLen)
    T.set(U);
    for (let j = 1; j < iterations; j++) {
      //U = createHmac(password).update(U).digest();
      U = arrayify(computeHmac(hashAlgorithm, password, U));
      for (let k = 0; k < hLen; k++) T[k] ^= U[k];
    }
    const destPos = (i - 1) * hLen;
    const len = i === l ? r : hLen;
    //T.copy(DK, destPos, 0, len)
    DK.set(arrayify(T).slice(0, len), destPos);
  }
  return hexlify(DK);
}

const version$a = "wordlists/5.7.0";

const logger$p = new Logger(version$a);
class Wordlist {
  constructor(locale) {
    logger$p.checkAbstract(new.target, Wordlist);
    defineReadOnly(this, "locale", locale);
  }
  // Subclasses may override this
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(words) {
    return words.join(" ");
  }
  static check(wordlist) {
    const words = [];
    for (let i = 0; i < 2048; i++) {
      const word = wordlist.getWord(i);
      /* istanbul ignore if */
      if (i !== wordlist.getWordIndex(word)) {
        return "0x";
      }
      words.push(word);
    }
    return id(words.join("\n") + "\n");
  }
  static register(lang, name) {
    if (!name) {
      name = lang.locale;
    }
  }
}

const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  // Verify the computed list matches the official list
  /* istanbul ignore if */
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords(this);
    return wordlist[index];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);

const wordlists = {
  en: langEn
};

const version$9 = "hdnode/5.7.0";

const logger$o = new Logger(version$9);
const N$1 = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
// "Bitcoin seed"
const MasterSecret = toUtf8Bytes("Bitcoin seed");
const HardenedBit = 0x80000000;
// Returns a byte with the MSB bits set
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
// Returns a byte with the LSB bits set
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256$1(sha256$1(data)), 0, 4)]));
}
function getWordlist(wordlist) {
  if (wordlist == null) {
    return wordlists["en"];
  }
  if (typeof wordlist === "string") {
    const words = wordlists[wordlist];
    if (words == null) {
      logger$o.throwArgumentError("unknown locale", "wordlist", wordlist);
    }
    return words;
  }
  return wordlist;
}
const _constructorGuard$1 = {};
const defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
    /* istanbul ignore if */
    if (constructorGuard !== _constructorGuard$1) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly(this, "privateKey", signingKey.privateKey);
      defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly(this, "privateKey", null);
      defineReadOnly(this, "publicKey", hexlify(publicKey));
    }
    defineReadOnly(this, "parentFingerprint", parentFingerprint);
    defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256$1(this.publicKey)), 0, 4));
    defineReadOnly(this, "address", computeAddress(this.publicKey));
    defineReadOnly(this, "chainCode", chainCode);
    defineReadOnly(this, "index", index);
    defineReadOnly(this, "depth", depth);
    if (mnemonicOrPath == null) {
      // From a source that does not preserve the path (e.g. extended keys)
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      // From a source that does not preserve the mnemonic (e.g. neutered)
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", mnemonicOrPath);
    } else {
      // From a fully qualified source
      defineReadOnly(this, "mnemonic", mnemonicOrPath);
      defineReadOnly(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    // We only support the mainnet values for now, but if anyone needs
    // testnet values, let me know. I believe current sentiment is that
    // we should always use mainnet, and use BIP-44 to derive the network
    //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
    //   - Testnet: public=0x043587CF, private=0x04358394
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat([this.privateKey != null ? "0x0488ADE4" : "0x0488B21E", hexlify(this.depth), this.parentFingerprint, hexZeroPad(hexlify(this.index), 4), this.chainCode, this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey]));
  }
  neuter() {
    return new HDNode(_constructorGuard$1, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index) {
    if (index > 0xffffffff) {
      throw new Error("invalid index - " + String(index));
    }
    // Base path
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      // Data = 0x00 || ser_256(k_par)
      data.set(arrayify(this.privateKey), 1);
      // Hardened path
      if (path) {
        path += "'";
      }
    } else {
      // Data = ser_p(point(k_par))
      data.set(arrayify(this.publicKey));
    }
    // Data += ser_32(i)
    for (let i = 24; i >= 0; i -= 8) {
      data[33 + (i >> 3)] = index >> 24 - i & 0xff;
    }
    const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    // The private key
    let ki = null;
    // The public key
    let Ki = null;
    if (this.privateKey) {
      ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N$1));
    } else {
      const ek = new SigningKey(hexlify(IL));
      Ki = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path: path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard$1, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      if (component.match(/^[0-9]+'$/)) {
        const index = parseInt(component.substring(0, component.length - 1));
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index);
      } else if (component.match(/^[0-9]+$/)) {
        const index = parseInt(component);
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard$1, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist) {
    // If a locale name was passed in, find the associated wordlist
    wordlist = getWordlist(wordlist);
    // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes = Base58.decode(extendedKey);
    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
      logger$o.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify(bytes.slice(5, 9));
    const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes.slice(13, 45));
    const key = bytes.slice(45, 78);
    switch (hexlify(bytes.slice(0, 4))) {
      // Public Key
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard$1, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);
      // Private Key
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard$1, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
    }
    return logger$o.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2$1(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist) {
  wordlist = getWordlist(wordlist);
  logger$o.checkNormalize();
  const words = wordlist.split(mnemonic);
  if (words.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));
  let offset = 0;
  for (let i = 0; i < words.length; i++) {
    let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256$1(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
  wordlist = getWordlist(wordlist);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    // Consume the whole byte (with still more to go)
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
      // This byte will complete an 11-bit index
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      // Start the next word
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  // Compute the checksum bits
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256$1(entropy))[0] & getUpperMask(checksumBits);
  // Shift the checksum into the word indices
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist.join(indices.map(index => wordlist.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
    return true;
  } catch (error) {}
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger$o.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}

var lib_esm$7 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    HDNode: HDNode,
    defaultPath: defaultPath,
    entropyToMnemonic: entropyToMnemonic,
    getAccountPath: getAccountPath,
    isValidMnemonic: isValidMnemonic,
    mnemonicToEntropy: mnemonicToEntropy,
    mnemonicToSeed: mnemonicToSeed
});

const version$8 = "random/5.7.0";

const logger$n = new Logger(version$8);
// Debugging line for testing browser lib in node
//const window = { crypto: { getRandomValues: () => { } } };
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis
function getGlobal() {
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global$1 !== 'undefined') {
    return global$1;
  }
  throw new Error('unable to locate global object');
}
const anyGlobal = getGlobal();
let crypto = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto || !crypto.getRandomValues) {
  logger$n.warn("WARNING: Missing strong random number source");
  crypto = {
    getRandomValues: function (buffer) {
      return logger$n.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger$n.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto.getRandomValues(result);
  return arrayify(result);
}

function shuffled(array) {
  array = array.slice();
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
  return array;
}

var lib_esm$6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    randomBytes: randomBytes,
    shuffled: shuffled
});

var aesJsExports = {};
var aesJs = {
  get exports(){ return aesJsExports; },
  set exports(v){ aesJsExports = v; },
};

(function (module, exports) {

  (function (root) {
    function checkInt(value) {
      return parseInt(value) === value;
    }
    function checkInts(arrayish) {
      if (!checkInt(arrayish.length)) {
        return false;
      }
      for (var i = 0; i < arrayish.length; i++) {
        if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
          return false;
        }
      }
      return true;
    }
    function coerceArray(arg, copy) {
      // ArrayBuffer view
      if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {
        if (copy) {
          if (arg.slice) {
            arg = arg.slice();
          } else {
            arg = Array.prototype.slice.call(arg);
          }
        }
        return arg;
      }

      // It's an array; check it is a valid representation of a byte
      if (Array.isArray(arg)) {
        if (!checkInts(arg)) {
          throw new Error('Array contains invalid value: ' + arg);
        }
        return new Uint8Array(arg);
      }

      // Something else, but behaves like an array (maybe a Buffer? Arguments?)
      if (checkInt(arg.length) && checkInts(arg)) {
        return new Uint8Array(arg);
      }
      throw new Error('unsupported array-like object');
    }
    function createArray(length) {
      return new Uint8Array(length);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
      if (sourceStart != null || sourceEnd != null) {
        if (sourceArray.slice) {
          sourceArray = sourceArray.slice(sourceStart, sourceEnd);
        } else {
          sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
        }
      }
      targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = function () {
      function toBytes(text) {
        var result = [],
          i = 0;
        text = encodeURI(text);
        while (i < text.length) {
          var c = text.charCodeAt(i++);

          // if it is a % sign, encode the following 2 bytes as a hex value
          if (c === 37) {
            result.push(parseInt(text.substr(i, 2), 16));
            i += 2;

            // otherwise, just the actual byte
          } else {
            result.push(c);
          }
        }
        return coerceArray(result);
      }
      function fromBytes(bytes) {
        var result = [],
          i = 0;
        while (i < bytes.length) {
          var c = bytes[i];
          if (c < 128) {
            result.push(String.fromCharCode(c));
            i++;
          } else if (c > 191 && c < 224) {
            result.push(String.fromCharCode((c & 0x1f) << 6 | bytes[i + 1] & 0x3f));
            i += 2;
          } else {
            result.push(String.fromCharCode((c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f));
            i += 3;
          }
        }
        return result.join('');
      }
      return {
        toBytes: toBytes,
        fromBytes: fromBytes
      };
    }();
    var convertHex = function () {
      function toBytes(text) {
        var result = [];
        for (var i = 0; i < text.length; i += 2) {
          result.push(parseInt(text.substr(i, 2), 16));
        }
        return result;
      }

      // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
      var Hex = '0123456789abcdef';
      function fromBytes(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i++) {
          var v = bytes[i];
          result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
        }
        return result.join('');
      }
      return {
        toBytes: toBytes,
        fromBytes: fromBytes
      };
    }();

    // Number of rounds by keysize
    var numberOfRounds = {
      16: 10,
      24: 12,
      32: 14
    };

    // Round constant words
    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

    // S-box and Inverse S-box (S is for Substitution)
    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
    var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

    // Transformations for encryption
    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

    // Transformations for decryption
    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

    // Transformations for decryption key expansion
    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
    function convertToInt32(bytes) {
      var result = [];
      for (var i = 0; i < bytes.length; i += 4) {
        result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
      }
      return result;
    }
    var AES = function (key) {
      if (!(this instanceof AES)) {
        throw Error('AES must be instanitated with `new`');
      }
      Object.defineProperty(this, 'key', {
        value: coerceArray(key, true)
      });
      this._prepare();
    };
    AES.prototype._prepare = function () {
      var rounds = numberOfRounds[this.key.length];
      if (rounds == null) {
        throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
      }

      // encryption round keys
      this._Ke = [];

      // decryption round keys
      this._Kd = [];
      for (var i = 0; i <= rounds; i++) {
        this._Ke.push([0, 0, 0, 0]);
        this._Kd.push([0, 0, 0, 0]);
      }
      var roundKeyCount = (rounds + 1) * 4;
      var KC = this.key.length / 4;

      // convert the key into ints
      var tk = convertToInt32(this.key);

      // copy values into round key arrays
      var index;
      for (var i = 0; i < KC; i++) {
        index = i >> 2;
        this._Ke[index][i % 4] = tk[i];
        this._Kd[rounds - index][i % 4] = tk[i];
      }

      // key expansion (fips-197 section 5.2)
      var rconpointer = 0;
      var t = KC,
        tt;
      while (t < roundKeyCount) {
        tt = tk[KC - 1];
        tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
        rconpointer += 1;

        // key expansion (for non-256 bit)
        if (KC != 8) {
          for (var i = 1; i < KC; i++) {
            tk[i] ^= tk[i - 1];
          }

          // key expansion for 256-bit keys is "slightly different" (fips-197)
        } else {
          for (var i = 1; i < KC / 2; i++) {
            tk[i] ^= tk[i - 1];
          }
          tt = tk[KC / 2 - 1];
          tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;
          for (var i = KC / 2 + 1; i < KC; i++) {
            tk[i] ^= tk[i - 1];
          }
        }

        // copy values into round key arrays
        var i = 0,
          r,
          c;
        while (i < KC && t < roundKeyCount) {
          r = t >> 2;
          c = t % 4;
          this._Ke[r][c] = tk[i];
          this._Kd[rounds - r][c] = tk[i++];
          t++;
        }
      }

      // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
      for (var r = 1; r < rounds; r++) {
        for (var c = 0; c < 4; c++) {
          tt = this._Kd[r][c];
          this._Kd[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
        }
      }
    };
    AES.prototype.encrypt = function (plaintext) {
      if (plaintext.length != 16) {
        throw new Error('invalid plaintext size (must be 16 bytes)');
      }
      var rounds = this._Ke.length - 1;
      var a = [0, 0, 0, 0];

      // convert plaintext to (ints ^ key)
      var t = convertToInt32(plaintext);
      for (var i = 0; i < 4; i++) {
        t[i] ^= this._Ke[0][i];
      }

      // apply round transforms
      for (var r = 1; r < rounds; r++) {
        for (var i = 0; i < 4; i++) {
          a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ this._Ke[r][i];
        }
        t = a.slice();
      }

      // the last round is special
      var result = createArray(16),
        tt;
      for (var i = 0; i < 4; i++) {
        tt = this._Ke[rounds][i];
        result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
        result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
        result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
        result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
      }
      return result;
    };
    AES.prototype.decrypt = function (ciphertext) {
      if (ciphertext.length != 16) {
        throw new Error('invalid ciphertext size (must be 16 bytes)');
      }
      var rounds = this._Kd.length - 1;
      var a = [0, 0, 0, 0];

      // convert plaintext to (ints ^ key)
      var t = convertToInt32(ciphertext);
      for (var i = 0; i < 4; i++) {
        t[i] ^= this._Kd[0][i];
      }

      // apply round transforms
      for (var r = 1; r < rounds; r++) {
        for (var i = 0; i < 4; i++) {
          a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ this._Kd[r][i];
        }
        t = a.slice();
      }

      // the last round is special
      var result = createArray(16),
        tt;
      for (var i = 0; i < 4; i++) {
        tt = this._Kd[rounds][i];
        result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
        result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
        result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
        result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
      }
      return result;
    };

    /**
     *  Mode Of Operation - Electonic Codebook (ECB)
     */
    var ModeOfOperationECB = function (key) {
      if (!(this instanceof ModeOfOperationECB)) {
        throw Error('AES must be instanitated with `new`');
      }
      this.description = "Electronic Code Block";
      this.name = "ecb";
      this._aes = new AES(key);
    };
    ModeOfOperationECB.prototype.encrypt = function (plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0; i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        block = this._aes.encrypt(block);
        copyArray(block, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function (ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0; i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        copyArray(block, plaintext, i);
      }
      return plaintext;
    };

    /**
     *  Mode Of Operation - Cipher Block Chaining (CBC)
     */
    var ModeOfOperationCBC = function (key, iv) {
      if (!(this instanceof ModeOfOperationCBC)) {
        throw Error('AES must be instanitated with `new`');
      }
      this.description = "Cipher Block Chaining";
      this.name = "cbc";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error('invalid initialation vector size (must be 16 bytes)');
      }
      this._lastCipherblock = coerceArray(iv, true);
      this._aes = new AES(key);
    };
    ModeOfOperationCBC.prototype.encrypt = function (plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0; i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        for (var j = 0; j < 16; j++) {
          block[j] ^= this._lastCipherblock[j];
        }
        this._lastCipherblock = this._aes.encrypt(block);
        copyArray(this._lastCipherblock, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function (ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0; i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        for (var j = 0; j < 16; j++) {
          plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
        }
        copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
      }
      return plaintext;
    };

    /**
     *  Mode Of Operation - Cipher Feedback (CFB)
     */
    var ModeOfOperationCFB = function (key, iv, segmentSize) {
      if (!(this instanceof ModeOfOperationCFB)) {
        throw Error('AES must be instanitated with `new`');
      }
      this.description = "Cipher Feedback";
      this.name = "cfb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error('invalid initialation vector size (must be 16 size)');
      }
      if (!segmentSize) {
        segmentSize = 1;
      }
      this.segmentSize = segmentSize;
      this._shiftRegister = coerceArray(iv, true);
      this._aes = new AES(key);
    };
    ModeOfOperationCFB.prototype.encrypt = function (plaintext) {
      if (plaintext.length % this.segmentSize != 0) {
        throw new Error('invalid plaintext size (must be segmentSize bytes)');
      }
      var encrypted = coerceArray(plaintext, true);
      var xorSegment;
      for (var i = 0; i < encrypted.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j = 0; j < this.segmentSize; j++) {
          encrypted[i + j] ^= xorSegment[j];
        }

        // Shift the register
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function (ciphertext) {
      if (ciphertext.length % this.segmentSize != 0) {
        throw new Error('invalid ciphertext size (must be segmentSize bytes)');
      }
      var plaintext = coerceArray(ciphertext, true);
      var xorSegment;
      for (var i = 0; i < plaintext.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j = 0; j < this.segmentSize; j++) {
          plaintext[i + j] ^= xorSegment[j];
        }

        // Shift the register
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return plaintext;
    };

    /**
     *  Mode Of Operation - Output Feedback (OFB)
     */
    var ModeOfOperationOFB = function (key, iv) {
      if (!(this instanceof ModeOfOperationOFB)) {
        throw Error('AES must be instanitated with `new`');
      }
      this.description = "Output Feedback";
      this.name = "ofb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error('invalid initialation vector size (must be 16 bytes)');
      }
      this._lastPrecipher = coerceArray(iv, true);
      this._lastPrecipherIndex = 16;
      this._aes = new AES(key);
    };
    ModeOfOperationOFB.prototype.encrypt = function (plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0; i < encrypted.length; i++) {
        if (this._lastPrecipherIndex === 16) {
          this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
          this._lastPrecipherIndex = 0;
        }
        encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      }
      return encrypted;
    };

    // Decryption is symetric
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;

    /**
     *  Counter object for CTR common mode of operation
     */
    var Counter = function (initialValue) {
      if (!(this instanceof Counter)) {
        throw Error('Counter must be instanitated with `new`');
      }

      // We allow 0, but anything false-ish uses the default 1
      if (initialValue !== 0 && !initialValue) {
        initialValue = 1;
      }
      if (typeof initialValue === 'number') {
        this._counter = createArray(16);
        this.setValue(initialValue);
      } else {
        this.setBytes(initialValue);
      }
    };
    Counter.prototype.setValue = function (value) {
      if (typeof value !== 'number' || parseInt(value) != value) {
        throw new Error('invalid counter value (must be an integer)');
      }
      for (var index = 15; index >= 0; --index) {
        this._counter[index] = value % 256;
        value = value >> 8;
      }
    };
    Counter.prototype.setBytes = function (bytes) {
      bytes = coerceArray(bytes, true);
      if (bytes.length != 16) {
        throw new Error('invalid counter bytes size (must be 16 bytes)');
      }
      this._counter = bytes;
    };
    Counter.prototype.increment = function () {
      for (var i = 15; i >= 0; i--) {
        if (this._counter[i] === 255) {
          this._counter[i] = 0;
        } else {
          this._counter[i]++;
          break;
        }
      }
    };

    /**
     *  Mode Of Operation - Counter (CTR)
     */
    var ModeOfOperationCTR = function (key, counter) {
      if (!(this instanceof ModeOfOperationCTR)) {
        throw Error('AES must be instanitated with `new`');
      }
      this.description = "Counter";
      this.name = "ctr";
      if (!(counter instanceof Counter)) {
        counter = new Counter(counter);
      }
      this._counter = counter;
      this._remainingCounter = null;
      this._remainingCounterIndex = 16;
      this._aes = new AES(key);
    };
    ModeOfOperationCTR.prototype.encrypt = function (plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0; i < encrypted.length; i++) {
        if (this._remainingCounterIndex === 16) {
          this._remainingCounter = this._aes.encrypt(this._counter._counter);
          this._remainingCounterIndex = 0;
          this._counter.increment();
        }
        encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
      }
      return encrypted;
    };

    // Decryption is symetric
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;

    ///////////////////////
    // Padding

    // See:https://tools.ietf.org/html/rfc2315
    function pkcs7pad(data) {
      data = coerceArray(data, true);
      var padder = 16 - data.length % 16;
      var result = createArray(data.length + padder);
      copyArray(data, result);
      for (var i = data.length; i < result.length; i++) {
        result[i] = padder;
      }
      return result;
    }
    function pkcs7strip(data) {
      data = coerceArray(data, true);
      if (data.length < 16) {
        throw new Error('PKCS#7 invalid length');
      }
      var padder = data[data.length - 1];
      if (padder > 16) {
        throw new Error('PKCS#7 padding byte out of range');
      }
      var length = data.length - padder;
      for (var i = 0; i < padder; i++) {
        if (data[length + i] !== padder) {
          throw new Error('PKCS#7 invalid padding byte');
        }
      }
      var result = createArray(length);
      copyArray(data, result, 0, 0, length);
      return result;
    }

    ///////////////////////
    // Exporting

    // The block cipher
    var aesjs = {
      AES: AES,
      Counter: Counter,
      ModeOfOperation: {
        ecb: ModeOfOperationECB,
        cbc: ModeOfOperationCBC,
        cfb: ModeOfOperationCFB,
        ofb: ModeOfOperationOFB,
        ctr: ModeOfOperationCTR
      },
      utils: {
        hex: convertHex,
        utf8: convertUtf8
      },
      padding: {
        pkcs7: {
          pad: pkcs7pad,
          strip: pkcs7strip
        }
      },
      _arrayTest: {
        coerceArray: coerceArray,
        createArray: createArray,
        copyArray: copyArray
      }
    };

    // node.js
    {
      module.exports = aesjs;

      // RequireJS/AMD
      // http://www.requirejs.org/docs/api.html
      // https://github.com/amdjs/amdjs-api/wiki/AMD
    }
  })();
})(aesJs);
var aes = aesJsExports;

const version$7 = "json-wallets/5.7.0";

function looseArrayify(hexString) {
  if (typeof hexString === 'string' && hexString.substring(0, 2) !== '0x') {
    hexString = '0x' + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = '0' + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === 'string') {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split('/');
  for (let i = 0; i < comps.length; i++) {
    // Search for a child object with a case-insensitive matching key
    let matchingChild = null;
    for (const key in currentChild) {
      if (key.toLowerCase() === comps[i]) {
        matchingChild = currentChild[key];
        break;
      }
    }
    // Didn't find one. :'(
    if (matchingChild === null) {
      return null;
    }
    // Now check this child...
    currentChild = matchingChild;
  }
  return currentChild;
}
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
function uuidV4(randomBytes) {
  const bytes = arrayify(randomBytes);
  // Section: 4.1.3:
  // - time_hi_and_version[12:16] = 0b0100
  bytes[6] = bytes[6] & 0x0f | 0x40;
  // Section 4.4
  // - clock_seq_hi_and_reserved[6] = 0b0
  // - clock_seq_hi_and_reserved[7] = 0b1
  bytes[8] = bytes[8] & 0x3f | 0x80;
  const value = hexlify(bytes);
  return [value.substring(2, 10), value.substring(10, 14), value.substring(14, 18), value.substring(18, 22), value.substring(22, 34)].join("-");
}

const logger$m = new Logger(version$7);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }
}
// See: https://github.com/ethereum/pyethsaletool
function decrypt$1(json, password) {
  const data = JSON.parse(json);
  password = getPassword(password);
  // Ethereum Address
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  // Encrypted Seed
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger$m.throwArgumentError("invalid encseed", "json", json);
  }
  const key = arrayify(pbkdf2$1(password, password, 2000, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  // Decrypt the seed
  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);
  const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  // This wallet format is weird... Convert the binary encoded hex to a string.
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256$1(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey: privateKey
  });
}

function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff
  return true;
}
//export function isJsonWallet(json: string): boolean {
//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));
//}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}

var scryptExports = {};
var scrypt$1 = {
  get exports(){ return scryptExports; },
  set exports(v){ scryptExports = v; },
};

(function (module, exports) {

  (function (root) {
    const MAX_VALUE = 0x7fffffff;

    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
    // See: https://github.com/dchest/scrypt-async-js
    function SHA256(m) {
      const K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
      let h0 = 0x6a09e667,
        h1 = 0xbb67ae85,
        h2 = 0x3c6ef372,
        h3 = 0xa54ff53a;
      let h4 = 0x510e527f,
        h5 = 0x9b05688c,
        h6 = 0x1f83d9ab,
        h7 = 0x5be0cd19;
      const w = new Uint32Array(64);
      function blocks(p) {
        let off = 0,
          len = p.length;
        while (len >= 64) {
          let a = h0,
            b = h1,
            c = h2,
            d = h3,
            e = h4,
            f = h5,
            g = h6,
            h = h7,
            u,
            i,
            j,
            t1,
            t2;
          for (i = 0; i < 16; i++) {
            j = off + i * 4;
            w[i] = (p[j] & 0xff) << 24 | (p[j + 1] & 0xff) << 16 | (p[j + 2] & 0xff) << 8 | p[j + 3] & 0xff;
          }
          for (i = 16; i < 64; i++) {
            u = w[i - 2];
            t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
            u = w[i - 15];
            t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0) | 0;
          }
          for (i = 0; i < 64; i++) {
            t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
            t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
            h = g;
            g = f;
            f = e;
            e = d + t1 | 0;
            d = c;
            c = b;
            b = a;
            a = t1 + t2 | 0;
          }
          h0 = h0 + a | 0;
          h1 = h1 + b | 0;
          h2 = h2 + c | 0;
          h3 = h3 + d | 0;
          h4 = h4 + e | 0;
          h5 = h5 + f | 0;
          h6 = h6 + g | 0;
          h7 = h7 + h | 0;
          off += 64;
          len -= 64;
        }
      }
      blocks(m);
      let i,
        bytesLeft = m.length % 64,
        bitLenHi = m.length / 0x20000000 | 0,
        bitLenLo = m.length << 3,
        numZeros = bytesLeft < 56 ? 56 : 120,
        p = m.slice(m.length - bytesLeft, m.length);
      p.push(0x80);
      for (i = bytesLeft + 1; i < numZeros; i++) {
        p.push(0);
      }
      p.push(bitLenHi >>> 24 & 0xff);
      p.push(bitLenHi >>> 16 & 0xff);
      p.push(bitLenHi >>> 8 & 0xff);
      p.push(bitLenHi >>> 0 & 0xff);
      p.push(bitLenLo >>> 24 & 0xff);
      p.push(bitLenLo >>> 16 & 0xff);
      p.push(bitLenLo >>> 8 & 0xff);
      p.push(bitLenLo >>> 0 & 0xff);
      blocks(p);
      return [h0 >>> 24 & 0xff, h0 >>> 16 & 0xff, h0 >>> 8 & 0xff, h0 >>> 0 & 0xff, h1 >>> 24 & 0xff, h1 >>> 16 & 0xff, h1 >>> 8 & 0xff, h1 >>> 0 & 0xff, h2 >>> 24 & 0xff, h2 >>> 16 & 0xff, h2 >>> 8 & 0xff, h2 >>> 0 & 0xff, h3 >>> 24 & 0xff, h3 >>> 16 & 0xff, h3 >>> 8 & 0xff, h3 >>> 0 & 0xff, h4 >>> 24 & 0xff, h4 >>> 16 & 0xff, h4 >>> 8 & 0xff, h4 >>> 0 & 0xff, h5 >>> 24 & 0xff, h5 >>> 16 & 0xff, h5 >>> 8 & 0xff, h5 >>> 0 & 0xff, h6 >>> 24 & 0xff, h6 >>> 16 & 0xff, h6 >>> 8 & 0xff, h6 >>> 0 & 0xff, h7 >>> 24 & 0xff, h7 >>> 16 & 0xff, h7 >>> 8 & 0xff, h7 >>> 0 & 0xff];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
      // compress password if it's longer than hash block length
      password = password.length <= 64 ? password : SHA256(password);
      const innerLen = 64 + salt.length + 4;
      const inner = new Array(innerLen);
      const outerKey = new Array(64);
      let i;
      let dk = [];

      // inner = (password ^ ipad) || salt || counter
      for (i = 0; i < 64; i++) {
        inner[i] = 0x36;
      }
      for (i = 0; i < password.length; i++) {
        inner[i] ^= password[i];
      }
      for (i = 0; i < salt.length; i++) {
        inner[64 + i] = salt[i];
      }
      for (i = innerLen - 4; i < innerLen; i++) {
        inner[i] = 0;
      }

      // outerKey = password ^ opad
      for (i = 0; i < 64; i++) outerKey[i] = 0x5c;
      for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];

      // increments counter inside inner
      function incrementCounter() {
        for (let i = innerLen - 1; i >= innerLen - 4; i--) {
          inner[i]++;
          if (inner[i] <= 0xff) return;
          inner[i] = 0;
        }
      }

      // output blocks = SHA256(outerKey || SHA256(inner)) ...
      while (dkLen >= 32) {
        incrementCounter();
        dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
        dkLen -= 32;
      }
      if (dkLen > 0) {
        incrementCounter();
        dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
      }
      return dk;
    }

    // The following is an adaptation of scryptsy
    // See: https://www.npmjs.com/package/scryptsy
    function blockmix_salsa8(BY, Yi, r, x, _X) {
      let i;
      arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
      for (i = 0; i < 2 * r; i++) {
        blockxor(BY, i * 16, _X, 16);
        salsa20_8(_X, x);
        arraycopy(_X, 0, BY, Yi + i * 16, 16);
      }
      for (i = 0; i < r; i++) {
        arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
      }
      for (i = 0; i < r; i++) {
        arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
      }
    }
    function R(a, b) {
      return a << b | a >>> 32 - b;
    }
    function salsa20_8(B, x) {
      arraycopy(B, 0, x, 0, 16);
      for (let i = 8; i > 0; i -= 2) {
        x[4] ^= R(x[0] + x[12], 7);
        x[8] ^= R(x[4] + x[0], 9);
        x[12] ^= R(x[8] + x[4], 13);
        x[0] ^= R(x[12] + x[8], 18);
        x[9] ^= R(x[5] + x[1], 7);
        x[13] ^= R(x[9] + x[5], 9);
        x[1] ^= R(x[13] + x[9], 13);
        x[5] ^= R(x[1] + x[13], 18);
        x[14] ^= R(x[10] + x[6], 7);
        x[2] ^= R(x[14] + x[10], 9);
        x[6] ^= R(x[2] + x[14], 13);
        x[10] ^= R(x[6] + x[2], 18);
        x[3] ^= R(x[15] + x[11], 7);
        x[7] ^= R(x[3] + x[15], 9);
        x[11] ^= R(x[7] + x[3], 13);
        x[15] ^= R(x[11] + x[7], 18);
        x[1] ^= R(x[0] + x[3], 7);
        x[2] ^= R(x[1] + x[0], 9);
        x[3] ^= R(x[2] + x[1], 13);
        x[0] ^= R(x[3] + x[2], 18);
        x[6] ^= R(x[5] + x[4], 7);
        x[7] ^= R(x[6] + x[5], 9);
        x[4] ^= R(x[7] + x[6], 13);
        x[5] ^= R(x[4] + x[7], 18);
        x[11] ^= R(x[10] + x[9], 7);
        x[8] ^= R(x[11] + x[10], 9);
        x[9] ^= R(x[8] + x[11], 13);
        x[10] ^= R(x[9] + x[8], 18);
        x[12] ^= R(x[15] + x[14], 7);
        x[13] ^= R(x[12] + x[15], 9);
        x[14] ^= R(x[13] + x[12], 13);
        x[15] ^= R(x[14] + x[13], 18);
      }
      for (let i = 0; i < 16; ++i) {
        B[i] += x[i];
      }
    }

    // naive approach... going back to loop unrolling may yield additional performance
    function blockxor(S, Si, D, len) {
      for (let i = 0; i < len; i++) {
        D[i] ^= S[Si + i];
      }
    }
    function arraycopy(src, srcPos, dest, destPos, length) {
      while (length--) {
        dest[destPos++] = src[srcPos++];
      }
    }
    function checkBufferish(o) {
      if (!o || typeof o.length !== 'number') {
        return false;
      }
      for (let i = 0; i < o.length; i++) {
        const v = o[i];
        if (typeof v !== 'number' || v % 1 || v < 0 || v >= 256) {
          return false;
        }
      }
      return true;
    }
    function ensureInteger(value, name) {
      if (typeof value !== "number" || value % 1) {
        throw new Error('invalid ' + name);
      }
      return value;
    }

    // N = Cpu cost, r = Memory cost, p = parallelization cost
    // callback(error, progress, key)
    function _scrypt(password, salt, N, r, p, dkLen, callback) {
      N = ensureInteger(N, 'N');
      r = ensureInteger(r, 'r');
      p = ensureInteger(p, 'p');
      dkLen = ensureInteger(dkLen, 'dkLen');
      if (N === 0 || (N & N - 1) !== 0) {
        throw new Error('N must be power of 2');
      }
      if (N > MAX_VALUE / 128 / r) {
        throw new Error('N too large');
      }
      if (r > MAX_VALUE / 128 / p) {
        throw new Error('r too large');
      }
      if (!checkBufferish(password)) {
        throw new Error('password must be an array or buffer');
      }
      password = Array.prototype.slice.call(password);
      if (!checkBufferish(salt)) {
        throw new Error('salt must be an array or buffer');
      }
      salt = Array.prototype.slice.call(salt);
      let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
      const B = new Uint32Array(p * 32 * r);
      for (let i = 0; i < B.length; i++) {
        const j = i * 4;
        B[i] = (b[j + 3] & 0xff) << 24 | (b[j + 2] & 0xff) << 16 | (b[j + 1] & 0xff) << 8 | (b[j + 0] & 0xff) << 0;
      }
      const XY = new Uint32Array(64 * r);
      const V = new Uint32Array(32 * r * N);
      const Yi = 32 * r;

      // scratch space
      const x = new Uint32Array(16); // salsa20_8
      const _X = new Uint32Array(16); // blockmix_salsa8

      const totalOps = p * N * 2;
      let currentOp = 0;
      let lastPercent10 = null;

      // Set this to true to abandon the scrypt on the next step
      let stop = false;

      // State information
      let state = 0;
      let i0 = 0,
        i1;
      let Bi;

      // How many blockmix_salsa8 can we do per step?
      const limit = callback ? parseInt(1000 / r) : 0xffffffff;

      // Trick from scrypt-async; if there is a setImmediate shim in place, use it
      const nextTick = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;

      // This is really all I changed; making scryptsy a state machine so we occasionally
      // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
      const incrementalSMix = function () {
        if (stop) {
          return callback(new Error('cancelled'), currentOp / totalOps);
        }
        let steps;
        switch (state) {
          case 0:
            // for (var i = 0; i < p; i++)...
            Bi = i0 * 32 * r;
            arraycopy(B, Bi, XY, 0, Yi); // ROMix - 1

            state = 1; // Move to ROMix 2
            i1 = 0;

          // Fall through

          case 1:
            // Run up to 1000 steps of the first inner smix loop
            steps = N - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i = 0; i < steps; i++) {
              // ROMix - 2
              arraycopy(XY, 0, V, (i1 + i) * Yi, Yi); // ROMix - 3
              blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 4
            }

            // for (var i = 0; i < N; i++)
            i1 += steps;
            currentOp += steps;
            if (callback) {
              // Call the callback with the progress (optionally stopping us)
              const percent10 = parseInt(1000 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N) {
              break;
            }
            i1 = 0; // Move to ROMix 6
            state = 2;

          // Fall through

          case 2:
            // Run up to 1000 steps of the second inner smix loop
            steps = N - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i = 0; i < steps; i++) {
              // ROMix - 6
              const offset = (2 * r - 1) * 16; // ROMix - 7
              const j = XY[offset] & N - 1;
              blockxor(V, j * Yi, XY, Yi); // ROMix - 8 (inner)
              blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 9 (outer)
            }

            // for (var i = 0; i < N; i++)...
            i1 += steps;
            currentOp += steps;

            // Call the callback with the progress (optionally stopping us)
            if (callback) {
              const percent10 = parseInt(1000 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N) {
              break;
            }
            arraycopy(XY, 0, B, Bi, Yi); // ROMix - 10

            // for (var i = 0; i < p; i++)...
            i0++;
            if (i0 < p) {
              state = 0;
              break;
            }
            b = [];
            for (let i = 0; i < B.length; i++) {
              b.push(B[i] >> 0 & 0xff);
              b.push(B[i] >> 8 & 0xff);
              b.push(B[i] >> 16 & 0xff);
              b.push(B[i] >> 24 & 0xff);
            }
            const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);

            // Send the result to the callback
            if (callback) {
              callback(null, 1.0, derivedKey);
            }

            // Done; don't break (which would reschedule)
            return derivedKey;
        }

        // Schedule the next steps
        if (callback) {
          nextTick(incrementalSMix);
        }
      };

      // Run the smix state machine until completion
      if (!callback) {
        while (true) {
          const derivedKey = incrementalSMix();
          if (derivedKey != undefined) {
            return derivedKey;
          }
        }
      }

      // Bootstrap the async incremental smix
      incrementalSMix();
    }
    const lib = {
      scrypt: function (password, salt, N, r, p, dkLen, progressCallback) {
        return new Promise(function (resolve, reject) {
          let lastProgress = 0;
          if (progressCallback) {
            progressCallback(0);
          }
          _scrypt(password, salt, N, r, p, dkLen, function (error, progress, key) {
            if (error) {
              reject(error);
            } else if (key) {
              if (progressCallback && lastProgress !== 1) {
                progressCallback(1);
              }
              resolve(new Uint8Array(key));
            } else if (progressCallback && progress !== lastProgress) {
              lastProgress = progress;
              return progressCallback(progress);
            }
          });
        });
      },
      syncScrypt: function (password, salt, N, r, p, dkLen) {
        return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
      }
    };

    // node.js
    {
      module.exports = lib;

      // RequireJS/AMD
      // http://www.requirejs.org/docs/api.html
      // https://github.com/amdjs/amdjs-api/wiki/AMD
    }
  })();
})(scrypt$1);
var scrypt = scryptExports;

var __awaiter$a = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$l = new Logger(version$7);
// Exported Types
function hasMnemonic$1(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }
}
function _decrypt(data, key, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(key, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256$1(concat([key.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger$l.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address: address,
    privateKey: hexlify(privateKey)
  };
  // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new aes.Counter(mnemonicIv);
    const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      // If we don't have the locale wordlist installed to
      // read this mnemonic, just bail and don't set the
      // mnemonic
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return arrayify(pbkdf2$1(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError = function (name, value) {
      return logger$l.throwArgumentError("invalid key-derivation function parameters", name, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p = parseInt(searchPath(data, "crypto/kdfparams/p"));
      // Check for all required parameters
      if (!N || !r || !p) {
        throwError("kdf", kdf);
      }
      // Make sure N is a power of 2
      if ((N & N - 1) !== 0) {
        throwError("N", N);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError("prf", prf);
      }
      const count = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }
  return logger$l.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data = JSON.parse(json);
  const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(data, key);
}
function decrypt(json, password, progressCallback) {
  return __awaiter$a(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);
    return _getAccount(data, key);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    // Check the address matches the private key
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    // Check the mnemonic (if any) matches the private key
    if (hasMnemonic$1(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e) {
    return Promise.reject(e);
  }
  // The options are optional, so adjust the call as needed
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic$1(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  // Check/generate the salt
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes(32);
  }
  // Override initialization vector
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  // Override the uuid
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  // Override the scrypt password-based key derivation function parameters
  let N = 1 << 17,
    r = 8,
    p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  // We take 64 bytes:
  //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
  //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
  return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(key => {
    key = arrayify(key);
    // This will be used to encrypt the wallet (as per Web3 secret storage)
    const derivedKey = key.slice(0, 16);
    const macPrefix = key.slice(16, 32);
    // This will be used to encrypt the mnemonic phrase (if any)
    const mnemonicKey = key.slice(32, 64);
    // Encrypt the private key
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    // Compute the message authentication code, used to check the password
    const mac = keccak256$1(concat([macPrefix, ciphertext]));
    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N,
          dklen: 32,
          p: p,
          r: r
        },
        mac: mac.substring(2)
      }
    };
    // If we have a mnemonic, encrypt it into the JSON wallet
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new aes.Counter(mnemonicIv);
      const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now = new Date();
      const timestamp = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client: client,
        gethFilename: "UTC--" + timestamp + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path: path,
        locale: locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}

function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt$1(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt$1(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}

var lib_esm$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    decryptCrowdsale: decrypt$1,
    decryptJsonWallet: decryptJsonWallet,
    decryptJsonWalletSync: decryptJsonWalletSync,
    decryptKeystore: decrypt,
    decryptKeystoreSync: decryptSync,
    encryptKeystore: encrypt,
    getJsonWalletAddress: getJsonWalletAddress,
    isCrowdsaleWallet: isCrowdsaleWallet,
    isKeystoreWallet: isKeystoreWallet
});

const version$6 = "wallet/5.7.0";

var __awaiter$9 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$k = new Logger(version$6);
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
class Wallet extends Signer {
  constructor(privateKey, provider) {
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger$k.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node.privateKey) !== this.address) {
          logger$k.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        /* istanbul ignore if */
        if (privateKey.curve !== "secp256k1") {
          logger$k.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        // A lot of common tools do not prefix private keys with a 0x (see: #1166)
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    /* istanbul ignore if */
    if (provider && !Provider.isProvider(provider)) {
      logger$k.throwArgumentError("invalid provider", "provider", provider);
    }
    defineReadOnly(this, "provider", provider || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider) {
    return new Wallet(this, provider);
  }
  signTransaction(transaction) {
    return resolveProperties(transaction).then(tx => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger$k.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }
        delete tx.from;
      }
      const signature = this._signingKey().signDigest(keccak256$1(serialize$1(tx)));
      return serialize$1(tx, signature);
    });
  }
  signMessage(message) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter$9(this, void 0, void 0, function* () {
      // Populate any ENS names
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, name => {
        if (this.provider == null) {
          logger$k.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name
          });
        }
        return this.provider.resolveName(name);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt(this, password, options, progressCallback);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(options) {
    let entropy = randomBytes(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256$1(concat([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json, password, progressCallback) {
    return decryptJsonWallet(json, password, progressCallback).then(account => {
      return new Wallet(account);
    });
  }
  static fromEncryptedJsonSync(json, password) {
    return new Wallet(decryptJsonWalletSync(json, password));
  }
  static fromMnemonic(mnemonic, path, wordlist) {
    if (!path) {
      path = defaultPath;
    }
    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
  }
}
function verifyMessage(message, signature) {
  return recoverAddress(hashMessage(message), signature);
}
function verifyTypedData(domain, types, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
}

var lib_esm$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Wallet: Wallet,
    verifyMessage: verifyMessage,
    verifyTypedData: verifyTypedData
});

const version$5 = "networks/5.7.1";

const logger$j = new Logger(version$5);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function (providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {}
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {}
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {}
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      // These networks are currently faulty on Pocket as their
      // network does not handle the Berlin hardfork, which is
      // live on these ones.
      // @TODO: This goes away once Pocket has upgraded their nodes
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {}
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {}
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {}
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function (network) {
    return ethDefaultProvider(network);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function (providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function (network) {
    return etcDefaultProvider(url, network);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
// See: https://chainlist.org
const networks = {
  unspecified: {
    chainId: 0,
    name: "unspecified"
  },
  homestead: homestead,
  mainnet: homestead,
  morden: {
    chainId: 2,
    name: "morden"
  },
  ropsten: ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: {
    chainId: 1337702,
    name: "kintsugi"
  },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/etc", "classic")
  },
  classicMorden: {
    chainId: 62,
    name: "classicMorden"
  },
  classicMordor: classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: {
    chainId: 100,
    name: "xdai"
  },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: {
    chainId: 80001,
    name: "maticmum"
  },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": {
    chainId: 69,
    name: "optimism-kovan"
  },
  "optimism-goerli": {
    chainId: 420,
    name: "optimism-goerli"
  },
  arbitrum: {
    chainId: 42161,
    name: "arbitrum"
  },
  "arbitrum-rinkeby": {
    chainId: 421611,
    name: "arbitrum-rinkeby"
  },
  "arbitrum-goerli": {
    chainId: 421613,
    name: "arbitrum-goerli"
  },
  bnb: {
    chainId: 56,
    name: "bnb"
  },
  bnbt: {
    chainId: 97,
    name: "bnbt"
  }
};
/**
 *  getNetwork
 *
 *  Converts a named common networks or chain ID (network ID) to a Network
 *  and verifies a network is a valid Network..
 */
function getNetwork(network) {
  // No network (null)
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name in networks) {
      const standard = networks[name];
      if (standard.chainId === network) {
        return {
          name: standard.name,
          chainId: standard.chainId,
          ensAddress: standard.ensAddress || null,
          _defaultProvider: standard._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard = networks[network];
    if (standard == null) {
      return null;
    }
    return {
      name: standard.name,
      chainId: standard.chainId,
      ensAddress: standard.ensAddress,
      _defaultProvider: standard._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  // Not a standard network; check that it is a valid network in general
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger$j.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger$j.throwArgumentError("network chainId mismatch", "network", network);
  }
  // @TODO: In the next major version add an attach function to a defaultProvider
  // class and move the _defaultProvider internal to this file (extend Network)
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  // Standard Network (allow overriding the ENS address)
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

const version$4 = "web/5.7.1";

var __awaiter$8 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter$8(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || undefined
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors"; // no-cors, cors, *same-origin
      request.cache = "no-cache"; // *default, no-cache, reload, force-cache, only-if-cached
      request.credentials = "same-origin"; // include, *same-origin, omit
      request.redirect = "follow"; // manual, *follow, error
      request.referrer = "client"; // no-referrer, *client
    }
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key) => {
        headers[key.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach(key => {
        headers[key.toLowerCase()] = response.headers.get(key);
      });
    }
    return {
      headers: headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}

var __awaiter$7 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$i = new Logger(version$4);
function staller(duration) {
  return new Promise(resolve => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {}
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
// This API is still a work in progress; the future changes will likely be:
// - ConnectionInfo => FetchDataRequest<T = any>
// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }
//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)
// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T
// For this reason, it should be considered internal until the API is finalized
function _fetchData(connection, body, processFunc) {
  // How many times to retry in the event of a throttle
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$i.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$i.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  // @TODO: Allow ConnectionInfo to override some of these values
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1000;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$i.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key in connection.headers) {
        headers[key.toLowerCase()] = {
          key: key,
          value: String(connection.headers[key])
        };
        if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$i.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, {
          argument: "url",
          url: url,
          user: connection.user,
          password: "[REDACTED]"
        });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$1(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "content-type": dataMatch[1] || "text/plain"
        },
        body: dataMatch[2] ? decode$1(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger$i.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error: error,
        requestBody: null,
        requestMethod: "GET",
        url: url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream"
      };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = {
        key: "Content-Length",
        value: String(body.length)
      };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach(key => {
    const header = headers[key];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function () {
    let timer = null;
    const promise = new Promise(function (resolve, reject) {
      if (timeout) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          reject(logger$i.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout,
            url: url
          }));
        }, timeout);
      }
    });
    const cancel = function () {
      if (timer == null) {
        return;
      }
      clearTimeout(timer);
      timer = null;
    };
    return {
      promise,
      cancel
    };
  }();
  const runningFetch = function () {
    return __awaiter$7(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              // Redirection; for now we only support absolute locataions
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              // Exponential back-off throttling
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall = parseInt(retryAfter) * 1000;
                } else {
                  stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                //console.log("Stalling 429");
                yield staller(stall);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$i.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url: url
            });
          }
        }
        let body = response.body;
        if (allow304 && response.statusCode === 304) {
          body = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger$i.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url: url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            // Allow the processFunc to trigger a throttle
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                //console.log("Stalling callback");
                yield staller(timeout);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$i.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body, response.headers ? response.headers["content-type"] : null),
              error: error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url: url
            });
          }
        }
        runningTimeout.cancel();
        // If we had a processFunc, it either returned a T or threw above.
        // The "body" is now a Uint8Array.
        return body;
      }
      return logger$i.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url: url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger$i.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error: error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  // If we have json to send, we must
  // - add content-type of application/json (unless already overridden)
  // - convert the json to bytes
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    // Create a connection with the content-type set for JSON
    const updated = typeof connection === "string" ? {
      url: connection
    } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter(k => k.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = {
        "content-type": "application/json"
      };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 10000;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function (resolve, reject) {
    let timer = null;
    let done = false;
    // Returns true if cancel was successful. Unsuccessful cancel means we're already done.
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer) {
        clearTimeout(timer);
      }
      return true;
    };
    if (options.timeout) {
      timer = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function (result) {
        // If we have a result, or are allowed null then we're done
        if (result !== undefined) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
          // Otherwise, exponential back-off (up to 10s) our next request
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function (error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}

var lib_esm$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _fetchData: _fetchData,
    fetchJson: fetchJson,
    poll: poll
});

var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

// pre-compute lookup table
var ALPHABET_MAP = {};
for (var z$1 = 0; z$1 < ALPHABET.length; z$1++) {
  var x = ALPHABET.charAt(z$1);
  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous');
  ALPHABET_MAP[x] = z$1;
}
function polymodStep(pre) {
  var b = pre >> 25;
  return (pre & 0x1FFFFFF) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}
function prefixChk(prefix) {
  var chk = 1;
  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
    chk = polymodStep(chk) ^ c >> 5;
  }
  chk = polymodStep(chk);
  for (i = 0; i < prefix.length; ++i) {
    var v = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ v & 0x1f;
  }
  return chk;
}
function encode(prefix, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
  prefix = prefix.toLowerCase();

  // determine chk mod
  var chk = prefixChk(prefix);
  if (typeof chk === 'string') throw new Error(chk);
  var result = prefix + '1';
  for (var i = 0; i < words.length; ++i) {
    var x = words[i];
    if (x >> 5 !== 0) throw new Error('Non 5-bit word');
    chk = polymodStep(chk) ^ x;
    result += ALPHABET.charAt(x);
  }
  for (i = 0; i < 6; ++i) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i = 0; i < 6; ++i) {
    var v = chk >> (5 - i) * 5 & 0x1f;
    result += ALPHABET.charAt(v);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8) return str + ' too short';
  if (str.length > LIMIT) return 'Exceeds length limit';

  // don't allow mixed case
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
  str = lowered;
  var split = str.lastIndexOf('1');
  if (split === -1) return 'No separator character for ' + str;
  if (split === 0) return 'Missing prefix for ' + str;
  var prefix = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6) return 'Data too short';
  var chk = prefixChk(prefix);
  if (typeof chk === 'string') return chk;
  var words = [];
  for (var i = 0; i < wordChars.length; ++i) {
    var c = wordChars.charAt(i);
    var v = ALPHABET_MAP[c];
    if (v === undefined) return 'Unknown character ' + c;
    chk = polymodStep(chk) ^ v;

    // not in the checksum?
    if (i + 6 >= wordChars.length) continue;
    words.push(v);
  }
  if (chk !== 1) return 'Invalid checksum for ' + str;
  return {
    prefix: prefix,
    words: words
  };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === 'object') return res;
}
function decode(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === 'object') return res;
  throw new Error(res);
}
function convert(data, inBits, outBits, pad) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits) return 'Excess padding';
    if (value << outBits - bits & maxV) return 'Non-zero padding';
  }
  return result;
}
function toWordsUnsafe(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res)) return res;
}
function toWords(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}
function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
}
function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe: decodeUnsafe,
  decode: decode,
  encode: encode,
  toWordsUnsafe: toWordsUnsafe,
  toWords: toWords,
  fromWordsUnsafe: fromWordsUnsafe,
  fromWords: fromWords
};

const version$3 = "providers/5.7.2";

const logger$h = new Logger(version$3);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = v => {
      return this.data(v, true);
    };
    formats.transaction = {
      hash: hash,
      type: type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data: data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash,
      address: address,
      topics: Formatter.arrayOf(hash),
      data: data,
      logIndex: number,
      blockHash: hash
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash,
      transactionHash: hash,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type: type
    };
    formats.block = {
      hash: Formatter.allowNull(hash),
      parentHash: hash,
      number: number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, undefined),
      toBlock: Formatter.allowNull(blockTag, undefined),
      blockHash: Formatter.allowNull(hash, undefined),
      address: Formatter.allowNull(address, undefined),
      topics: Formatter.allowNull(this.topics.bind(this), undefined)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address: address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash),
      transactionHash: hash,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger$h.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero$1 ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$h.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v = BigNumber.from(value);
    try {
      return v.toNumber();
    } catch (error) {}
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    // The difficulty may need to come from _difficulty in recursed blocks
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    // Rename gas to gasLimit
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    // Some clients (TestRPC) do strange things like return 0x0 for the
    // 0 address; correct this to be a real address
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    // Rename input to data
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    // If to and creates are empty, populate the creates from the transaction
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      // geth-etc returns chainId
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    // 0x0000... should actually be null
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    // RSK incorrectly implemented EIP-658, so we munge things a bit here for it
    if (result.root != null) {
      if (result.root.length <= 4) {
        // Could be 0x00, 0x0, 0x01 or 0x1
        const value = BigNumber.from(result.root).toNumber();
        if (value === 0 || value === 1) {
          // Make sure if both are specified, they match
          if (result.status != null && result.status !== value) {
            logger$h.throwArgumentError("alt-root-status/status mismatch", "value", {
              root: result.root,
              status: result.status
            });
          }
          result.status = value;
          delete result.root;
        } else {
          logger$h.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        // Must be a valid bytes32
        logger$h.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map(v => this.topics(v));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key in format) {
      try {
        const value = format[key](object[key]);
        if (value !== undefined) {
          result[key] = value;
        }
      } catch (error) {
        error.checkKey = key;
        error.checkValue = object[key];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format, nullValue) {
    return function (value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format, replaceValue) {
    return function (value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format) {
    return function (array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function (value) {
        result.push(format(value));
      });
      return result;
    };
  }
}
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
// Show the throttle message only once
let throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https:/\/docs.ethers.io/api-keys/");
  console.log("==========================");
}

var __awaiter$6 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$g = new Logger(version$3);
const MAX_CCIP_REDIRECTS = 10;
//////////////////////////////
// Event Serializeing
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$g.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  // Remove trailing null AND-topics; they are redundant
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map(topic => {
    if (Array.isArray(topic)) {
      // Only track unique OR-topics
      const unique = {};
      topic.forEach(topic => {
        unique[checkTopic(topic)] = true;
      });
      // The order of OR-topics does not matter
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map(topic => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map(topic => {
      return topic === "null" ? null : topic;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$g.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
//////////////////////////////
// Helper Object
function getTime() {
  return new Date().getTime();
}
function stall$1(duration) {
  return new Promise(resolve => {
    setTimeout(resolve, duration);
  });
}
//////////////////////////////
// Provider Object
/**
 *  EventType
 *   - "block"
 *   - "poll"
 *   - "didPoll"
 *   - "pending"
 *   - "error"
 *   - "network"
 *   - filter
 *   - topics array
 *   - transaction hash
 */
const PollableEvents = ["block", "network", "pending", "poll"];
let Event$1 = class Event {
  constructor(tag, listener, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};
    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address && address !== "*") {
      filter.address = address;
    }
    return filter;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
const coinInfos = {
  "0": {
    symbol: "btc",
    p2pkh: 0x00,
    p2sh: 0x05,
    prefix: "bc"
  },
  "2": {
    symbol: "ltc",
    p2pkh: 0x30,
    p2sh: 0x32,
    prefix: "ltc"
  },
  "3": {
    symbol: "doge",
    p2pkh: 0x1e,
    p2sh: 0x16
  },
  "60": {
    symbol: "eth",
    ilk: "eth"
  },
  "61": {
    symbol: "etc",
    ilk: "eth"
  },
  "700": {
    symbol: "xdai",
    ilk: "eth"
  }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256$1(sha256$1(data)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
const matchers = [new RegExp("^(https):/\/(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), matcherIpfs, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {}
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
// Trim off the ipfs:// prefix and return the default gateway URL
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$g.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https:/\/gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  // Add place-holders for pointers as we add items
  for (let i = 0; i < datas.length; i++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = arrayify(datas[i]);
    // Update the bytes offset
    result[i] = numPad(byteCount);
    // The length and padded value of data
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
}
class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      // supportsInterface(bytes4 = selector("resolve(bytes,bytes)"))
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then(result => {
        return BigNumber.from(result).eq(1);
      }).catch(error => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        // Rethrow the error: link is down, etc. Let future attempts retry.
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter$6(this, void 0, void 0, function* () {
      // e.g. keccak256("addr(bytes32,uint256)")
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      // Wildcard support; use EIP-2544 to resolve the request
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        // selector("resolve(bytes,bytes)")
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger$g.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$g.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    // P2SH: OP_HASH160 <scriptHash> OP_EQUAL
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    // Bech32
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program
      let version = bytes[0];
      if (version === 0x00) {
        if (length !== 20 && length !== 32) {
          version = -1;
        }
      } else {
        version = -1;
      }
      if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words = bech32.toWords(bytes.slice(2));
        words.unshift(version);
        return bech32.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      // If Ethereum, use the standard `addr(bytes32)`
      if (coinType === 60) {
        try {
          // keccak256("addr(bytes32)")
          const result = yield this._fetch("0x3b3b57de");
          // No address
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      // keccak256("addr(bytes32,uint256")
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      // No address
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      // Compute the address
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$g.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType: coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const linkage = [{
        type: "name",
        content: this.name
      }];
      try {
        // test data for ricmoo.eth
        //const avatar = "eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233";
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i = 0; i < matchers.length; i++) {
          const match = avatar.match(matchers[i]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({
                type: "url",
                content: avatar
              });
              return {
                linkage,
                url: avatar
              };
            case "data":
              linkage.push({
                type: "data",
                content: avatar
              });
              return {
                linkage,
                url: avatar
              };
            case "ipfs":
              linkage.push({
                type: "ipfs",
                content: avatar
              });
              return {
                linkage,
                url: getIpfsLink(avatar)
              };
            case "erc721":
            case "erc1155":
              {
                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                linkage.push({
                  type: scheme,
                  content: avatar
                });
                // The owner of this name
                const owner = this._resolvedAddress || (yield this.getAddress());
                const comps = (match[2] || "").split("/");
                if (comps.length !== 2) {
                  return null;
                }
                const addr = yield this.provider.formatter.address(comps[0]);
                const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
                // Check that this account owns the token
                if (scheme === "erc721") {
                  // ownerOf(uint256 tokenId)
                  const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                    to: addr,
                    data: hexConcat(["0x6352211e", tokenId])
                  }));
                  if (owner !== tokenOwner) {
                    return null;
                  }
                  linkage.push({
                    type: "owner",
                    content: tokenOwner
                  });
                } else if (scheme === "erc1155") {
                  // balanceOf(address owner, uint256 tokenId)
                  const balance = BigNumber.from(yield this.provider.call({
                    to: addr,
                    data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                  }));
                  if (balance.isZero()) {
                    return null;
                  }
                  linkage.push({
                    type: "balance",
                    content: balance.toString()
                  });
                }
                // Call the token contract for the metadata URL
                const tx = {
                  to: this.provider.formatter.address(comps[0]),
                  data: hexConcat([selector, tokenId])
                };
                let metadataUrl = _parseString(yield this.provider.call(tx), 0);
                if (metadataUrl == null) {
                  return null;
                }
                linkage.push({
                  type: "metadata-url-base",
                  content: metadataUrl
                });
                // ERC-1155 allows a generic {id} in the URL
                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                  linkage.push({
                    type: "metadata-url-expanded",
                    content: metadataUrl
                  });
                }
                // Transform IPFS metadata links
                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }
                linkage.push({
                  type: "metadata-url",
                  content: metadataUrl
                });
                // Get the token metadata
                const metadata = yield fetchJson(metadataUrl);
                if (!metadata) {
                  return null;
                }
                linkage.push({
                  type: "metadata",
                  content: JSON.stringify(metadata)
                });
                // Pull the image URL out
                let imageUrl = metadata.image;
                if (typeof imageUrl !== "string") {
                  return null;
                }
                if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                  // Allow
                } else {
                  // Transform IPFS link to gateway
                  const ipfs = imageUrl.match(matcherIpfs);
                  if (ipfs == null) {
                    return null;
                  }
                  linkage.push({
                    type: "url-ipfs",
                    content: imageUrl
                  });
                  imageUrl = getIpfsLink(imageUrl);
                }
                linkage.push({
                  type: "url",
                  content: imageUrl
                });
                return {
                  linkage,
                  url: imageUrl
                };
              }
          }
        }
      } catch (error) {}
      return null;
    });
  }
  getContentHash() {
    return __awaiter$6(this, void 0, void 0, function* () {
      // keccak256("contenthash()")
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      // No contenthash
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      // IPFS (CID: 1, Type: DAG-PB)
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs:/\/" + Base58.encode("0x" + ipfs[1]);
        }
      }
      // IPNS (CID: 1, Type: libp2p-key)
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length = parseInt(ipns[3], 16);
        if (ipns[4].length === length * 2) {
          return "ipns:/\/" + Base58.encode("0x" + ipns[1]);
        }
      }
      // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz:/\/" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5
          const urlSafe = {
            "=": "",
            "+": "-",
            "/": "_"
          };
          const hash = encode$1("0x" + skynet[1]).replace(/[=+\/]/g, a => urlSafe[a]);
          return "sia:/\/" + hash;
        }
      }
      return logger$g.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key) {
    return __awaiter$6(this, void 0, void 0, function* () {
      // The key encoded as parameter to fetchBytes
      let keyBytes = toUtf8Bytes(key);
      // The nodehash consumes the first slot, so the string pointer targets
      // offset 64, with the length at offset 64 and data starting at offset 96
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      // Pad to word-size (32 bytes)
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    // Events being listened to
    this._events = [];
    this._emitted = {
      block: -2
    };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    // If network is any, this Provider allows the underlying
    // network to change dynamically, and we auto-detect the
    // current network
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      // Squash any "unhandled promise" errors; that do not need to be handled
      network.catch(error => {});
      // Trigger initial network setting (async)
      this._ready().catch(error => {});
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$g.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4000;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {}
        }
        // Try the Provider's network detection (this MUST throw if it cannot)
        if (network == null) {
          network = yield this.detectNetwork();
        }
        // This should never happen; every Provider sub-class should have
        // suggested a network by here (or have thrown).
        if (!network) {
          logger$g.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        // Possible this call stacked so do not call defineReadOnly again
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll(() => {
      return this._ready().then(network => {
        return network;
      }, error => {
        // If the network isn't running yet, we will wait
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return undefined;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        // URL expansion
        const href = url.replace("{sender}", sender).replace("{data}", data);
        // If no {data} is present, use POST; otherwise GET
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({
          data,
          sender
        });
        const result = yield fetchJson({
          url: href,
          errorPassThrough: true
        }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        // 4xx indicates the result is not present; stop
        if (result.status >= 400 && result.status < 500) {
          return logger$g.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, {
            url,
            errorMessage
          });
        }
        // 5xx indicates server issue; try the next url
        errorMessages.push(errorMessage);
      }
      return logger$g.throwError(`error encountered during CCIP fetch: ${errorMessages.map(m => JSON.stringify(m)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this._ready();
      // Allowing stale data up to maxAge old
      if (maxAge > 0) {
        // While there are pending internal block requests...
        while (this._internalBlockNumber) {
          // ..."remember" which fetch we started with
          const internalBlockNumber = this._internalBlockNumber;
          try {
            // Check the result is not too stale
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            // Too old; fetch a new value
            break;
          } catch (error) {
            // The fetch rejected; if we are the first to get the
            // rejection, drop through so we replace it with a new
            // fetch; all others blocked will then get that fetch
            // which won't match the one they "remembered" and loop
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then(network => null, error => error)
      }).then(({
        blockNumber,
        networkError
      }) => {
        if (networkError) {
          // Unremember this bad internal block number
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber); // @TODO: Still need this?
        return {
          blockNumber,
          reqTime,
          respTime
        };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      // Swallow unhandled exceptions; if needed they are handled else where
      checkInternalBlockNumber.catch(error => {
        // Don't null the dead (rejected) fetch, if it has already been updated
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      // Track all running promises, so we can trigger a post-poll once they are complete
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      // Emit a poll event after we have the latest (fast) block number
      this.emit("poll", pollId, blockNumber);
      // If the block has not changed, meh.
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      // First polling cycle, trigger a "block" events
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1000) {
        logger$g.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$g.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber: blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        // Notify all listener for each block that has passed
        for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
          this.emit("block", i);
        }
      }
      // The emitted block was updated, check for obsolete events
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach(key => {
          // The block event does not expire
          if (key === "block") {
            return;
          }
          // The block we were at when we emitted this event
          const eventBlockNumber = this._emitted[key];
          // We cannot garbage collect pending transactions or blocks here
          // They should be garbage collected by the Provider when setting
          // "pending" events
          if (eventBlockNumber === "pending") {
            return;
          }
          // Evict any transaction hashes or block hashes over 12 blocks
          // old, since they should not return null anyways
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key];
          }
        });
      }
      // First polling cycle
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      // Find all transaction hashes we are waiting on
      this._events.forEach(event => {
        switch (event.type) {
          case "tx":
            {
              const hash = event.hash;
              let runner = this.getTransactionReceipt(hash).then(receipt => {
                if (!receipt || receipt.blockNumber == null) {
                  return null;
                }
                this._emitted["t:" + hash] = receipt.blockNumber;
                this.emit(hash, receipt);
                return null;
              }).catch(error => {
                this.emit("error", error);
              });
              runners.push(runner);
              break;
            }
          case "filter":
            {
              // We only allow a single getLogs to be in-flight at a time
              if (!event._inflight) {
                event._inflight = true;
                // This is the first filter for this event, so we want to
                // restrict events to events that happened no earlier than now
                if (event._lastBlockNumber === -2) {
                  event._lastBlockNumber = blockNumber - 1;
                }
                // Filter from the last *known* event; due to load-balancing
                // and some nodes returning updated block numbers before
                // indexing events, a logs result with 0 entries cannot be
                // trusted and we must retry a range which includes it again
                const filter = event.filter;
                filter.fromBlock = event._lastBlockNumber + 1;
                filter.toBlock = blockNumber;
                // Prevent fitler ranges from growing too wild, since it is quite
                // likely there just haven't been any events to move the lastBlockNumber.
                const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
                if (minFromBlock > filter.fromBlock) {
                  filter.fromBlock = minFromBlock;
                }
                if (filter.fromBlock < 0) {
                  filter.fromBlock = 0;
                }
                const runner = this.getLogs(filter).then(logs => {
                  // Allow the next getLogs
                  event._inflight = false;
                  if (logs.length === 0) {
                    return;
                  }
                  logs.forEach(log => {
                    // Only when we get an event for a given block number
                    // can we trust the events are indexed
                    if (log.blockNumber > event._lastBlockNumber) {
                      event._lastBlockNumber = log.blockNumber;
                    }
                    // Make sure we stall requests to fetch blocks and txs
                    this._emitted["b:" + log.blockHash] = log.blockNumber;
                    this._emitted["t:" + log.transactionHash] = log.blockNumber;
                    this.emit(filter, log);
                  });
                }).catch(error => {
                  this.emit("error", error);
                  // Allow another getLogs (the range was not updated)
                  event._inflight = false;
                });
                runners.push(runner);
              }
              break;
            }
        }
      });
      this._lastBlockNumber = blockNumber;
      // Once all events for this loop have been processed, emit "didPoll"
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch(error => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter$6(this, void 0, void 0, function* () {
      return logger$g.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const network = yield this._ready();
      // Make sure we are still connected to the same network; this is
      // only an external call for backends which can have the underlying
      // network change spontaneously
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        // We are allowing network changes, things can get complex fast;
        // make sure you know what you are doing if you use "any"
        if (this.anyNetwork) {
          this._network = currentNetwork;
          // Reset all internal block number guards and caches
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          // The "network" event MUST happen before this method resolves
          // so any events have a chance to unregister, so we stall an
          // additional event loop before returning from /this/ call
          this.emit("network", currentNetwork, network);
          yield stall$1(0);
          return this._network;
        }
        const error = logger$g.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network: network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(blockNumber => {
      this._setFastBlockNumber(blockNumber);
    }, error => {});
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          // We block additional polls until the polling interval
          // is done, to prevent overwhelming the poll function
          this._bootstrapPoll = setTimeout(() => {
            // If polling was disabled, something may require a poke
            // since starting the bootstrap poll and it was disabled
            if (!this._poller) {
              this.poll();
            }
            // Clear out the bootstrap so we can do another
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now = getTime();
    // Stale block number, request a newer value
    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then(blockNumber => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    // Older block, maybe a stale request
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    // Update the time we updated the blocknumber
    this._fastQueryDate = getTime();
    // Newer block number, use  it
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      // Receipt is already good
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      // Poll until the receipt is good...
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function () {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach(func => {
            func();
          });
          return false;
        };
        const minedHandler = receipt => {
          if (receipt.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = blockNumber => __awaiter$6(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            // Wait 1 second; this is only used in the case of a fault, so
            // we will trade off a little bit of latency for more consistent
            // results and fewer JSON-RPC calls
            yield stall$1(1000);
            this.getTransactionCount(replaceable.from).then(nonce => __awaiter$6(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                // First check if the transaction was mined
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                // First time scanning. We start a little earlier for some
                // wiggle room here to handle the eventually consistent nature
                // of blockchain (e.g. the getTransactionCount was for a
                // different block)
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    // Successfully mined!
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    // Matches our transaction from and nonce; its a replacement
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      // Get the receipt of the replacement
                      const receipt = yield this.waitForTransaction(tx.hash, confirmations);
                      // Already resolved or rejected (prolly a timeout)
                      if (alreadyDone()) {
                        return;
                      }
                      // The reason we were replaced
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      // Explain why we were replaced
                      reject(logger$g.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), error => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$g.makeError("timeout exceeded", Logger.errors.TIMEOUT, {
              timeout: timeout
            }));
          }, timeout);
          if (timer.unref) {
            timer.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then(p => hexValue(p))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash, startBlock) {
    if (hash != null && hexDataLength(hash) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    // Check the hash we expect is the same as the hash the server reported
    if (hash != null && tx.hash !== hash) {
      logger$g.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, {
        expectedHash: tx.hash,
        returnedHash: hash
      });
    }
    result.wait = (confirms, timeout) => __awaiter$6(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      // Get the details to detect replacement
      let replacement = undefined;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      // No longer pending, allow the polling loop to garbage collect this
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$g.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt: receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash = yield this.perform("sendTransaction", {
          signedTransaction: hexTx
        });
        return this._wrapTransaction(tx, hash, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach(key => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then(v => v ? this._getAddress(v) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(key => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then(v => v ? BigNumber.from(v) : null);
      });
      ["type"].forEach(key => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then(v => v != null ? v : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach(key => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then(v => v ? hexlify(v) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter) {
    return __awaiter$6(this, void 0, void 0, function* () {
      filter = yield filter;
      const result = {};
      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }
      ["blockHash", "topics"].forEach(key => {
        if (filter[key] == null) {
          return;
        }
        result[key] = filter[key];
      });
      ["fromBlock", "toBlock"].forEach(key => {
        if (filter[key] == null) {
          return;
        }
        result[key] = this._getBlockTag(filter[key]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger$g.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", {
        transaction,
        blockTag
      });
      // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data = hexDataSlice(result, 4);
          // Check the sender of the OffchainLookup matches the transaction
          const sender = hexDataSlice(data, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger$g.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          // Read the URLs from the response
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data, urlsOffset + 32);
          for (let u = 0; u < urlsLength; u++) {
            const url = _parseString(urlsData, u * 32);
            if (url == null) {
              logger$g.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          // Get the CCIP calldata to forward
          const calldata = _parseBytes(data, 64);
          // Get the callbackSelector (bytes4)
          if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
            logger$g.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data, 96, 100);
          // Get the extra data to send back to the contract as context
          const extraData = _parseBytes(data, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger$g.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: {
            transaction,
            blockTag
          },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$g.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$6(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$g.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$g.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      // If blockTag is a number (not "latest", etc), this is the block number
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger$g.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        // Block was not found
        if (block == null) {
          // For blockhashes, if we didn't say it existed, that blockhash may
          // not exist. If we did see it though, perhaps from a log, we know
          // it exists, and this node is just not caught up yet.
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          // For block tags, if we are asking for a future block, we return null
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          // Retry on the next block
          return undefined;
        }
        // Add transactions
        if (includeTransactions) {
          let blockNumber = null;
          for (let i = 0; i < block.transactions.length; i++) {
            const tx = block.transactions[i];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber == null) {
                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              // Add the confirmations using the fast block number (pessimistic)
              let confirmations = blockNumber - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map(tx => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), {
        oncePoll: this
      });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = {
        transactionHash: this.formatter.hash(transactionHash, true)
      };
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return undefined;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          // Add the confirmations using the fast block number (pessimistic)
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), {
        oncePoll: this
      });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = {
        transactionHash: this.formatter.hash(transactionHash, true)
      };
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return undefined;
        }
        // "geth-etc" returns receipts before they are ready
        if (result.blockHash == null) {
          return undefined;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          // Add the confirmations using the fast block number (pessimistic)
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), {
        oncePoll: this
      });
    });
  }
  getLogs(filter) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        filter: this._getFilter(filter)
      });
      const logs = yield this.perform("getLogs", params);
      logs.forEach(log => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$g.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let currentName = name;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        // Optimization since the eth node cannot change and does
        // not have a wildcard resolver
        if (name !== "eth" && currentName === "eth") {
          return null;
        }
        // Check the current node for a resolver
        const addr = yield this._getResolver(currentName, "getResolver");
        // Found a resolver!
        if (addr != null) {
          const resolver = new Resolver(this, addr, name);
          // Legacy resolver found, using EIP-2544 so it isn't safe to use
          if (currentName !== name && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        // Get the parent node
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name, operation) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      // No ENS...
      if (!network.ensAddress) {
        logger$g.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, {
          operation,
          network: network.name
        });
      }
      try {
        // keccak256("resolver(bytes32)")
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
        // ENS registry cannot throw errors on resolver(bytes32)
      }
      return null;
    });
  }
  resolveName(name) {
    return __awaiter$6(this, void 0, void 0, function* () {
      name = yield name;
      // If it is already an address, nothing to resolve
      try {
        return Promise.resolve(this.formatter.address(name));
      } catch (error) {
        // If is is a hexstring, the address is bad (See #694)
        if (isHexString(name)) {
          throw error;
        }
      }
      if (typeof name !== "string") {
        logger$g.throwArgumentError("invalid ENS name", "name", name);
      }
      // Get the addr from the resolver
      const resolver = yield this.getResolver(name);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$6(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      // keccak("name(bytes32)")
      const name = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name);
      if (addr != address) {
        return null;
      }
      return name;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        // Address; reverse lookup
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        // Try resolving the avatar against the addr.reverse resolver
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar = yield resolver.getAvatar();
          if (avatar) {
            return avatar.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        // Try getting the name and performing forward lookup; allowing wildcards
        try {
          // keccak("name(bytes32)")
          const name = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        // ENS name; forward lookup with wildcard
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger$g.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, {
      operation: method
    });
  }
  _startEvent(event) {
    this.polling = this._events.filter(e => e.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter(e => e.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event$1(getEventTag(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter(event => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach(event => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter(event => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map(event => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter(event => event.tag === eventTag).map(event => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter(event => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach(event => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter(event => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach(event => {
      this._stopEvent(event);
    });
    return this;
  }
}

var __awaiter$5 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$f = new Logger(version$3);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  // These *are* the droids we're looking for.
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data = isHexString(value.data) ? value.data : null;
    if (!requireData || data) {
      return {
        message: value.message,
        data
      };
    }
  }
  // Spelunk further...
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunk(value[key], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  // Might be a JSON string we can further descend...
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {}
  }
  return null;
}
function checkError$1(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  // Undo the "convenience" some nodes are attempting to prevent backwards
  // incompatibility; maybe for v6 consider forwarding reverts as errors
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    // Nothing descriptive..
    logger$f.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    // Try to find something, with a preference on SERVER_ERROR body
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    // Found "reverted", this is a CALL_EXCEPTION
    if (result) {
      logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  // @TODO: Should we spelunk for message too?
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  // "insufficient funds for gas * price + value + cost(data)"
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger$f.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  // "nonce too low"
  if (message.match(/nonce (is )?too low/i)) {
    logger$f.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  // "replacement transaction underpriced"
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger$f.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  // "replacement transaction underpriced"
  if (message.match(/only replay-protected/i)) {
    logger$f.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function (resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult$1(payload) {
  if (payload.error) {
    // @TODO: not any
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$f.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger$f.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then(accounts => {
      if (accounts.length <= this._index) {
        logger$f.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then(address => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
    // wishes to use this, it is easy to specify explicitly, otherwise
    // we look it up for them.
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then(to => __awaiter$5(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$f.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({
      tx,
      sender
    }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$f.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, {
        from: true
      });
      return this.provider.send("eth_sendTransaction", [hexTx]).then(hash => {
        return hash;
      }, error => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$f.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError$1("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger$f.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      // This cannot be mined any earlier than any recent block
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      // Send the transaction
      const hash = yield this.sendUncheckedTransaction(transaction);
      try {
        // Unfortunately, JSON-RPC only provides and opaque transaction hash
        // for a response, and we need the actual transaction, so we poll
        // for it; it should show up very quickly
        return yield poll(() => __awaiter$5(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash);
          if (tx === null) {
            return undefined;
          }
          return this.provider._wrapTransaction(tx, hash, blockNumber);
        }), {
          oncePoll: this.provider
        });
      } catch (error) {
        error.transactionHash = hash;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter$5(this, void 0, void 0, function* () {
      // Populate any ENS names (in-place)
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, name => {
        return this.provider.resolveName(name);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [address.toLowerCase(), JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$f.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: {
              domain: populated.domain,
              types,
              value: populated.value
            }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then(hash => {
      return {
        hash: hash,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: confirmations => {
          return this.provider.waitForTransaction(hash, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    // The network is unknown, query the JSON-RPC for it
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(network => {
            resolve(network);
          }, error => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    // Default URL
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url: url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http:/\/localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      // Clear this cache at the beginning of the next event loop
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error) {}
      }
      if (chainId != null) {
        const getNetwork = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger$f.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId: chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger$f.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then(accounts => {
      return accounts.map(a => this.formatter.address(a));
    });
  }
  send(method, params) {
    const request = {
      method: method,
      params: params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    // We can expand this in the future to any call, but for now these
    // are the biggest wins and do not require any serializing parameters.
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult$1).then(result => {
      this.emit("debug", {
        action: "response",
        request: request,
        response: result,
        provider: this
      });
      return result;
    }, error => {
      this.emit("debug", {
        action: "response",
        error: error,
        request: request,
        provider: this
      });
      throw error;
    });
    // Cache the fetch, but clear it on the next event loop
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call":
        {
          const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
          return ["eth_call", [hexlifyTransaction(params.transaction, {
            from: true
          }), params.blockTag]];
        }
      case "estimateGas":
        {
          const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
          return ["eth_estimateGas", [hexlifyTransaction(params.transaction, {
            from: true
          })]];
        }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter$5(this, void 0, void 0, function* () {
      // Legacy networks do not like the type field being passed along (which
      // is fair), so we delete type if it is 0 and a non-EIP-1559 network
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          // If there are no EIP-1559 properties, it might be non-EIP-1559
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              // Network doesn't know about EIP-1559 (and hence type)
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$f.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, {
          operation: method
        });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError$1(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function (filterId) {
      function poll() {
        self.send("eth_getFilterChanges", [filterId]).then(function (hashes) {
          if (self._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function (hash) {
            // @TODO: This should be garbage collected at some point... How? When?
            self._emitted["t:" + hash.toLowerCase()] = "pending";
            seq = seq.then(function () {
              return self.getTransaction(hash).then(function (tx) {
                self.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function () {
            return timer(1000);
          });
        }).then(function () {
          if (self._pendingFilter != pendingFilter) {
            self.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function () {
            poll();
          }, 0);
          return null;
        }).catch(error => {});
      }
      poll();
      return filterId;
    }).catch(error => {});
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    // Check only allowed properties are given
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key in allowExtra) {
        if (allowExtra[key]) {
          allowed[key] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    // JSON-RPC now requires numeric values to be "quantity" values
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
      if (transaction[key] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key]));
      if (key === "gasLimit") {
        key = "gas";
      }
      result[key] = value;
    });
    ["from", "to", "data"].forEach(function (key) {
      if (transaction[key] == null) {
        return;
      }
      result[key] = hexlify(transaction[key]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
}

let WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger = new Logger(version$3);
  WS = function () {
    logger.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

var __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$e = new Logger(version$3);
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */
let NextId = 1;
// For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub
class WebSocketProvider extends JsonRpcProvider {
  constructor(url, network) {
    // This will be added in the future; please open an issue to expedite
    if (network === "any") {
      logger$e.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      defineReadOnly(this, "_websocket", new WS(this.connection.url));
    } else {
      defineReadOnly(this, "_websocket", url);
    }
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    // Stall sending requests until the socket is open...
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach(id => {
        this.websocket.send(this._requests[id].payload);
      });
    };
    this.websocket.onmessage = messageEvent => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id = String(result.id);
        const request = this._requests[id];
        delete this._requests[id];
        if (result.result !== undefined) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, undefined);
          this.emit("debug", {
            action: "response",
            error: error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        // Subscription...
        const sub = this._subs[result.params.subscription];
        if (sub) {
          //this.emit.apply(this,                  );
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    // This Provider does not actually poll, but we want to trigger
    // poll events for things that depend on them (like stalling for
    // block and transaction lookups)
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1000);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  // Cannot narrow the type of _websocket, as that is not backwards compatible
  // so we add a getter and let the WebSocket be a public API.
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger$e.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger$e.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter$4(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger$e.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method: method,
        params: params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = {
        callback,
        payload
      };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws:/\/localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then(param => {
          return this.send("eth_subscribe", param);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = {
        tag,
        processFunc
      };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], result => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], result => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], result => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx":
        {
          const emitReceipt = event => {
            const hash = event.hash;
            this.getTransactionReceipt(hash).then(receipt => {
              if (!receipt) {
                return;
              }
              this.emit(hash, receipt);
            });
          };
          // In case it is already mined
          emitReceipt(event);
          // To keep things simple, we start up a single newHeads subscription
          // to keep an eye out for transactions we are watching for.
          // Starting a subscription for an event (i.e. "tx") that is already
          // running is (basically) a nop.
          this._subscribe("tx", ["newHeads"], result => {
            this._events.filter(e => e.type === "tx").forEach(emitReceipt);
          });
          break;
        }
      // Nothing is needed
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      // There are remaining transaction event listeners
      if (this._events.filter(e => e.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      // There are remaining event listeners
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then(subId => {
      if (!this._subs[subId]) {
        return;
      }
      delete this._subs[subId];
      this.send("eth_unsubscribe", [subId]);
    });
  }
  destroy() {
    return __awaiter$4(this, void 0, void 0, function* () {
      // Wait until we have connected before trying to disconnect
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise(resolve => {
          this.websocket.onopen = function () {
            resolve(true);
          };
          this.websocket.onerror = function () {
            resolve(false);
          };
        });
      }
      // Hangup
      // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
      this.websocket.close(1000);
    });
  }
}

var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$d = new Logger(version$3);
// A StaticJsonRpcProvider is useful when you *know* for certain that
// the backend will never change, as it never calls eth_chainId to
// verify its backend. However, if the backend does change, the effects
// are undefined and may include:
// - inconsistent results
// - locking up the UI
// - block skew warnings
// - wrong results
// If the network is not explicit (i.e. auto-detection is expected), the
// node MUST be running and available to respond to requests BEFORE this
// is instantiated.
class StaticJsonRpcProvider extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: {
        get: () => super.detectNetwork
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger$d.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        // If still not set, set it
        if (this._network == null) {
          // A static network does not support "any"
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger$d.checkAbstract(new.target, UrlJsonRpcProvider);
    // Normalize the Network and API Key
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach(key => {
        defineReadOnly(this, key, apiKey[key]);
      });
    }
  }
  _startPending() {
    logger$d.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger$d.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "getSigner"
    });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  // Return a defaultApiKey if null, otherwise validate the API key
  static getApiKey(apiKey) {
    return apiKey;
  }
  // Returns the url or connection for the given network and API key. The
  // API key will have been sanitized by the getApiKey first, so any validation
  // or transformations can be done there.
  static getUrl(network, apiKey) {
    return logger$d.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
}

const logger$c = new Logger(version$3);
// This key was provided to ethers.js by Alchemy to be used by the
// default provider, but it is recommended that for your own
// production environments, that you acquire your own API key at:
//   https://dashboard.alchemyapi.io
const defaultApiKey$2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$2;
  }
}
class AlchemyProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey$2;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger$c.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        host = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        host = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger$c.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https:/" + "/" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey$2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$2;
  }
}

const logger$b = new Logger(version$3);
const defaultApiKey$1 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
  switch (name) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger$b.throwArgumentError("unsupported network", "name", name);
}
class AnkrProvider extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey$1;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey$1;
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey$1;
    }
    const connection = {
      allowGzip: true,
      url: "https:/\/" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey$1) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
}

var __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$a = new Logger(version$3);
class CloudflareProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger$a.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger$a.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: {
        get: () => super.perform
      }
    });
    return __awaiter$2(this, void 0, void 0, function* () {
      // The Cloudflare provider does not support eth_blockNumber,
      // so we get the latest block and pull it from that
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", {
          blockTag: "latest"
        });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
}

var __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$9 = new Logger(version$3);
// The transaction has already been sanitized by the calls in Provider
function getTransactionPostData(transaction) {
  const result = {};
  for (let key in transaction) {
    if (transaction[key] == null) {
      continue;
    }
    let value = transaction[key];
    if (key === "type" && value === 0) {
      continue;
    }
    // Quantity-types require no leading zero, unless 0
    if ({
      type: true,
      gasLimit: true,
      gasPrice: true,
      maxFeePerGs: true,
      maxPriorityFeePerGas: true,
      nonce: true,
      value: true
    }[key]) {
      value = hexValue(hexlify(value));
    } else if (key === "accessList") {
      value = "[" + accessListify(value).map(set => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key] = value;
  }
  return result;
}
function getResult(result) {
  // getLogs, getHistory have weird success responses
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  // This response indicates we are being throttled
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    // @TODO: not any
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    // @TODO: not any
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
// The blockTag was normalized as a string by the Provider pre-perform operations
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
function checkError(method, error, transaction) {
  // Undo the "convenience" some nodes are attempting to prevent backwards
  // incompatibility; maybe for v6 consider forwarding reverts as errors
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e = error.error;
    // Etherscan keeps changing their string
    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      // Etherscan prefixes the data like "Reverted 0x1234"
      let data = e.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString(data)) {
        return data;
      }
      logger$9.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  // Get the message from any nested error structure
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"
  if (message.match(/insufficient funds/)) {
    logger$9.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  // "Transaction with the same hash was already imported."
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger$9.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."
  if (message.match(/another transaction with same nonce/)) {
    logger$9.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger$9.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
class EtherscanProvider extends BaseProvider {
  constructor(network, apiKey) {
    super(network);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https:/\/api.etherscan.io";
      case "goerli":
        return "https:/\/api-goerli.etherscan.io";
      case "sepolia":
        return "https:/\/api-sepolia.etherscan.io";
      case "matic":
        return "https:/\/api.polygonscan.com";
      case "maticmum":
        return "https:/\/api-testnet.polygonscan.com";
      case "arbitrum":
        return "https:/\/api.arbiscan.io";
      case "arbitrum-goerli":
        return "https:/\/api-goerli.arbiscan.io";
      case "optimism":
        return "https:/\/api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https:/\/api-goerli-optimistic.etherscan.io";
    }
    return logger$9.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url: url,
        throttleSlotInterval: 1000,
        throttleCallback: (attempt, url) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = {
          "content-type": "application/x-www-form-urlencoded; charset=UTF-8"
        };
        payloadStr = Object.keys(payload).map(key => {
          return `${key}=${payload[key]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: {
        get: () => super.perform
      }
    });
    return __awaiter$1(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", {
            action: "eth_blockNumber"
          });
        case "getGasPrice":
          return this.fetch("proxy", {
            action: "eth_gasPrice"
          });
        case "getBalance":
          // Returns base-10 result
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch(error => {
            return checkError("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call":
          {
            if (params.blockTag !== "latest") {
              throw new Error("EtherscanProvider does not support blockTag for call");
            }
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_call";
            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError("call", error, params.transaction);
            }
          }
        case "estimateGas":
          {
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_estimateGas";
            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError("estimateGas", error, params.transaction);
            }
          }
        case "getLogs":
          {
            const args = {
              action: "getLogs"
            };
            if (params.filter.fromBlock) {
              args.fromBlock = checkLogTag(params.filter.fromBlock);
            }
            if (params.filter.toBlock) {
              args.toBlock = checkLogTag(params.filter.toBlock);
            }
            if (params.filter.address) {
              args.address = params.filter.address;
            }
            // @TODO: We can handle slightly more complicated logs using the logs API
            if (params.filter.topics && params.filter.topics.length > 0) {
              if (params.filter.topics.length > 1) {
                logger$9.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, {
                  topics: params.filter.topics
                });
              }
              if (params.filter.topics.length === 1) {
                const topic0 = params.filter.topics[0];
                if (typeof topic0 !== "string" || topic0.length !== 66) {
                  logger$9.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, {
                    topic0: topic0
                  });
                }
                args.topic0 = topic0;
              }
            }
            const logs = yield this.fetch("logs", args);
            // Cache txHash => blockHash
            let blocks = {};
            // Add any missing blockHash to the logs
            for (let i = 0; i < logs.length; i++) {
              const log = logs[i];
              if (log.blockHash != null) {
                continue;
              }
              if (blocks[log.blockNumber] == null) {
                const block = yield this.getBlock(log.blockNumber);
                if (block) {
                  blocks[log.blockNumber] = block.hash;
                }
              }
              log.blockHash = blocks[log.blockNumber];
            }
            return logs;
          }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0.0;
          }
          return parseFloat((yield this.fetch("stats", {
            action: "ethprice"
          })).ethusd);
      }
      return _super.perform.call(this, method, params);
    });
  }
  // Note: The `page` page parameter only allows pagination within the
  //       10,000 window available without a page and offset parameter
  //       Error: Result window is too large, PageNo x Offset size must
  //              be less than or equal to 10000
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map(tx => {
        ["contractAddress", "to"].forEach(function (key) {
          if (tx[key] == "") {
            delete tx[key];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$8 = new Logger(version$3);
function now() {
  return new Date().getTime();
}
// Returns to network as long as all agree, or null if any is null.
// Throws an error if any two networks do not match.
function checkNetworks(networks) {
  let result = null;
  for (let i = 0; i < networks.length; i++) {
    const network = networks[i];
    // Null! We do not know our network; bail.
    if (network == null) {
      return null;
    }
    if (result) {
      // Make sure the network matches the previous networks
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger$8.throwArgumentError("provider mismatch", "networks", networks);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  // Odd length; take the middle
  if (values.length % 2) {
    return values[middle];
  }
  // Even length; take the average of the two middle
  const a = values[middle - 1],
    b = values[middle];
  if (maxDelta != null && Math.abs(a - b) > maxDelta) {
    return null;
  }
  return (a + b) / 2;
}
function serialize(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map(i => serialize(i)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map(key => {
      let v = value[key];
      if (typeof v === "function") {
        v = "[function]";
      } else {
        v = serialize(v);
      }
      return JSON.stringify(key) + ":" + v;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
// Next request ID to use for emitting debug info
let nextRid = 1;
function stall(duration) {
  let cancel = null;
  let timer = null;
  let promise = new Promise(resolve => {
    cancel = function () {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      resolve();
    };
    timer = setTimeout(cancel, duration);
  });
  const wait = func => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return {
    cancel,
    getPromise,
    wait
  };
}
const ForwardErrors = [Logger.errors.CALL_EXCEPTION, Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED, Logger.errors.UNPREDICTABLE_GAS_LIMIT];
const ForwardProperties = ["address", "args", "errorArgs", "errorSignature", "method", "transaction"];
function exposeDebugConfig(config, now) {
  const result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", {
    get: () => config.provider
  });
  if (config.start) {
    result.start = config.start;
  }
  if (now) {
    result.duration = now - config.start;
  }
  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize, quorum) {
  return function (configs) {
    // Count the votes for each result
    const tally = {};
    configs.forEach(c => {
      const value = normalize(c.result);
      if (!tally[value]) {
        tally[value] = {
          count: 0,
          result: c.result
        };
      }
      tally[value].count++;
    });
    // Check for a quorum on any given result
    const keys = Object.keys(tally);
    for (let i = 0; i < keys.length; i++) {
      const check = tally[keys[i]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    // No quroum
    return undefined;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize = serialize;
  switch (method) {
    case "getBlockNumber":
      // Return the median value, unless there is (median + 1) is also
      // present, in which case that is probably true and the median
      // is going to be stale soon. In the event of a malicious node,
      // the lie will be true soon enough.
      return function (configs) {
        const values = configs.map(c => c.result);
        // Get the median block number
        let blockNumber = median(configs.map(c => c.result), 2);
        if (blockNumber == null) {
          return undefined;
        }
        blockNumber = Math.ceil(blockNumber);
        // If the next block height is present, its prolly safe to use
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        // Don't ever roll back the blockNumber
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      // Return the middle (round index up) value, similar to median
      // but do not average even entries and choose the higher.
      // Malicious actors must compromise 50% of the nodes to lie.
      return function (configs) {
        const values = configs.map(c => c.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      // Returns the median price. Malicious actors must compromise at
      // least 50% of the nodes to lie (in a meaningful way).
      return function (configs) {
        return median(configs.map(c => c.result));
      };
    // No additional normalizing required; serialize is enough
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    // We drop the confirmations from transactions as it is approximate
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function (tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize(tx);
      };
      break;
    // We drop the confirmations from transactions as it is approximate
    case "getBlock":
      // We drop the confirmations from transactions as it is approximate
      if (params.includeTransactions) {
        normalize = function (block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map(tx => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize(block);
        };
      } else {
        normalize = function (block) {
          if (block == null) {
            return null;
          }
          return serialize(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  // Return the result if and only if the expected quorum is
  // satisfied and agreed upon for the final result.
  return normalizedTally(normalize, provider.quorum);
}
// If we are doing a blockTag query, we need to make sure the backend is
// caught up to the FallbackProvider, before sending a request to it.
function waitForSync(config, blockNumber) {
  return __awaiter(this, void 0, void 0, function* () {
    const provider = config.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function () {
          // We are synced
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          // We're done; just quit
          if (config.cancelled) {
            return resolve(null);
          }
          // Try again, next block
          return resolve(undefined);
        }, 0);
      });
    }, {
      oncePoll: provider
    });
  });
}
function getRunner(config, currentBlockNumber, method, params) {
  return __awaiter(this, void 0, void 0, function* () {
    let provider = config.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider[method](params.transaction, params.blockTag);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs":
        {
          let filter = params.filter;
          if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {
            provider = yield waitForSync(config, currentBlockNumber);
          }
          return provider.getLogs(filter);
        }
    }
    return logger$8.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method: method,
      params: params
    });
  });
}
class FallbackProvider extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger$8.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;
        const priority = 1;
        return Object.freeze({
          provider: configOrProvider,
          weight: 1,
          stallTimeout,
          priority
        });
      }
      const config = shallowCopy(configOrProvider);
      if (config.priority == null) {
        config.priority = 1;
      }
      if (config.stallTimeout == null) {
        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;
      }
      if (config.weight == null) {
        config.weight = 1;
      }
      const weight = config.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger$8.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config);
    });
    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger$8.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    // Are all providers' networks are known
    let networkOrReady = checkNetworks(providerConfigs.map(c => c.provider.network));
    // Not all networks are known; we must stall
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    // Preserve a copy, so we do not get mutated
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      const networks = yield Promise.all(this.providerConfigs.map(c => c.provider.getNetwork()));
      return checkNetworks(networks);
    });
  }
  perform(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      // Sending transactions is special; always broadcast it to all backends
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map(c => {
          return c.provider.sendTransaction(params.signedTransaction).then(result => {
            return result.hash;
          }, error => {
            return error;
          });
        }));
        // Any success is good enough (other errors are likely "already seen" errors
        for (let i = 0; i < results.length; i++) {
          const result = results[i];
          if (typeof result === "string") {
            return result;
          }
        }
        // They were all an error; pick the first error
        throw results[0];
      }
      // We need to make sure we are in sync with our backends, so we need
      // to know this before we can make a lot of calls
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      // Shuffle the providers and then sort them by their priority; we
      // shallowCopy them since we will store the result in them too
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a, b) => a.priority - b.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i = 0;
      let first = true;
      while (true) {
        const t0 = now();
        // Compute the inflight weight (exclude anything past)
        let inflightWeight = configs.filter(c => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0);
        // Start running enough to meet quorum
        while (inflightWeight < this.quorum && i < configs.length) {
          const config = configs[i++];
          const rid = nextRid++;
          config.start = now();
          config.staller = stall(config.stallTimeout);
          config.staller.wait(() => {
            config.staller = null;
          });
          config.runner = getRunner(config, currentBlockNumber, method, params).then(result => {
            config.done = true;
            config.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid: rid,
                backend: exposeDebugConfig(config, now()),
                request: {
                  method: method,
                  params: deepCopy(params)
                },
                provider: this
              });
            }
          }, error => {
            config.done = true;
            config.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid: rid,
                backend: exposeDebugConfig(config, now()),
                request: {
                  method: method,
                  params: deepCopy(params)
                },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid: rid,
              backend: exposeDebugConfig(config, null),
              request: {
                method: method,
                params: deepCopy(params)
              },
              provider: this
            });
          }
          inflightWeight += config.weight;
        }
        // Wait for anything meaningful to finish or stall out
        const waiting = [];
        configs.forEach(c => {
          if (c.done || !c.runner) {
            return;
          }
          waiting.push(c.runner);
          if (c.staller) {
            waiting.push(c.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        // Check the quorum and process the results; the process function
        // may additionally decide the quorum is not met
        const results = configs.filter(c => c.done && c.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== undefined) {
            // Shut down any stallers
            configs.forEach(c => {
              if (c.staller) {
                c.staller.cancel();
              }
              c.cancelled = true;
            });
            return result;
          }
          if (!first) {
            yield stall(100).getPromise();
          }
          first = false;
        }
        // No result, check for errors that should be forwarded
        const errors = configs.reduce((accum, c) => {
          if (!c.done || c.error == null) {
            return accum;
          }
          const code = c.error.code;
          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = {
                error: c.error,
                weight: 0
              };
            }
            accum[code].weight += c.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach(errorCode => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          // Shut down any stallers
          configs.forEach(c => {
            if (c.staller) {
              c.staller.cancel();
            }
            c.cancelled = true;
          });
          const e = tally.error;
          const props = {};
          ForwardProperties.forEach(name => {
            if (e[name] == null) {
              return;
            }
            props[name] = e[name];
          });
          logger$8.throwError(e.reason || e.message, errorCode, props);
        });
        // All configs have run to completion; we will never get more data
        if (configs.filter(c => !c.done).length === 0) {
          break;
        }
      }
      // Shut down any stallers; shouldn't be any
      configs.forEach(c => {
        if (c.staller) {
          c.staller.cancel();
        }
        c.cancelled = true;
      });
      return logger$8.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method: method,
        params: params,
        //results: configs.map((c) => c.result),
        //errors: configs.map((c) => c.error),
        results: configs.map(c => exposeDebugConfig(c)),
        provider: this
      });
    });
  }
}

const IpcProvider = null;

const logger$7 = new Logger(version$3);
const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger$7.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class InfuraProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger$7.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger$7.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "sepolia":
        host = "sepolia.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        host = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        host = "arbitrum-goerli.infura.io";
        break;
      default:
        logger$7.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https:/" + "/" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}

// Experimental
class JsonRpcBatchProvider extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method: method,
      params: params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = {
      request,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      // Schedule batch for next event loop + short duration
      this._pendingBatchAggregator = setTimeout(() => {
        // Get teh current batch and clear it, so new requests
        // go into the next batch
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        // Get the request as an array of requests
        const request = batch.map(inflight => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request)).then(result => {
          this.emit("debug", {
            action: "response",
            request: request,
            response: result,
            provider: this
          });
          // For each result, feed it to the correct Promise, depending
          // on whether it was a success or error
          batch.forEach((inflightRequest, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest.reject(error);
            } else {
              inflightRequest.resolve(payload.result);
            }
          });
        }, error => {
          this.emit("debug", {
            action: "response",
            error: error,
            request: request,
            provider: this
          });
          batch.forEach(inflightRequest => {
            inflightRequest.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
}

/* istanbul ignore file */
const logger$6 = new Logger(version$3);
// Special API key provided by Nodesmith for ethers.js
const defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger$6.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey;
  }
  static getUrl(network, apiKey) {
    logger$6.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger$6.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
}

const logger$5 = new Logger(version$3);
const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
class PocketProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: true,
      applicationSecretKey: null
    };
    // Parse applicationId and applicationSecretKey
    if (apiKey == null) {
      apiKeyObj.applicationId = defaultApplicationId;
    } else if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
    } else if (apiKey.applicationId) {
      apiKeyObj.applicationId = apiKey.applicationId;
    } else {
      logger$5.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        host = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        host = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        host = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger$5.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const url = `https:/\/${host}/v1/lb/${apiKey.applicationId}`;
    const connection = {
      headers: {},
      url
    };
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}

const logger$4 = new Logger(version$3);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function (method, params) {
    const request = {
      method: method,
      params: params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error = new Error(response.error.message);
          error.code = response.error.code;
          error.data = response.error.data;
          return reject(error);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function (method, params) {
    if (params == null) {
      params = [];
    }
    const request = {
      method,
      params
    };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then(response => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, error => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
class Web3Provider extends JsonRpcProvider {
  constructor(provider, network) {
    if (provider == null) {
      logger$4.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger$4.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}

const logger$3 = new Logger(version$3);
////////////////////////
// Helper Functions
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  // If passed a URL, figure out the right type of provider based on the scheme
  if (typeof network === "string") {
    // @TODO: Add support for IpcProvider; maybe if it ends in ".ipc"?
    // Handle http and ws (and their secure variants)
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(network);
        case "ws":
        case "wss":
          return new WebSocketProvider(network);
        default:
          logger$3.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n = getNetwork(network);
  if (!n || !n._defaultProvider) {
    logger$3.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network: network
    });
  }
  return n._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AlchemyProvider: AlchemyProvider,
    AlchemyWebSocketProvider: AlchemyWebSocketProvider,
    AnkrProvider: AnkrProvider,
    BaseProvider: BaseProvider,
    CloudflareProvider: CloudflareProvider,
    EtherscanProvider: EtherscanProvider,
    FallbackProvider: FallbackProvider,
    Formatter: Formatter,
    InfuraProvider: InfuraProvider,
    InfuraWebSocketProvider: InfuraWebSocketProvider,
    IpcProvider: IpcProvider,
    JsonRpcBatchProvider: JsonRpcBatchProvider,
    JsonRpcProvider: JsonRpcProvider,
    JsonRpcSigner: JsonRpcSigner,
    NodesmithProvider: NodesmithProvider,
    PocketProvider: PocketProvider,
    Provider: Provider,
    Resolver: Resolver,
    StaticJsonRpcProvider: StaticJsonRpcProvider,
    UrlJsonRpcProvider: UrlJsonRpcProvider,
    Web3Provider: Web3Provider,
    WebSocketProvider: WebSocketProvider,
    getDefaultProvider: getDefaultProvider,
    getNetwork: getNetwork,
    isCommunityResourcable: isCommunityResourcable,
    isCommunityResource: isCommunityResource,
    showThrottleMessage: showThrottleMessage
});

const version$2 = "solidity/5.7.0";

const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger$2 = new Logger(version$2);
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    //let signed = (match[1] === "int")
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger$2.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger$2.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger$2.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    if (count != value.length) {
      logger$2.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function (value) {
      result.push(_pack(baseType, value, true));
    });
    return concat(result);
  }
  return logger$2.throwArgumentError("invalid type", "type", type);
}
// @TODO: Array Enum
function pack(types, values) {
  if (types.length != values.length) {
    logger$2.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function (type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak256(types, values) {
  return keccak256$1(pack(types, values));
}
function sha256(types, values) {
  return sha256$1(pack(types, values));
}

var lib_esm$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    keccak256: keccak256,
    pack: pack,
    sha256: sha256
});

const version$1 = "units/5.7.0";

const logger$1 = new Logger(version$1);
const names = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
// Some environments have issues with RegEx that contain back-tracking, so we cannot
// use them.
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger$1.throwArgumentError("invalid value", "value", value);
  }
  // Make sure we have at least one whole digit (0 if none)
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  // Make sure we have at least 1 whole digit with no leading zeros
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger$1.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}

var lib_esm$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    commify: commify,
    formatEther: formatEther,
    formatUnits: formatUnits,
    parseEther: parseEther,
    parseUnits: parseUnits
});

var utils$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AbiCoder: AbiCoder,
    ConstructorFragment: ConstructorFragment,
    ErrorFragment: ErrorFragment,
    EventFragment: EventFragment,
    FormatTypes: FormatTypes,
    Fragment: Fragment,
    FunctionFragment: FunctionFragment,
    HDNode: HDNode,
    Indexed: Indexed,
    Interface: Interface,
    LogDescription: LogDescription,
    Logger: Logger,
    ParamType: ParamType,
    RLP: lib_esm$h,
    SigningKey: SigningKey,
    get SupportedAlgorithm () { return SupportedAlgorithm; },
    TransactionDescription: TransactionDescription,
    get TransactionTypes () { return TransactionTypes; },
    get UnicodeNormalizationForm () { return UnicodeNormalizationForm; },
    Utf8ErrorFuncs: Utf8ErrorFuncs,
    get Utf8ErrorReason () { return Utf8ErrorReason; },
    _TypedDataEncoder: TypedDataEncoder,
    _fetchData: _fetchData,
    _toEscapedUtf8String: _toEscapedUtf8String,
    accessListify: accessListify,
    arrayify: arrayify,
    base58: Base58,
    base64: lib_esm$e,
    checkProperties: checkProperties,
    checkResultErrors: checkResultErrors,
    commify: commify,
    computeAddress: computeAddress,
    computeHmac: computeHmac,
    computePublicKey: computePublicKey,
    concat: concat,
    deepCopy: deepCopy,
    defaultAbiCoder: defaultAbiCoder,
    defaultPath: defaultPath,
    defineReadOnly: defineReadOnly,
    dnsEncode: dnsEncode,
    entropyToMnemonic: entropyToMnemonic,
    fetchJson: fetchJson,
    formatBytes32String: formatBytes32String,
    formatEther: formatEther,
    formatUnits: formatUnits,
    getAccountPath: getAccountPath,
    getAddress: getAddress,
    getContractAddress: getContractAddress,
    getCreate2Address: getCreate2Address,
    getIcapAddress: getIcapAddress,
    getJsonWalletAddress: getJsonWalletAddress,
    getStatic: getStatic,
    hashMessage: hashMessage,
    hexConcat: hexConcat,
    hexDataLength: hexDataLength,
    hexDataSlice: hexDataSlice,
    hexStripZeros: hexStripZeros,
    hexValue: hexValue,
    hexZeroPad: hexZeroPad,
    hexlify: hexlify,
    id: id,
    isAddress: isAddress,
    isBytes: isBytes,
    isBytesLike: isBytesLike,
    isHexString: isHexString,
    isValidMnemonic: isValidMnemonic,
    isValidName: isValidName,
    joinSignature: joinSignature,
    keccak256: keccak256$1,
    mnemonicToEntropy: mnemonicToEntropy,
    mnemonicToSeed: mnemonicToSeed,
    namehash: namehash,
    nameprep: nameprep,
    parseBytes32String: parseBytes32String,
    parseEther: parseEther,
    parseTransaction: parse,
    parseUnits: parseUnits,
    poll: poll,
    randomBytes: randomBytes,
    recoverAddress: recoverAddress,
    recoverPublicKey: recoverPublicKey,
    resolveProperties: resolveProperties,
    ripemd160: ripemd160,
    serializeTransaction: serialize$1,
    sha256: sha256$1,
    sha512: sha512,
    shallowCopy: shallowCopy,
    shuffled: shuffled,
    solidityKeccak256: keccak256,
    solidityPack: pack,
    soliditySha256: sha256,
    splitSignature: splitSignature,
    stripZeros: stripZeros,
    toUtf8Bytes: toUtf8Bytes,
    toUtf8CodePoints: toUtf8CodePoints,
    toUtf8String: toUtf8String,
    verifyMessage: verifyMessage,
    verifyTypedData: verifyTypedData,
    zeroPad: zeroPad
});

const version = "ethers/5.7.2";

const logger = new Logger(version);

var ethers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BaseContract: BaseContract,
    BigNumber: BigNumber,
    Contract: Contract,
    ContractFactory: ContractFactory,
    FixedNumber: FixedNumber,
    Signer: Signer,
    VoidSigner: VoidSigner,
    Wallet: Wallet,
    Wordlist: Wordlist,
    constants: index$1,
    get errors () { return ErrorCode; },
    getDefaultProvider: getDefaultProvider,
    logger: logger,
    providers: index,
    utils: utils$1,
    version: version,
    wordlists: wordlists
});

try {
  const anyGlobal = window;
  if (anyGlobal._ethers == null) {
    anyGlobal._ethers = ethers;
  }
} catch (error) {}

var lib_esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BaseContract: BaseContract,
    BigNumber: BigNumber,
    Contract: Contract,
    ContractFactory: ContractFactory,
    FixedNumber: FixedNumber,
    Signer: Signer,
    VoidSigner: VoidSigner,
    Wallet: Wallet,
    Wordlist: Wordlist,
    constants: index$1,
    get errors () { return ErrorCode; },
    ethers: ethers,
    getDefaultProvider: getDefaultProvider,
    logger: logger,
    providers: index,
    utils: utils$1,
    version: version,
    wordlists: wordlists
});

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);
function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function () {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn) handler.call(self);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn) handler.call(self, arg1);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn) handler.call(self, arg1, arg2);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn) handler.call(self, arg1, arg2, arg3);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self, args) {
  if (isFn) handler.apply(self, args);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
  }
}
EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = type === 'error';
  events = this._events;
  if (events) doError = doError && events.error == null;else if (!doError) return false;
  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er) er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }
  handler = events[type];
  if (!handler) return false;
  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++) args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  events = this._events;
  if (!events) return this;
  list = events[type];
  if (!list) return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0) this._events = new EventHandlers();else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events;
  events = this._events;
  if (!events) return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }
  return this;
};
EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;
  if (!events) ret = [];else {
    evlistener = events[type];
    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--) copy[i] = arr[i];
  return copy;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

// Events being emitted by an eip-1193 provider
// See https://eips.ethereum.org/EIPS/eip-1193#events
const EthereumEvents = Object.freeze({
    CONNECT: 'connect',
    DISCONNECT: 'disconnect',
    CHAIN_CHANGED: 'chainChanged',
    ACCOUNTS_CHANGED: 'accountsChanged',
});
// Events emitted by the connectors,
// The InternalWeb3Provider of Moralis will listen to these
const ConnectorEvents = Object.freeze({
    CONNECT: 'connect',
    DISCONNECT: 'disconnect',
    CHAIN_CHANGED: 'chainChanged',
    ACCOUNT_CHANGED: 'accountChanged',
});

/**
 * Abstract connector to connect EIP-1193 providers to Moralis
 *
 * It should implement at least:
 * - activate()
 * - Emit ConnectorEvent.CHAIN_CHANGED when the chain has changed (if possible)
 * - Emit ConnectorEvent.ACCOUNT_CHANGED when the account has changed (if possible)
 * - type: a name to identify
 * - network: the network type that is used (eg. 'evm')
 */
class AbstractWeb3Connector extends EventEmitter {
    type = 'abstract';
    network = 'evm';
    account = null;
    chainId = null;
    provider;
    constructor() {
        super();
        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
        this.handleChainChanged = this.handleChainChanged.bind(this);
        this.handleConnect = this.handleConnect.bind(this);
        this.handleDisconnect = this.handleDisconnect.bind(this);
    }
    subscribeToEvents(provider) {
        if (provider && provider.on) {
            provider.on(EthereumEvents.CHAIN_CHANGED, this.handleChainChanged);
            provider.on(EthereumEvents.ACCOUNTS_CHANGED, this.handleAccountsChanged);
            provider.on(EthereumEvents.CONNECT, this.handleConnect);
            provider.on(EthereumEvents.DISCONNECT, this.handleDisconnect);
        }
    }
    unsubscribeToEvents(provider) {
        if (provider && provider.removeListener) {
            provider.removeListener(EthereumEvents.CHAIN_CHANGED, this.handleChainChanged);
            provider.removeListener(EthereumEvents.ACCOUNTS_CHANGED, this.handleAccountsChanged);
            provider.removeListener(EthereumEvents.CONNECT, this.handleConnect);
            provider.removeListener(EthereumEvents.DISCONNECT, this.handleDisconnect);
        }
    }
    /**
     * Activates the provider.
     * Should returns an object with:
     * - provider: A valid EIP-1193 provider
     * - chainId(optional): the chainId that has been connected to (in hex format)
     * - account(optional): the address that is connected to the provider
     */
    async activate() {
        throw new Error('Not implemented: activate()');
    }
    /**
     * Updates account and emit event, on EIP-1193 accountsChanged events
     */
    handleAccountsChanged(accounts) {
        const account = accounts && accounts[0] ? accounts[0].toLowerCase() : null;
        this.account = account;
        this.emit(ConnectorEvents.ACCOUNT_CHANGED, account);
    }
    /**
     * Updates chainId and emit event, on EIP-1193 accountsChanged events
     */
    handleChainChanged(chainId) {
        const newChainId = chainId;
        this.chainId = newChainId;
        this.emit(ConnectorEvents.CHAIN_CHANGED, newChainId);
    }
    handleConnect(connectInfo) {
        console.log('connected', connectInfo);
        this.emit(ConnectorEvents.CONNECT, connectInfo);
    }
    handleDisconnect(error) {
        this.emit(ConnectorEvents.DISCONNECT, error);
    }
    /**
     * Cleans all active listners, connections and stale references
     */
    async deactivate() {
        this.unsubscribeToEvents(this.provider);
        this.account = null;
        this.chainId = null;
    }
}
var AbstractWeb3Connector$1 = AbstractWeb3Connector;

var a = (n => (n.MissingApiKey = "MISSING_API_KEY", n.ModalNotReady = "MODAL_NOT_READY", n.MalformedResponse = "MALFORMED_RESPONSE", n.InvalidArgument = "INVALID_ARGUMENT", n.ExtensionNotInitialized = "EXTENSION_NOT_INITIALIZED", n.IncompatibleExtensions = "INCOMPATIBLE_EXTENSIONS", n))(a || {}),
  m$1 = (_ => (_.SyncWeb3Method = "SYNC_WEB3_METHOD", _.DuplicateIframe = "DUPLICATE_IFRAME", _.ReactNativeEndpointConfiguration = "REACT_NATIVE_ENDPOINT_CONFIGURATION", _.DeprecationNotice = "DEPRECATION_NOTICE", _))(m$1 || {}),
  p = (e => (e[e.ParseError = -32700] = "ParseError", e[e.InvalidRequest = -32600] = "InvalidRequest", e[e.MethodNotFound = -32601] = "MethodNotFound", e[e.InvalidParams = -32602] = "InvalidParams", e[e.InternalError = -32603] = "InternalError", e[e.MagicLinkFailedVerification = -1e4] = "MagicLinkFailedVerification", e[e.MagicLinkExpired = -10001] = "MagicLinkExpired", e[e.MagicLinkRateLimited = -10002] = "MagicLinkRateLimited", e[e.MagicLinkInvalidRedirectURL = -10006] = "MagicLinkInvalidRedirectURL", e[e.UserAlreadyLoggedIn = -10003] = "UserAlreadyLoggedIn", e[e.UpdateEmailFailed = -10004] = "UpdateEmailFailed", e[e.UserRequestEditEmail = -10005] = "UserRequestEditEmail", e[e.InactiveRecipient = -10010] = "InactiveRecipient", e[e.AccessDeniedToUser = -10011] = "AccessDeniedToUser", e))(p || {});
var u = (t => (t.LoginWithSms = "magic_auth_login_with_sms", t.LoginWithEmailOTP = "magic_auth_login_with_email_otp", t.LoginWithMagicLink = "magic_auth_login_with_magic_link", t.LoginWithCredential = "magic_auth_login_with_credential", t.GetIdToken = "magic_auth_get_id_token", t.GenerateIdToken = "magic_auth_generate_id_token", t.GetMetadata = "magic_auth_get_metadata", t.IsLoggedIn = "magic_auth_is_logged_in", t.Logout = "magic_auth_logout", t.UpdateEmail = "magic_auth_update_email", t.UserSettings = "magic_auth_settings", t.UserSettingsTestMode = "magic_auth_settings_testing_mode", t.LoginWithSmsTestMode = "magic_auth_login_with_sms_testing_mode", t.LoginWithEmailOTPTestMode = "magic_auth_login_with_email_otp_testing_mode", t.LoginWithMagicLinkTestMode = "magic_login_with_magic_link_testing_mode", t.LoginWithCredentialTestMode = "magic_auth_login_with_credential_testing_mode", t.GetIdTokenTestMode = "magic_auth_get_id_token_testing_mode", t.GenerateIdTokenTestMode = "magic_auth_generate_id_token_testing_mode", t.GetMetadataTestMode = "magic_auth_get_metadata_testing_mode", t.IsLoggedInTestMode = "magic_auth_is_logged_in_testing_mode", t.LogoutTestMode = "magic_auth_logout_testing_mode", t.UpdateEmailTestMode = "magic_auth_update_email_testing_mode", t.IntermediaryEvent = "magic_intermediary_event", t))(u || {});
var g$1 = (i => (i.MAGIC_HANDLE_RESPONSE = "MAGIC_HANDLE_RESPONSE", i.MAGIC_OVERLAY_READY = "MAGIC_OVERLAY_READY", i.MAGIC_SHOW_OVERLAY = "MAGIC_SHOW_OVERLAY", i.MAGIC_HIDE_OVERLAY = "MAGIC_HIDE_OVERLAY", i.MAGIC_HANDLE_EVENT = "MAGIC_HANDLE_EVENT", i))(g$1 || {}),
  o = (s => (s.MAGIC_HANDLE_REQUEST = "MAGIC_HANDLE_REQUEST", s))(o || {});
var l$1 = (s => (s.Harmony = "HARMONY", s))(l$1 || {});

var yt = Object.create;
var U = Object.defineProperty,
  Rt = Object.defineProperties,
  Tt = Object.getOwnPropertyDescriptor,
  vt = Object.getOwnPropertyDescriptors,
  xt = Object.getOwnPropertyNames,
  $e$1 = Object.getOwnPropertySymbols,
  It = Object.getPrototypeOf,
  Me = Object.prototype.hasOwnProperty,
  Pt = Object.prototype.propertyIsEnumerable;
var Ne = (t, e, n) => e in t ? U(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : t[e] = n,
  z = (t, e) => {
    for (var n in e || (e = {})) Me.call(e, n) && Ne(t, n, e[n]);
    if ($e$1) for (var n of $e$1(e)) Pt.call(e, n) && Ne(t, n, e[n]);
    return t;
  },
  we = (t, e) => Rt(t, vt(e)),
  bt = t => U(t, "__esModule", {
    value: !0
  });
var $t = (t, e) => () => (e || t((e = {
    exports: {}
  }).exports, e), e.exports),
  Mt = (t, e) => {
    for (var n in e) U(t, n, {
      get: e[n],
      enumerable: !0
    });
  },
  Nt = (t, e, n, r) => {
    if (e && typeof e == "object" || typeof e == "function") for (let s of xt(e)) !Me.call(t, s) && (n || s !== "default") && U(t, s, {
      get: () => e[s],
      enumerable: !(r = Tt(e, s)) || r.enumerable
    });
    return t;
  },
  wt = (t, e) => Nt(bt(U(t != null ? yt(It(t)) : {}, "default", !e && t && t.__esModule ? {
    get: () => t.default,
    enumerable: !0
  } : {
    value: t,
    enumerable: !0
  })), t);
var I = (t, e, n) => new Promise((r, s) => {
  var o = c => {
      try {
        i(n.next(c));
      } catch (p) {
        s(p);
      }
    },
    a = c => {
      try {
        i(n.throw(c));
      } catch (p) {
        s(p);
      }
    },
    i = c => c.done ? r(c.value) : Promise.resolve(c.value).then(o, a);
  i((n = n.apply(t, e)).next());
});
var nt$1 = $t((gr, fe) => {

  var bn = Object.prototype.hasOwnProperty,
    T = "~";
  function B() {}
  Object.create && (B.prototype = Object.create(null), new B().__proto__ || (T = !1));
  function $n(t, e, n) {
    this.fn = t, this.context = e, this.once = n || !1;
  }
  function tt(t, e, n, r, s) {
    if (typeof n != "function") throw new TypeError("The listener must be a function");
    var o = new $n(n, r || t, s),
      a = T ? T + e : e;
    return t._events[a] ? t._events[a].fn ? t._events[a] = [t._events[a], o] : t._events[a].push(o) : (t._events[a] = o, t._eventsCount++), t;
  }
  function oe(t, e) {
    --t._eventsCount === 0 ? t._events = new B() : delete t._events[e];
  }
  function y() {
    this._events = new B(), this._eventsCount = 0;
  }
  y.prototype.eventNames = function () {
    var e = [],
      n,
      r;
    if (this._eventsCount === 0) return e;
    for (r in n = this._events) bn.call(n, r) && e.push(T ? r.slice(1) : r);
    return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(n)) : e;
  };
  y.prototype.listeners = function (e) {
    var n = T ? T + e : e,
      r = this._events[n];
    if (!r) return [];
    if (r.fn) return [r.fn];
    for (var s = 0, o = r.length, a = new Array(o); s < o; s++) a[s] = r[s].fn;
    return a;
  };
  y.prototype.listenerCount = function (e) {
    var n = T ? T + e : e,
      r = this._events[n];
    return r ? r.fn ? 1 : r.length : 0;
  };
  y.prototype.emit = function (e, n, r, s, o, a) {
    var i = T ? T + e : e;
    if (!this._events[i]) return !1;
    var c = this._events[i],
      p = arguments.length,
      l,
      u;
    if (c.fn) {
      switch (c.once && this.removeListener(e, c.fn, void 0, !0), p) {
        case 1:
          return c.fn.call(c.context), !0;
        case 2:
          return c.fn.call(c.context, n), !0;
        case 3:
          return c.fn.call(c.context, n, r), !0;
        case 4:
          return c.fn.call(c.context, n, r, s), !0;
        case 5:
          return c.fn.call(c.context, n, r, s, o), !0;
        case 6:
          return c.fn.call(c.context, n, r, s, o, a), !0;
      }
      for (u = 1, l = new Array(p - 1); u < p; u++) l[u - 1] = arguments[u];
      c.fn.apply(c.context, l);
    } else {
      var v = c.length,
        M;
      for (u = 0; u < v; u++) switch (c[u].once && this.removeListener(e, c[u].fn, void 0, !0), p) {
        case 1:
          c[u].fn.call(c[u].context);
          break;
        case 2:
          c[u].fn.call(c[u].context, n);
          break;
        case 3:
          c[u].fn.call(c[u].context, n, r);
          break;
        case 4:
          c[u].fn.call(c[u].context, n, r, s);
          break;
        default:
          if (!l) for (M = 1, l = new Array(p - 1); M < p; M++) l[M - 1] = arguments[M];
          c[u].fn.apply(c[u].context, l);
      }
    }
    return !0;
  };
  y.prototype.on = function (e, n, r) {
    return tt(this, e, n, r, !1);
  };
  y.prototype.once = function (e, n, r) {
    return tt(this, e, n, r, !0);
  };
  y.prototype.removeListener = function (e, n, r, s) {
    var o = T ? T + e : e;
    if (!this._events[o]) return this;
    if (!n) return oe(this, o), this;
    var a = this._events[o];
    if (a.fn) a.fn === n && (!s || a.once) && (!r || a.context === r) && oe(this, o);else {
      for (var i = 0, c = [], p = a.length; i < p; i++) (a[i].fn !== n || s && !a[i].once || r && a[i].context !== r) && c.push(a[i]);
      c.length ? this._events[o] = c.length === 1 ? c[0] : c : oe(this, o);
    }
    return this;
  };
  y.prototype.removeAllListeners = function (e) {
    var n;
    return e ? (n = T ? T + e : e, this._events[n] && oe(this, n)) : (this._events = new B(), this._eventsCount = 0), this;
  };
  y.prototype.off = y.prototype.removeListener;
  y.prototype.addListener = y.prototype.on;
  y.prefixed = T;
  y.EventEmitter = y;
  typeof fe != "undefined" && (fe.exports = y);
});
function At(t) {
  let e = {
    exports: {}
  };
  return t(e, e.exports), e.exports;
}
var Lt = Number.MAX_SAFE_INTEGER || 9007199254740991;
var me = {
    SEMVER_SPEC_VERSION: "2.0.0",
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: Lt,
    MAX_SAFE_COMPONENT_LENGTH: 16
  },
  St = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {},
  d = St,
  K = At(function (t, e) {
    let {
        MAX_SAFE_COMPONENT_LENGTH: n
      } = me,
      r = (e = t.exports = {}).re = [],
      s = e.src = [],
      o = e.t = {},
      a = 0,
      i = (c, p, l) => {
        let u = a++;
        d(u, p), o[c] = u, s[u] = p, r[u] = new RegExp(p, l ? "g" : void 0);
      };
    i("NUMERICIDENTIFIER", "0|[1-9]\\d*"), i("NUMERICIDENTIFIERLOOSE", "[0-9]+"), i("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), i("MAINVERSION", `(${s[o.NUMERICIDENTIFIER]})\\.(${s[o.NUMERICIDENTIFIER]})\\.(${s[o.NUMERICIDENTIFIER]})`), i("MAINVERSIONLOOSE", `(${s[o.NUMERICIDENTIFIERLOOSE]})\\.(${s[o.NUMERICIDENTIFIERLOOSE]})\\.(${s[o.NUMERICIDENTIFIERLOOSE]})`), i("PRERELEASEIDENTIFIER", `(?:${s[o.NUMERICIDENTIFIER]}|${s[o.NONNUMERICIDENTIFIER]})`), i("PRERELEASEIDENTIFIERLOOSE", `(?:${s[o.NUMERICIDENTIFIERLOOSE]}|${s[o.NONNUMERICIDENTIFIER]})`), i("PRERELEASE", `(?:-(${s[o.PRERELEASEIDENTIFIER]}(?:\\.${s[o.PRERELEASEIDENTIFIER]})*))`), i("PRERELEASELOOSE", `(?:-?(${s[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[o.PRERELEASEIDENTIFIERLOOSE]})*))`), i("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), i("BUILD", `(?:\\+(${s[o.BUILDIDENTIFIER]}(?:\\.${s[o.BUILDIDENTIFIER]})*))`), i("FULLPLAIN", `v?${s[o.MAINVERSION]}${s[o.PRERELEASE]}?${s[o.BUILD]}?`), i("FULL", `^${s[o.FULLPLAIN]}$`), i("LOOSEPLAIN", `[v=\\s]*${s[o.MAINVERSIONLOOSE]}${s[o.PRERELEASELOOSE]}?${s[o.BUILD]}?`), i("LOOSE", `^${s[o.LOOSEPLAIN]}$`), i("GTLT", "((?:<|>)?=?)"), i("XRANGEIDENTIFIERLOOSE", `${s[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), i("XRANGEIDENTIFIER", `${s[o.NUMERICIDENTIFIER]}|x|X|\\*`), i("XRANGEPLAIN", `[v=\\s]*(${s[o.XRANGEIDENTIFIER]})(?:\\.(${s[o.XRANGEIDENTIFIER]})(?:\\.(${s[o.XRANGEIDENTIFIER]})(?:${s[o.PRERELEASE]})?${s[o.BUILD]}?)?)?`), i("XRANGEPLAINLOOSE", `[v=\\s]*(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:${s[o.PRERELEASELOOSE]})?${s[o.BUILD]}?)?)?`), i("XRANGE", `^${s[o.GTLT]}\\s*${s[o.XRANGEPLAIN]}$`), i("XRANGELOOSE", `^${s[o.GTLT]}\\s*${s[o.XRANGEPLAINLOOSE]}$`), i("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), i("COERCERTL", s[o.COERCE], !0), i("LONETILDE", "(?:~>?)"), i("TILDETRIM", `(\\s*)${s[o.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", i("TILDE", `^${s[o.LONETILDE]}${s[o.XRANGEPLAIN]}$`), i("TILDELOOSE", `^${s[o.LONETILDE]}${s[o.XRANGEPLAINLOOSE]}$`), i("LONECARET", "(?:\\^)"), i("CARETTRIM", `(\\s*)${s[o.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", i("CARET", `^${s[o.LONECARET]}${s[o.XRANGEPLAIN]}$`), i("CARETLOOSE", `^${s[o.LONECARET]}${s[o.XRANGEPLAINLOOSE]}$`), i("COMPARATORLOOSE", `^${s[o.GTLT]}\\s*(${s[o.LOOSEPLAIN]})$|^$`), i("COMPARATOR", `^${s[o.GTLT]}\\s*(${s[o.FULLPLAIN]})$|^$`), i("COMPARATORTRIM", `(\\s*)${s[o.GTLT]}\\s*(${s[o.LOOSEPLAIN]}|${s[o.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", i("HYPHENRANGE", `^\\s*(${s[o.XRANGEPLAIN]})\\s+-\\s+(${s[o.XRANGEPLAIN]})\\s*$`), i("HYPHENRANGELOOSE", `^\\s*(${s[o.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[o.XRANGEPLAINLOOSE]})\\s*$`), i("STAR", "(<|>)?=?\\s*\\*"), i("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), i("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }),
  Ae = /^[0-9]+$/,
  Le = (t, e) => {
    let n = Ae.test(t),
      r = Ae.test(e);
    return n && r && (t = +t, e = +e), t === e ? 0 : n && !r ? -1 : r && !n ? 1 : t < e ? -1 : 1;
  },
  Ot = (t, e) => Le(e, t),
  Ct = {
    compareIdentifiers: Le,
    rcompareIdentifiers: Ot
  },
  {
    MAX_LENGTH: Se,
    MAX_SAFE_INTEGER: Y
  } = me,
  {
    re: Oe,
    t: Ce
  } = K,
  {
    compareIdentifiers: F
  } = Ct,
  h = class {
    constructor(e, n) {
      if (n && typeof n == "object" || (n = {
        loose: !!n,
        includePrerelease: !1
      }), e instanceof h) {
        if (e.loose === !!n.loose && e.includePrerelease === !!n.includePrerelease) return e;
        e = e.version;
      } else if (typeof e != "string") throw new TypeError(`Invalid Version: ${e}`);
      if (e.length > Se) throw new TypeError(`version is longer than ${Se} characters`);
      d("SemVer", e, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
      let r = e.trim().match(n.loose ? Oe[Ce.LOOSE] : Oe[Ce.FULL]);
      if (!r) throw new TypeError(`Invalid Version: ${e}`);
      if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > Y || this.major < 0) throw new TypeError("Invalid major version");
      if (this.minor > Y || this.minor < 0) throw new TypeError("Invalid minor version");
      if (this.patch > Y || this.patch < 0) throw new TypeError("Invalid patch version");
      r[4] ? this.prerelease = r[4].split(".").map(s => {
        if (/^[0-9]+$/.test(s)) {
          let o = +s;
          if (o >= 0 && o < Y) return o;
        }
        return s;
      }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e) {
      if (d("SemVer.compare", this.version, this.options, e), !(e instanceof h)) {
        if (typeof e == "string" && e === this.version) return 0;
        e = new h(e, this.options);
      }
      return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
    }
    compareMain(e) {
      return e instanceof h || (e = new h(e, this.options)), F(this.major, e.major) || F(this.minor, e.minor) || F(this.patch, e.patch);
    }
    comparePre(e) {
      if (e instanceof h || (e = new h(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
      if (!this.prerelease.length && e.prerelease.length) return 1;
      if (!this.prerelease.length && !e.prerelease.length) return 0;
      let n = 0;
      do {
        let r = this.prerelease[n],
          s = e.prerelease[n];
        if (d("prerelease compare", n, r, s), r === void 0 && s === void 0) return 0;
        if (s === void 0) return 1;
        if (r === void 0) return -1;
        if (r !== s) return F(r, s);
      } while (++n);
    }
    compareBuild(e) {
      e instanceof h || (e = new h(e, this.options));
      let n = 0;
      do {
        let r = this.build[n],
          s = e.build[n];
        if (d("prerelease compare", n, r, s), r === void 0 && s === void 0) return 0;
        if (s === void 0) return 1;
        if (r === void 0) return -1;
        if (r !== s) return F(r, s);
      } while (++n);
    }
    inc(e, n) {
      switch (e) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", n), this.inc("pre", n);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", n), this.inc("pre", n);
          break;
        case "major":
          this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) this.prerelease = [0];else {
            let r = this.prerelease.length;
            for (; --r >= 0;) typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
            r === -1 && this.prerelease.push(0);
          }
          n && (this.prerelease[0] === n ? isNaN(this.prerelease[1]) && (this.prerelease = [n, 0]) : this.prerelease = [n, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${e}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  },
  _t$1 = (t, e, n) => new h(t, n).compare(new h(e, n)),
  k = _t$1,
  Dt = (t, e, n) => k(t, e, n) === 0,
  kt = Dt,
  Jt = (t, e, n) => k(t, e, n) !== 0,
  qt = Jt,
  Gt = (t, e, n) => k(t, e, n) > 0,
  Ut = Gt,
  Kt = (t, e, n) => k(t, e, n) >= 0,
  Ft = Kt,
  jt = (t, e, n) => k(t, e, n) < 0,
  Wt = jt,
  Xt = (t, e, n) => k(t, e, n) <= 0,
  Bt = Xt,
  Ht = (t, e, n, r) => {
    switch (e) {
      case "===":
        return typeof t == "object" && (t = t.version), typeof n == "object" && (n = n.version), t === n;
      case "!==":
        return typeof t == "object" && (t = t.version), typeof n == "object" && (n = n.version), t !== n;
      case "":
      case "=":
      case "==":
        return kt(t, n, r);
      case "!=":
        return qt(t, n, r);
      case ">":
        return Ut(t, n, r);
      case ">=":
        return Ft(t, n, r);
      case "<":
        return Wt(t, n, r);
      case "<=":
        return Bt(t, n, r);
      default:
        throw new TypeError(`Invalid operator: ${e}`);
    }
  },
  Ee = Ht,
  j = Symbol("SemVer ANY"),
  O = class {
    static get ANY() {
      return j;
    }
    constructor(e, n) {
      if (n && typeof n == "object" || (n = {
        loose: !!n,
        includePrerelease: !1
      }), e instanceof O) {
        if (e.loose === !!n.loose) return e;
        e = e.value;
      }
      d("comparator", e, n), this.options = n, this.loose = !!n.loose, this.parse(e), this.semver === j ? this.value = "" : this.value = this.operator + this.semver.version, d("comp", this);
    }
    parse(e) {
      let n = this.options.loose ? _e[De$1.COMPARATORLOOSE] : _e[De$1.COMPARATOR],
        r = e.match(n);
      if (!r) throw new TypeError(`Invalid comparator: ${e}`);
      this.operator = r[1] !== void 0 ? r[1] : "", this.operator === "=" && (this.operator = ""), r[2] ? this.semver = new h(r[2], this.options.loose) : this.semver = j;
    }
    toString() {
      return this.value;
    }
    test(e) {
      if (d("Comparator.test", e, this.options.loose), this.semver === j || e === j) return !0;
      if (typeof e == "string") try {
        e = new h(e, this.options);
      } catch (n) {
        return !1;
      }
      return Ee(e, this.operator, this.semver, this.options);
    }
    intersects(e, n) {
      if (!(e instanceof O)) throw new TypeError("a Comparator is required");
      if (n && typeof n == "object" || (n = {
        loose: !!n,
        includePrerelease: !1
      }), this.operator === "") return this.value === "" || new N(e.value, n).test(this.value);
      if (e.operator === "") return e.value === "" || new N(this.value, n).test(e.semver);
      let r = !(this.operator !== ">=" && this.operator !== ">" || e.operator !== ">=" && e.operator !== ">"),
        s = !(this.operator !== "<=" && this.operator !== "<" || e.operator !== "<=" && e.operator !== "<"),
        o = this.semver.version === e.semver.version,
        a = !(this.operator !== ">=" && this.operator !== "<=" || e.operator !== ">=" && e.operator !== "<="),
        i = Ee(this.semver, "<", e.semver, n) && (this.operator === ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"),
        c = Ee(this.semver, ">", e.semver, n) && (this.operator === "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
      return r || s || o && a || i || c;
    }
  },
  {
    re: _e,
    t: De$1
  } = K,
  N = class {
    constructor(e, n) {
      if (n && typeof n == "object" || (n = {
        loose: !!n,
        includePrerelease: !1
      }), e instanceof N) return e.loose === !!n.loose && e.includePrerelease === !!n.includePrerelease ? e : new N(e.raw, n);
      if (e instanceof O) return this.raw = e.value, this.set = [[e]], this.format(), this;
      if (this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map(r => this.parseRange(r.trim())).filter(r => r.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${e}`);
      this.format();
    }
    format() {
      return this.range = this.set.map(e => e.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(e) {
      let {
        loose: n
      } = this.options;
      e = e.trim();
      let r = n ? g[f.HYPHENRANGELOOSE] : g[f.HYPHENRANGE];
      e = e.replace(r, cn(this.options.includePrerelease)), d("hyphen replace", e), e = e.replace(g[f.COMPARATORTRIM], Vt), d("comparator trim", e, g[f.COMPARATORTRIM]), e = (e = (e = e.replace(g[f.TILDETRIM], zt)).replace(g[f.CARETTRIM], Yt)).split(/\s+/).join(" ");
      let s = n ? g[f.COMPARATORLOOSE] : g[f.COMPARATOR];
      return e.split(" ").map(o => Zt(o, this.options)).join(" ").split(/\s+/).map(o => an(o, this.options)).filter(this.options.loose ? o => !!o.match(s) : () => !0).map(o => new O(o, this.options));
    }
    intersects(e, n) {
      if (!(e instanceof N)) throw new TypeError("a Range is required");
      return this.set.some(r => ke$1(r, n) && e.set.some(s => ke$1(s, n) && r.every(o => s.every(a => o.intersects(a, n)))));
    }
    test(e) {
      if (!e) return !1;
      if (typeof e == "string") try {
        e = new h(e, this.options);
      } catch (n) {
        return !1;
      }
      for (let n = 0; n < this.set.length; n++) if (ln(this.set[n], e, this.options)) return !0;
      return !1;
    }
  },
  {
    re: g,
    t: f,
    comparatorTrimReplace: Vt,
    tildeTrimReplace: zt,
    caretTrimReplace: Yt
  } = K,
  ke$1 = (t, e) => {
    let n = !0,
      r = t.slice(),
      s = r.pop();
    for (; n && r.length;) n = r.every(o => s.intersects(o, e)), s = r.pop();
    return n;
  },
  Zt = (t, e) => (d("comp", t, e), t = tn(t, e), d("caret", t), t = Qt(t, e), d("tildes", t), t = rn(t, e), d("xrange", t), t = on(t, e), d("stars", t), t),
  R = t => !t || t.toLowerCase() === "x" || t === "*",
  Qt = (t, e) => t.trim().split(/\s+/).map(n => en(n, e)).join(" "),
  en = (t, e) => {
    let n = e.loose ? g[f.TILDELOOSE] : g[f.TILDE];
    return t.replace(n, (r, s, o, a, i) => {
      let c;
      return d("tilde", t, r, s, o, a, i), R(s) ? c = "" : R(o) ? c = `>=${s}.0.0 <${+s + 1}.0.0-0` : R(a) ? c = `>=${s}.${o}.0 <${s}.${+o + 1}.0-0` : i ? (d("replaceTilde pr", i), c = `>=${s}.${o}.${a}-${i} <${s}.${+o + 1}.0-0`) : c = `>=${s}.${o}.${a} <${s}.${+o + 1}.0-0`, d("tilde return", c), c;
    });
  },
  tn = (t, e) => t.trim().split(/\s+/).map(n => nn(n, e)).join(" "),
  nn = (t, e) => {
    d("caret", t, e);
    let n = e.loose ? g[f.CARETLOOSE] : g[f.CARET],
      r = e.includePrerelease ? "-0" : "";
    return t.replace(n, (s, o, a, i, c) => {
      let p;
      return d("caret", t, s, o, a, i, c), R(o) ? p = "" : R(a) ? p = `>=${o}.0.0${r} <${+o + 1}.0.0-0` : R(i) ? p = o === "0" ? `>=${o}.${a}.0${r} <${o}.${+a + 1}.0-0` : `>=${o}.${a}.0${r} <${+o + 1}.0.0-0` : c ? (d("replaceCaret pr", c), p = o === "0" ? a === "0" ? `>=${o}.${a}.${i}-${c} <${o}.${a}.${+i + 1}-0` : `>=${o}.${a}.${i}-${c} <${o}.${+a + 1}.0-0` : `>=${o}.${a}.${i}-${c} <${+o + 1}.0.0-0`) : (d("no pr"), p = o === "0" ? a === "0" ? `>=${o}.${a}.${i}${r} <${o}.${a}.${+i + 1}-0` : `>=${o}.${a}.${i}${r} <${o}.${+a + 1}.0-0` : `>=${o}.${a}.${i} <${+o + 1}.0.0-0`), d("caret return", p), p;
    });
  },
  rn = (t, e) => (d("replaceXRanges", t, e), t.split(/\s+/).map(n => sn(n, e)).join(" ")),
  sn = (t, e) => {
    t = t.trim();
    let n = e.loose ? g[f.XRANGELOOSE] : g[f.XRANGE];
    return t.replace(n, (r, s, o, a, i, c) => {
      d("xRange", t, r, s, o, a, i, c);
      let p = R(o),
        l = p || R(a),
        u = l || R(i),
        v = u;
      return s === "=" && v && (s = ""), c = e.includePrerelease ? "-0" : "", p ? r = s === ">" || s === "<" ? "<0.0.0-0" : "*" : s && v ? (l && (a = 0), i = 0, s === ">" ? (s = ">=", l ? (o = +o + 1, a = 0, i = 0) : (a = +a + 1, i = 0)) : s === "<=" && (s = "<", l ? o = +o + 1 : a = +a + 1), s === "<" && (c = "-0"), r = `${s + o}.${a}.${i}${c}`) : l ? r = `>=${o}.0.0${c} <${+o + 1}.0.0-0` : u && (r = `>=${o}.${a}.0${c} <${o}.${+a + 1}.0-0`), d("xRange return", r), r;
    });
  },
  on = (t, e) => (d("replaceStars", t, e), t.trim().replace(g[f.STAR], "")),
  an = (t, e) => (d("replaceGTE0", t, e), t.trim().replace(g[e.includePrerelease ? f.GTE0PRE : f.GTE0], "")),
  cn = t => (e, n, r, s, o, a, i, c, p, l, u, v, M) => `${n = R(r) ? "" : R(s) ? `>=${r}.0.0${t ? "-0" : ""}` : R(o) ? `>=${r}.${s}.0${t ? "-0" : ""}` : a ? `>=${n}` : `>=${n}${t ? "-0" : ""}`} ${c = R(p) ? "" : R(l) ? `<${+p + 1}.0.0-0` : R(u) ? `<${p}.${+l + 1}.0-0` : v ? `<=${p}.${l}.${u}-${v}` : t ? `<${p}.${l}.${+u + 1}-0` : `<=${c}`}`.trim(),
  ln = (t, e, n) => {
    for (let r = 0; r < t.length; r++) if (!t[r].test(e)) return !1;
    if (e.prerelease.length && !n.includePrerelease) {
      for (let r = 0; r < t.length; r++) if (d(t[r].semver), t[r].semver !== O.ANY && t[r].semver.prerelease.length > 0) {
        let s = t[r].semver;
        if (s.major === e.major && s.minor === e.minor && s.patch === e.patch) return !0;
      }
      return !1;
    }
    return !0;
  },
  Je = (t, e, n) => {
    try {
      e = new N(e, n);
    } catch (r) {
      return !1;
    }
    return e.test(t);
  };
var {
    MAX_LENGTH: pn
  } = me,
  {
    re: qe,
    t: Ge
  } = K,
  un = (t, e) => {
    if (e && typeof e == "object" || (e = {
      loose: !!e,
      includePrerelease: !1
    }), t instanceof h) return t;
    if (typeof t != "string" || t.length > pn || !(e.loose ? qe[Ge.LOOSE] : qe[Ge.FULL]).test(t)) return null;
    try {
      return new h(t, e);
    } catch (n) {
      return null;
    }
  },
  dn = un,
  {
    re: Z,
    t: Q
  } = K,
  Ue = (t, e) => {
    if (t instanceof h) return t;
    if (typeof t == "number" && (t = String(t)), typeof t != "string") return null;
    let n = null;
    if ((e = e || {}).rtl) {
      let r;
      for (; (r = Z[Q.COERCERTL].exec(t)) && (!n || n.index + n[0].length !== t.length);) n && r.index + r[0].length === n.index + n[0].length || (n = r), Z[Q.COERCERTL].lastIndex = r.index + r[1].length + r[2].length;
      Z[Q.COERCERTL].lastIndex = -1;
    } else n = t.match(Z[Q.COERCE]);
    return n === null ? null : dn(`${n[2]}.${n[3] || "0"}.${n[4] || "0"}`, e);
  };
function mn(t) {
  return String.fromCharCode(parseInt(t.slice(1), 16));
}
function En(t) {
  return `%${`00${t.charCodeAt(0).toString(16)}`.slice(-2)}`;
}
function hn(t) {
  return btoa(encodeURIComponent(t).replace(/%[0-9A-F]{2}/g, mn));
}
function fn(t) {
  return decodeURIComponent(Array.from(atob(t), En).join(""));
}
function ee(t) {
  return hn(JSON.stringify(t));
}
function Ke(t) {
  return JSON.parse(fn(t));
}
function b(t) {
  return typeof t == "undefined";
}
function Rn(t) {
  return t === null;
}
function te(t) {
  return Rn(t) || b(t);
}
function Fe(t) {
  return te(t) ? !1 : !b(t.jsonrpc) && !b(t.id) && (!b(t.result) || !b(t.error));
}
function je(t) {
  return te(t) ? !1 : typeof t == "number" && Object.values(p).includes(t);
}
function ne(t) {
  if (!t) return !0;
  for (let e in t) if (Object.hasOwnProperty.call(t, e)) return !1;
  return !0;
}
var m = {};
function Tn(t, e) {
  return Object.assign(m, e), t;
}
var We = {
  "magic-sdk": "magic-sdk",
  "@magic-sdk/react-native-bare": "magic-sdk-rn-bare",
  "@magic-sdk/react-native-expo": "magic-sdk-rn-expo"
};
var $ = class extends Error {
    constructor(e, n) {
      super(`Magic SDK Error: [${e}] ${n}`);
      this.code = e;
      this.rawMessage = n;
      this.__proto__ = Error;
      Object.setPrototypeOf(this, $.prototype);
    }
  },
  w = class extends Error {
    constructor(e) {
      super();
      this.__proto__ = Error;
      let n = Number(e == null ? void 0 : e.code);
      this.rawMessage = (e == null ? void 0 : e.message) || "Internal error", this.code = je(n) ? n : p.InternalError, this.message = `Magic RPC Error: [${this.code}] ${this.rawMessage}`, Object.setPrototypeOf(this, w.prototype);
    }
  },
  W = class {
    constructor(e, n) {
      this.code = e;
      this.rawMessage = n;
      this.message = `Magic SDK Warning: [${e}] ${n}`;
    }
    log() {
      console.warn(this.message);
    }
  },
  X = class extends Error {
    constructor(e, n, r, s) {
      super(`Magic Extension Error (${e.name}): [${n}] ${r}`);
      this.code = n;
      this.rawMessage = r;
      this.data = s;
      this.__proto__ = Error;
      Object.setPrototypeOf(this, X.prototype);
    }
  },
  se$1 = class se {
    constructor(e, n, r) {
      this.code = n;
      this.rawMessage = r;
      this.message = `Magic Extension Warning (${e.name}): [${n}] ${r}`;
    }
    log() {
      console.warn(this.message);
    }
  };
function Xe() {
  return new $(a.MissingApiKey, "Please provide an API key that you acquired from the Magic developer dashboard.");
}
function lr() {
  return new $(a.ModalNotReady, "Modal is not ready.");
}
function Be$1() {
  return new $(a.MalformedResponse, "Response from the Magic iframe is malformed.");
}
function He(t) {
  return new $(a.ExtensionNotInitialized, `Extensions must be initialized with a Magic SDK instance before \`Extension.${t}\` can be accessed. Do not invoke \`Extension.${t}\` inside an extension constructor.`);
}
function Ve(t) {
  let e = `Some extensions are incompatible with \`${m.sdkName}@${m.version}\`:`;
  return t.filter(n => typeof n.compat != "undefined" && n.compat !== null).forEach(n => {
    let r = n.compat[m.sdkName];
    typeof r == "string" ? e += `
  - Extension \`${n.name}\` supports version(s) \`${r}\`` : r || (e += `
  - Extension \`${n.name}\` does not support ${m.platform} environments.`);
  }), new $(a.IncompatibleExtensions, e);
}
function ze(t) {
  let e = n => {
    let r = n + 1,
      s = r % 10,
      o = r % 100;
    return s === 1 && o !== 11 ? `${r}st` : s === 2 && o !== 12 ? `${r}nd` : s === 3 && o !== 13 ? `${r}rd` : `${r}th`;
  };
  return new $(a.InvalidArgument, `Invalid ${e(t.argument)} argument given to \`${t.procedure}\`.
  Expected: \`${t.expected}\`
  Received: \`${t.received}\``);
}
function pr() {
  return new W(m$1.DuplicateIframe, "Duplicate iframes found.");
}
function Ye() {
  return new W(m$1.SyncWeb3Method, "Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.");
}
function Ze$1() {
  return new W(m$1.ReactNativeEndpointConfiguration, `CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \`endpoint\` parameter SHOULD NOT be provided. The Magic \`<iframe>\` is automatically wrapped by a WebView pointed at \`${m.defaultEndpoint}\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`);
}
function* xn() {
  let t = 0;
  for (;;) t < Number.MAX_SAFE_INTEGER ? yield ++t : t = 0;
}
var In = xn();
function he() {
  return In.next().value;
}
var Qe = Symbol("Payload pre-processed by Magic SDK");
function et$1(t) {
  return Object.defineProperty(t, Qe, {
    value: !0,
    enumerable: !1
  }), t;
}
function Pn(t) {
  return !!t[Qe];
}
function C(t) {
  var e, n, r;
  return Pn(t) || (t.jsonrpc = (e = t.jsonrpc) != null ? e : "2.0", t.id = he(), t.method = (n = t.method) != null ? n : "noop", t.params = (r = t.params) != null ? r : [], et$1(t)), t;
}
function E(t, e = []) {
  return et$1({
    params: e,
    method: t,
    jsonrpc: "2.0",
    id: he()
  });
}
var _ = class {
  constructor(e) {
    e instanceof _ ? (this._jsonrpc = e.payload.jsonrpc, this._id = e.payload.id, this._result = e.payload.result, this._error = e.payload.error) : Fe(e) ? (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = e.result, this._error = e.error) : (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = void 0, this._error = void 0);
  }
  applyError(e) {
    return this._error = e, this;
  }
  applyResult(e) {
    return this._result = e, this;
  }
  get hasError() {
    return typeof this._error != "undefined" && this._error !== null;
  }
  get hasResult() {
    return typeof this._result != "undefined";
  }
  get payload() {
    return {
      jsonrpc: this._jsonrpc,
      id: this._id,
      result: this._result,
      error: this._error
    };
  }
};
var rt$1 = wt(nt$1()),
  st$1 = class st extends rt$1.default {};
function ie() {
  let t = new st$1();
  return {
    emitter: t,
    createChainingEmitterMethod: (r, s) => (...o) => (t[r].apply(t, o), s),
    createBoundEmitterMethod: r => (...s) => t[r].apply(t, s)
  };
}
var ot = Symbol("isPromiEvent");
function it(t) {
  return !!t[ot];
}
function ae(t) {
  let e = ge(t),
    {
      createBoundEmitterMethod: n,
      createChainingEmitterMethod: r
    } = ie(),
    s = Symbol("Promise.then"),
    o = Symbol("Promise.catch"),
    a = Symbol("Promise.finally"),
    i = (l, u) => (...v) => {
      let M = u[l].apply(u, v);
      return c(M);
    },
    c = l => Object.assign(l, {
      [ot]: !0,
      [s]: l[s] || l.then,
      [o]: l[o] || l.catch,
      [a]: l[a] || l.finally,
      then: i(s, l),
      catch: i(o, l),
      finally: i(a, l),
      on: r("on", l),
      once: r("once", l),
      addListener: r("addListener", l),
      off: r("off", l),
      removeListener: r("removeListener", l),
      removeAllListeners: r("removeAllListeners", l),
      emit: n("emit"),
      eventNames: n("eventNames"),
      listeners: n("listeners"),
      listenerCount: n("listenerCount")
    }),
    p = c(e.then(l => (p.emit("done", l), p.emit("settled"), l), l => {
      throw p.emit("error", l), p.emit("settled"), l;
    }));
  return p;
}
function ge(t) {
  return new Promise((e, n) => {
    let r = t(e, n);
    Promise.resolve(r).catch(n);
  });
}
var P = class {
  constructor(e) {
    this.sdk = e;
  }
  get overlay() {
    return this.sdk.overlay;
  }
  request(e) {
    let n = this.overlay.post(o.MAGIC_HANDLE_REQUEST, C(e)),
      r = ae((o, a) => {
        n.then(i => {
          if (s(), i.hasError) a(new w(i.payload.error));else if (i.hasResult) o(i.payload.result);else throw Be$1();
        }).catch(i => {
          s(), a(i);
        });
      }),
      s = this.overlay.on(g$1.MAGIC_HANDLE_EVENT, o => {
        var i;
        let {
          response: a
        } = o.data;
        if (a.id === e.id && ((i = a.result) == null ? void 0 : i.event)) {
          let {
            event: c,
            params: p = []
          } = a.result;
          r.emit(c, ...p);
        }
      });
    return r;
  }
  createIntermediaryEvent(e, n) {
    return s => {
      let o = E(u.IntermediaryEvent, [{
        payloadId: n,
        eventType: e,
        args: s
      }]);
      this.request(o);
    };
  }
};
var ye = class extends P {
  loginWithMagicLink(e) {
    let {
        email: n,
        showUI: r = !0,
        redirectURI: s
      } = e,
      o = E(this.sdk.testMode ? u.LoginWithMagicLinkTestMode : u.LoginWithMagicLink, [{
        email: n,
        showUI: r,
        redirectURI: s
      }]);
    return this.request(o);
  }
  loginWithSMS(e) {
    let {
        phoneNumber: n
      } = e,
      r = E(this.sdk.testMode ? u.LoginWithSmsTestMode : u.LoginWithSms, [{
        phoneNumber: n,
        showUI: !0
      }]);
    return this.request(r);
  }
  loginWithEmailOTP(e) {
    let {
        email: n
      } = e,
      r = E(this.sdk.testMode ? u.LoginWithEmailOTPTestMode : u.LoginWithEmailOTP, [{
        email: n,
        showUI: !0
      }]);
    return this.request(r);
  }
  loginWithCredential(e) {
    let n = e != null ? e : "";
    if (!e && m.platform === "web") {
      n = window.location.search;
      let s = window.location.origin + window.location.pathname;
      window.history.replaceState(null, "", s);
    }
    let r = E(this.sdk.testMode ? u.LoginWithCredentialTestMode : u.LoginWithCredential, [n]);
    return this.request(r);
  }
};
var H = {};
Mt(H, {
  clear: () => An,
  getItem: () => D,
  iterate: () => Cn,
  key: () => Sn,
  keys: () => On,
  length: () => Ln,
  removeItem: () => le,
  setItem: () => q
});
var ce;
function L(t) {
  return (...e) => I(this, null, function* () {
    return ce || (ce = yield m.configureStorage()), yield ce.ready(), ce[t](...e);
  });
}
var D = L("getItem"),
  q = L("setItem"),
  le = L("removeItem"),
  An = L("clear"),
  Ln = L("length"),
  Sn = L("key"),
  On = L("keys"),
  Cn = L("iterate");
function at() {
  let t = window.crypto.getRandomValues(new Uint8Array(16));
  t[6] = t[6] & 15 | 64, t[8] = t[8] & 191 | 128;
  let e = "";
  return e += t[0].toString(16), e += t[1].toString(16), e += t[2].toString(16), e += t[3].toString(16), e += "-", e += t[4].toString(16), e += t[5].toString(16), e += "-", e += t[6].toString(16), e += t[7].toString(16), e += "-", e += t[8].toString(16), e += t[9].toString(16), e += "-", e += t[10].toString(16), e += t[11].toString(16), e += t[12].toString(16), e += t[13].toString(16), e += t[14].toString(16), e += t[15].toString(16), e;
}
var Re = "STORE_KEY_PRIVATE_KEY",
  pe$1 = "STORE_KEY_PUBLIC_JWK",
  Te$1 = "ECDSA",
  ct = "P-256",
  _n = {
    name: Te$1,
    namedCurve: ct
  },
  Dn = {
    name: Te$1,
    namedCurve: ct
  };
function lt() {
  le(pe$1), le(Re);
}
function pt() {
  return I(this, null, function* () {
    let t = yield kn();
    if (!t) {
      console.info("unable to create public key or webcrypto is unsupported");
      return;
    }
    let {
        subtle: e
      } = window.crypto,
      n = yield D(Re);
    if (!n || !e) {
      console.info("unable to find private key or webcrypto unsupported");
      return;
    }
    let r = {
        iat: Math.floor(new Date().getTime() / 1e3),
        jti: at()
      },
      s = {
        typ: "dpop+jwt",
        alg: "ES256",
        jwk: t
      },
      o = {
        protected: ut$1(JSON.stringify(s)),
        claims: ut$1(JSON.stringify(r))
      },
      a = Gn(`${o.protected}.${o.claims}`),
      i = {
        name: Te$1,
        hash: {
          name: "SHA-256"
        }
      },
      c = Kn(new Uint8Array(yield e.sign(i, n, a)));
    return `${o.protected}.${o.claims}.${c}`;
  });
}
function kn() {
  return I(this, null, function* () {
    if (!qn()) {
      console.info("webcrypto is not supported");
      return;
    }
    return (yield D(pe$1)) || (yield Jn()), D(pe$1);
  });
}
function Jn() {
  return I(this, null, function* () {
    let t = null,
      {
        subtle: e
      } = window.crypto,
      n = yield e.generateKey(_n, !0, ["sign"]),
      r = yield e.exportKey("jwk", n.privateKey);
    t = yield e.exportKey("jwk", n.publicKey);
    let s = yield e.importKey("jwk", r, Dn, !1, ["sign"]);
    yield q(Re, s), yield q(pe$1, t);
  });
}
function qn() {
  let t = typeof window != "undefined" && !!window.crypto,
    e = t && !!window.crypto.subtle;
  return t && e;
}
function ut$1(t) {
  return dt(Un(t));
}
function Gn(t) {
  return new TextEncoder().encode(t);
}
function dt(t) {
  return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+/g, "");
}
function Un(t) {
  return encodeURIComponent(t).replace(/%([0-9A-F]{2})/g, (n, r) => String.fromCharCode(parseInt(r, 16)));
}
function Kn(t) {
  let e = "";
  return t.forEach(n => {
    e += String.fromCharCode(n);
  }), dt(e);
}
var ve$1 = class ve extends P {
  getIdToken(e) {
    let n = E(this.sdk.testMode ? u.GetIdTokenTestMode : u.GetIdToken, [e]);
    return this.request(n);
  }
  generateIdToken(e) {
    let n = E(this.sdk.testMode ? u.GenerateIdTokenTestMode : u.GenerateIdToken, [e]);
    return this.request(n);
  }
  getMetadata() {
    let e = E(this.sdk.testMode ? u.GetMetadataTestMode : u.GetMetadata);
    return this.request(e);
  }
  updateEmail(e) {
    let {
        email: n,
        showUI: r = !0
      } = e,
      s = E(this.sdk.testMode ? u.UpdateEmailTestMode : u.UpdateEmail, [{
        email: n,
        showUI: r
      }]);
    return this.request(s);
  }
  isLoggedIn() {
    let e = E(this.sdk.testMode ? u.IsLoggedInTestMode : u.IsLoggedIn);
    return this.request(e);
  }
  logout() {
    lt();
    let e = E(this.sdk.testMode ? u.LogoutTestMode : u.Logout);
    return this.request(e);
  }
  showSettings() {
    let e = E(this.sdk.testMode ? u.UserSettingsTestMode : u.UserSettings);
    return this.request(e);
  }
};
var {
    createBoundEmitterMethod: ue,
    createChainingEmitterMethod: G
  } = ie(),
  xe = class extends P {
    constructor() {
      super(...arguments);
      this.isMagic = !0;
      this.on = G("on", this);
      this.once = G("once", this);
      this.addListener = G("addListener", this);
      this.off = G("off", this);
      this.removeListener = G("removeListener", this);
      this.removeAllListeners = G("removeAllListeners", this);
      this.emit = ue("emit");
      this.eventNames = ue("eventNames");
      this.listeners = ue("listeners");
      this.listenerCount = ue("listenerCount");
    }
    sendAsync(e, n) {
      if (!n) throw ze({
        procedure: "Magic.rpcProvider.sendAsync",
        argument: 1,
        expected: "function",
        received: n === null ? "null" : typeof n
      });
      if (Array.isArray(e)) this.overlay.post(o.MAGIC_HANDLE_REQUEST, e.map(r => {
        let s = C(r);
        return this.prefixPayloadMethodForTestMode(s), s;
      })).then(r => {
        n(null, r.map(s => we(z({}, s.payload), {
          error: s.hasError ? new w(s.payload.error) : null
        })));
      });else {
        let r = C(e);
        this.prefixPayloadMethodForTestMode(r), this.overlay.post(o.MAGIC_HANDLE_REQUEST, r).then(s => {
          n(s.hasError ? new w(s.payload.error) : null, s.payload);
        });
      }
    }
    send(e, n) {
      if (typeof e == "string") {
        let s = E(e, Array.isArray(n) ? n : []);
        return this.request(s);
      }
      if (Array.isArray(e) || !!n) {
        this.sendAsync(e, n);
        return;
      }
      let r = Ye();
      return r.log(), new _(e).applyError({
        code: -32603,
        message: r.rawMessage
      }).payload;
    }
    enable() {
      let e = E("eth_accounts");
      return this.request(e);
    }
    request(e) {
      return this.prefixPayloadMethodForTestMode(e), super.request(e);
    }
    prefixPayloadMethodForTestMode(e) {
      let n = "testMode/eth/";
      this.sdk.testMode && (e.method = `${n}${e.method}`);
    }
  };
function Ie(t, e) {
  return e ? new URL(t, e) : new URL(t);
}
var Et = ["request", "overlay", "sdk"];
function Fn(t) {
  let e = Object.getPrototypeOf(t),
    n = [e];
  for (; e !== P.prototype;) e = Object.getPrototypeOf(e), n.push(e);
  return n;
}
var Pe = class extends P {
    constructor() {
      super(void 0);
      this.__sdk_access_field_descriptors__ = new Map();
      this.__is_initialized__ = !1;
      this.utils = {
        createPromiEvent: ae,
        isPromiEvent: it,
        encodeJSON: ee,
        decodeJSON: Ke,
        createJsonRpcRequestPayload: E,
        standardizeJsonRpcRequestPayload: C,
        storage: H
      };
      let e = [this, ...Fn(this)];
      Et.forEach(n => {
        let r = e.map(i => Object.getOwnPropertyDescriptor(i, n)),
          s = r.findIndex(i => !!i),
          o = s > 0,
          a = r[s];
        a && (this.__sdk_access_field_descriptors__.set(n, {
          descriptor: a,
          isPrototypeField: o
        }), Object.defineProperty(this, n, {
          configurable: !0,
          get: () => {
            throw He(n);
          }
        }));
      });
    }
    init(e) {
      this.__is_initialized__ || (Et.forEach(n => {
        if (this.__sdk_access_field_descriptors__.has(n)) {
          let {
            descriptor: r,
            isPrototypeField: s
          } = this.__sdk_access_field_descriptors__.get(n);
          s ? delete this[n] : Object.defineProperty(this, n, r);
        }
      }), this.sdk = e, this.__is_initialized__ = !0);
    }
    createDeprecationWarning(e) {
      let {
          method: n,
          removalVersion: r,
          useInstead: s
        } = e,
        o = s ? ` Use \`${s}\` instead.` : "",
        a = `\`${n}\` will be removed from this Extension in version \`${r}\`.${o}`;
      return new se$1(this, "DEPRECATION_NOTICE", a);
    }
    createWarning(e, n) {
      return new se$1(this, e, n);
    }
    createError(e, n, r) {
      return new X(this, e, n, r);
    }
  },
  ht = class extends Pe {},
  S = class extends Pe {};
S.Internal = ht, S.Anonymous = "anonymous extension";
function ft$1(t) {
  return t.compat && t.compat[m.sdkName] != null ? typeof t.compat[m.sdkName] == "string" ? Je(Ue(m.version), t.compat[m.sdkName]) : !!t.compat[m.sdkName] : !0;
}
function jn(t) {
  var s;
  let e = (s = t == null ? void 0 : t.extensions) != null ? s : [],
    n = {},
    r = [];
  if (Array.isArray(e) ? e.forEach(o => {
    ft$1(o) ? (o.init(this), (o.name || o.name !== S.Anonymous) && (this[o.name] = o), o instanceof S.Internal && (ne(o.config) || (n[o.name] = o.config))) : r.push(o);
  }) : Object.keys(e).forEach(o => {
    if (ft$1(e[o])) {
      e[o].init(this);
      let a = e[o];
      this[o] = a, a instanceof S.Internal && (ne(a.config) || (n[e[o].name] = a.config));
    } else r.push(e[o]);
  }), r.length) throw Ve(r);
  return n;
}
var V = class {
    constructor(e, n) {
      this.apiKey = e;
      var a;
      if (!e) throw Xe();
      m.platform === "react-native" && (n == null ? void 0 : n.endpoint) && Ze$1().log();
      let {
        defaultEndpoint: r,
        version: s
      } = m;
      this.testMode = !!(n == null ? void 0 : n.testMode), this.endpoint = Ie((a = n == null ? void 0 : n.endpoint) != null ? a : r).origin, this.auth = new ye(this), this.user = new ve$1(this), this.rpcProvider = new xe(this);
      let o = jn.call(this, n);
      this.parameters = ee(z({
        API_KEY: this.apiKey,
        DOMAIN_ORIGIN: window.location ? window.location.origin : "",
        ETH_NETWORK: n == null ? void 0 : n.network,
        host: Ie(this.endpoint).host,
        sdk: We[m.sdkName],
        version: s,
        ext: ne(o) ? void 0 : o,
        locale: (n == null ? void 0 : n.locale) || "en_US"
      }, m.bundleId ? {
        bundleId: m.bundleId
      } : {}));
    }
    get overlay() {
      if (!V.__overlays__.has(this.parameters)) {
        let e = new m.ViewController(this.endpoint, this.parameters);
        e.init(), V.__overlays__.set(this.parameters, e);
      }
      return V.__overlays__.get(this.parameters);
    }
    preload() {
      return I(this, null, function* () {
        yield this.overlay.ready;
      });
    }
  },
  be = V;
be.__overlays__ = new Map();
function Wn(t, e) {
  return e && Array.isArray(t) ? t.find(n => n.id === e) : t;
}
function Xn(t, e) {
  var s;
  let n = (s = e.data.response) == null ? void 0 : s.id,
    r = Wn(t, n);
  if (n && r) {
    let o = new _(r).applyResult(e.data.response.result).applyError(e.data.response.error);
    return {
      id: n,
      response: o
    };
  }
  return {};
}
function Bn(t, e) {
  return I(this, null, function* () {
    let n = yield D("rt"),
      r;
    if (m.platform === "web") try {
      r = yield pt();
    } catch (s) {
      console.error("webcrypto error", s);
    }
    return r ? n ? {
      msgType: t,
      payload: e,
      jwt: r,
      rt: n
    } : {
      msgType: t,
      payload: e,
      jwt: r
    } : {
      msgType: t,
      payload: e
    };
  });
}
function Hn(t) {
  return I(this, null, function* () {
    !t.data.rt || (yield q("rt", t.data.rt));
  });
}
var gt = class {
  constructor(e, n) {
    this.endpoint = e;
    this.parameters = n;
    this.messageHandlers = new Set();
    this.ready = this.waitForReady(), this.listen();
  }
  post(e, n) {
    return I(this, null, function* () {
      return ge(r => I(this, null, function* () {
        yield this.ready;
        let s = [],
          o = Array.isArray(n) ? n.map(p => p.id) : [],
          a = yield Bn(`${e}-${this.parameters}`, n);
        yield this._post(a);
        let i = p => l => {
            let {
              id: u,
              response: v
            } = Xn(n, l);
            Hn(l), u && v && Array.isArray(n) && o.includes(u) ? (s.push(v), s.length === n.length && (p(), r(s))) : u && v && !Array.isArray(n) && u === n.id && (p(), r(v));
          },
          c = this.on(g$1.MAGIC_HANDLE_RESPONSE, i(() => c()));
      }));
    });
  }
  on(e, n) {
    let r = n.bind(window),
      s = o => {
        o.data.msgType === `${e}-${this.parameters}` && r(o);
      };
    return this.messageHandlers.add(s), () => this.messageHandlers.delete(s);
  }
  waitForReady() {
    return new Promise(e => {
      this.on(g$1.MAGIC_OVERLAY_READY, () => e());
    });
  }
  listen() {
    this.on(g$1.MAGIC_HIDE_OVERLAY, () => {
      this.hideOverlay();
    }), this.on(g$1.MAGIC_SHOW_OVERLAY, () => {
      this.showOverlay();
    });
  }
};

var Zr = Object.create;
var De = Object.defineProperty;
var qr = Object.getOwnPropertyDescriptor;
var kr = Object.getOwnPropertyNames;
var et = Object.getPrototypeOf,
  rt = Object.prototype.hasOwnProperty;
var tt = p => De(p, "__esModule", {
  value: !0
});
var ve = (p => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(p, {
  get: (g, O) => (typeof require != "undefined" ? require : g)[O]
}) : p)(function (p) {
  if (typeof require != "undefined") return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + p + '" is not supported');
});
var $e = (p, g) => () => (g || p((g = {
  exports: {}
}).exports, g), g.exports);
var nt = (p, g, O, L) => {
    if (g && typeof g == "object" || typeof g == "function") for (let M of kr(g)) !rt.call(p, M) && (O || M !== "default") && De(p, M, {
      get: () => g[M],
      enumerable: !(L = qr(g, M)) || L.enumerable
    });
    return p;
  },
  Ze = (p, g) => nt(tt(De(p != null ? Zr(et(p)) : {}, "default", !g && p && p.__esModule ? {
    get: () => p.default,
    enumerable: !0
  } : {
    value: p,
    enumerable: !0
  })), p);
var se = (p, g, O) => new Promise((L, M) => {
  var Q = S => {
      try {
        Y(O.next(S));
      } catch (P) {
        M(P);
      }
    },
    C = S => {
      try {
        Y(O.throw(S));
      } catch (P) {
        M(P);
      }
    },
    Y = S => S.done ? L(S.value) : Promise.resolve(S.value).then(Q, C);
  Y((O = O.apply(p, g)).next());
});
var ke = $e((qe, Ne) => {
  (function (p) {
    if (typeof qe == "object" && typeof Ne != "undefined") Ne.exports = p();else if (typeof define == "function" && define.amd) define([], p);else {
      var g;
      typeof window != "undefined" ? g = window : typeof global != "undefined" ? g = global : typeof self != "undefined" ? g = self : g = this, g.localforage = p();
    }
  })(function () {
    return function L(M, Q, C) {
      function Y(K, Z) {
        if (!Q[K]) {
          if (!M[K]) {
            var m = typeof ve == "function" && ve;
            if (!Z && m) return m(K, !0);
            if (S) return S(K, !0);
            var w = new Error("Cannot find module '" + K + "'");
            throw w.code = "MODULE_NOT_FOUND", w;
          }
          var N = Q[K] = {
            exports: {}
          };
          M[K][0].call(N.exports, function (z) {
            var q = M[K][1][z];
            return Y(q || z);
          }, N, N.exports, L, M, Q, C);
        }
        return Q[K].exports;
      }
      for (var S = typeof ve == "function" && ve, P = 0; P < C.length; P++) Y(C[P]);
      return Y;
    }({
      1: [function (L, M, Q) {
        (function (C) {

          var Y = C.MutationObserver || C.WebKitMutationObserver,
            S;
          if (Y) {
            var P = 0,
              K = new Y(z),
              Z = C.document.createTextNode("");
            K.observe(Z, {
              characterData: !0
            }), S = function () {
              Z.data = P = ++P % 2;
            };
          } else if (!C.setImmediate && typeof C.MessageChannel != "undefined") {
            var m = new C.MessageChannel();
            m.port1.onmessage = z, S = function () {
              m.port2.postMessage(0);
            };
          } else "document" in C && "onreadystatechange" in C.document.createElement("script") ? S = function () {
            var F = C.document.createElement("script");
            F.onreadystatechange = function () {
              z(), F.onreadystatechange = null, F.parentNode.removeChild(F), F = null;
            }, C.document.documentElement.appendChild(F);
          } : S = function () {
            setTimeout(z, 0);
          };
          var w,
            N = [];
          function z() {
            w = !0;
            for (var F, k, U = N.length; U;) {
              for (k = N, N = [], F = -1; ++F < U;) k[F]();
              U = N.length;
            }
            w = !1;
          }
          M.exports = q;
          function q(F) {
            N.push(F) === 1 && !w && S();
          }
        }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
      }, {}],
      2: [function (L, M, Q) {

        var C = L(1);
        function Y() {}
        var S = {},
          P = ["REJECTED"],
          K = ["FULFILLED"],
          Z = ["PENDING"];
        M.exports = m;
        function m(h) {
          if (typeof h != "function") throw new TypeError("resolver must be a function");
          this.state = Z, this.queue = [], this.outcome = void 0, h !== Y && q(this, h);
        }
        m.prototype.catch = function (h) {
          return this.then(null, h);
        }, m.prototype.then = function (h, R) {
          if (typeof h != "function" && this.state === K || typeof R != "function" && this.state === P) return this;
          var I = new this.constructor(Y);
          if (this.state !== Z) {
            var B = this.state === K ? h : R;
            N(I, B, this.outcome);
          } else this.queue.push(new w(I, h, R));
          return I;
        };
        function w(h, R, I) {
          this.promise = h, typeof R == "function" && (this.onFulfilled = R, this.callFulfilled = this.otherCallFulfilled), typeof I == "function" && (this.onRejected = I, this.callRejected = this.otherCallRejected);
        }
        w.prototype.callFulfilled = function (h) {
          S.resolve(this.promise, h);
        }, w.prototype.otherCallFulfilled = function (h) {
          N(this.promise, this.onFulfilled, h);
        }, w.prototype.callRejected = function (h) {
          S.reject(this.promise, h);
        }, w.prototype.otherCallRejected = function (h) {
          N(this.promise, this.onRejected, h);
        };
        function N(h, R, I) {
          C(function () {
            var B;
            try {
              B = R(I);
            } catch (H) {
              return S.reject(h, H);
            }
            B === h ? S.reject(h, new TypeError("Cannot resolve promise with itself")) : S.resolve(h, B);
          });
        }
        S.resolve = function (h, R) {
          var I = F(z, R);
          if (I.status === "error") return S.reject(h, I.value);
          var B = I.value;
          if (B) q(h, B);else {
            h.state = K, h.outcome = R;
            for (var H = -1, j = h.queue.length; ++H < j;) h.queue[H].callFulfilled(R);
          }
          return h;
        }, S.reject = function (h, R) {
          h.state = P, h.outcome = R;
          for (var I = -1, B = h.queue.length; ++I < B;) h.queue[I].callRejected(R);
          return h;
        };
        function z(h) {
          var R = h && h.then;
          if (h && (typeof h == "object" || typeof h == "function") && typeof R == "function") return function () {
            R.apply(h, arguments);
          };
        }
        function q(h, R) {
          var I = !1;
          function B($) {
            I || (I = !0, S.reject(h, $));
          }
          function H($) {
            I || (I = !0, S.resolve(h, $));
          }
          function j() {
            R(H, B);
          }
          var J = F(j);
          J.status === "error" && B(J.value);
        }
        function F(h, R) {
          var I = {};
          try {
            I.value = h(R), I.status = "success";
          } catch (B) {
            I.status = "error", I.value = B;
          }
          return I;
        }
        m.resolve = k;
        function k(h) {
          return h instanceof this ? h : S.resolve(new this(Y), h);
        }
        m.reject = U;
        function U(h) {
          var R = new this(Y);
          return S.reject(R, h);
        }
        m.all = ae;
        function ae(h) {
          var R = this;
          if (Object.prototype.toString.call(h) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var I = h.length,
            B = !1;
          if (!I) return this.resolve([]);
          for (var H = new Array(I), j = 0, J = -1, $ = new this(Y); ++J < I;) ee(h[J], J);
          return $;
          function ee(oe, a) {
            R.resolve(oe).then(s, function (v) {
              B || (B = !0, S.reject($, v));
            });
            function s(v) {
              H[a] = v, ++j === I && !B && (B = !0, S.resolve($, H));
            }
          }
        }
        m.race = re;
        function re(h) {
          var R = this;
          if (Object.prototype.toString.call(h) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var I = h.length,
            B = !1;
          if (!I) return this.resolve([]);
          for (var H = -1, j = new this(Y); ++H < I;) J(h[H]);
          return j;
          function J($) {
            R.resolve($).then(function (ee) {
              B || (B = !0, S.resolve(j, ee));
            }, function (ee) {
              B || (B = !0, S.reject(j, ee));
            });
          }
        }
      }, {
        "1": 1
      }],
      3: [function (L, M, Q) {
        (function (C) {

          typeof C.Promise != "function" && (C.Promise = L(2));
        }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
      }, {
        "2": 2
      }],
      4: [function (L, M, Q) {

        var C = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        function Y(e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }
        function S() {
          try {
            if (typeof indexedDB != "undefined") return indexedDB;
            if (typeof webkitIndexedDB != "undefined") return webkitIndexedDB;
            if (typeof mozIndexedDB != "undefined") return mozIndexedDB;
            if (typeof OIndexedDB != "undefined") return OIndexedDB;
            if (typeof msIndexedDB != "undefined") return msIndexedDB;
          } catch {
            return;
          }
        }
        var P = S();
        function K() {
          try {
            if (!P || !P.open) return !1;
            var e = typeof openDatabase != "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform),
              t = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!e || t) && typeof indexedDB != "undefined" && typeof IDBKeyRange != "undefined";
          } catch {
            return !1;
          }
        }
        function Z(e, t) {
          e = e || [], t = t || {};
          try {
            return new Blob(e, t);
          } catch (n) {
            if (n.name !== "TypeError") throw n;
            for (var r = typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder, o = new r(), i = 0; i < e.length; i += 1) o.append(e[i]);
            return o.getBlob(t.type);
          }
        }
        typeof Promise == "undefined" && L(3);
        var m = Promise;
        function w(e, t) {
          t && e.then(function (r) {
            t(null, r);
          }, function (r) {
            t(r);
          });
        }
        function N(e, t, r) {
          typeof t == "function" && e.then(t), typeof r == "function" && e.catch(r);
        }
        function z(e) {
          return typeof e != "string" && (console.warn(e + " used as a key, but it is not a string."), e = String(e)), e;
        }
        function q() {
          if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1];
        }
        var F = "local-forage-detect-blob-support",
          k = void 0,
          U = {},
          ae = Object.prototype.toString,
          re = "readonly",
          h = "readwrite";
        function R(e) {
          for (var t = e.length, r = new ArrayBuffer(t), o = new Uint8Array(r), i = 0; i < t; i++) o[i] = e.charCodeAt(i);
          return r;
        }
        function I(e) {
          return new m(function (t) {
            var r = e.transaction(F, h),
              o = Z([""]);
            r.objectStore(F).put(o, "key"), r.onabort = function (i) {
              i.preventDefault(), i.stopPropagation(), t(!1);
            }, r.oncomplete = function () {
              var i = navigator.userAgent.match(/Chrome\/(\d+)/),
                n = navigator.userAgent.match(/Edge\//);
              t(n || !i || parseInt(i[1], 10) >= 43);
            };
          }).catch(function () {
            return !1;
          });
        }
        function B(e) {
          return typeof k == "boolean" ? m.resolve(k) : I(e).then(function (t) {
            return k = t, k;
          });
        }
        function H(e) {
          var t = U[e.name],
            r = {};
          r.promise = new m(function (o, i) {
            r.resolve = o, r.reject = i;
          }), t.deferredOperations.push(r), t.dbReady ? t.dbReady = t.dbReady.then(function () {
            return r.promise;
          }) : t.dbReady = r.promise;
        }
        function j(e) {
          var t = U[e.name],
            r = t.deferredOperations.pop();
          if (r) return r.resolve(), r.promise;
        }
        function J(e, t) {
          var r = U[e.name],
            o = r.deferredOperations.pop();
          if (o) return o.reject(t), o.promise;
        }
        function $(e, t) {
          return new m(function (r, o) {
            if (U[e.name] = U[e.name] || G(), e.db) if (t) H(e), e.db.close();else return r(e.db);
            var i = [e.name];
            t && i.push(e.version);
            var n = P.open.apply(P, i);
            t && (n.onupgradeneeded = function (f) {
              var u = n.result;
              try {
                u.createObjectStore(e.storeName), f.oldVersion <= 1 && u.createObjectStore(F);
              } catch (c) {
                if (c.name === "ConstraintError") console.warn('The database "' + e.name + '" has been upgraded from version ' + f.oldVersion + " to version " + f.newVersion + ', but the storage "' + e.storeName + '" already exists.');else throw c;
              }
            }), n.onerror = function (f) {
              f.preventDefault(), o(n.error);
            }, n.onsuccess = function () {
              r(n.result), j(e);
            };
          });
        }
        function ee(e) {
          return $(e, !1);
        }
        function oe(e) {
          return $(e, !0);
        }
        function a(e, t) {
          if (!e.db) return !0;
          var r = !e.db.objectStoreNames.contains(e.storeName),
            o = e.version < e.db.version,
            i = e.version > e.db.version;
          if (o && (e.version !== t && console.warn('The database "' + e.name + `" can't be downgraded from version ` + e.db.version + " to version " + e.version + "."), e.version = e.db.version), i || r) {
            if (r) {
              var n = e.db.version + 1;
              n > e.version && (e.version = n);
            }
            return !0;
          }
          return !1;
        }
        function s(e) {
          return new m(function (t, r) {
            var o = new FileReader();
            o.onerror = r, o.onloadend = function (i) {
              var n = btoa(i.target.result || "");
              t({
                __local_forage_encoded_blob: !0,
                data: n,
                type: e.type
              });
            }, o.readAsBinaryString(e);
          });
        }
        function v(e) {
          var t = R(atob(e.data));
          return Z([t], {
            type: e.type
          });
        }
        function b(e) {
          return e && e.__local_forage_encoded_blob;
        }
        function _(e) {
          var t = this,
            r = t._initReady().then(function () {
              var o = U[t._dbInfo.name];
              if (o && o.dbReady) return o.dbReady;
            });
          return N(r, e, e), r;
        }
        function E(e) {
          H(e);
          for (var t = U[e.name], r = t.forages, o = 0; o < r.length; o++) {
            var i = r[o];
            i._dbInfo.db && (i._dbInfo.db.close(), i._dbInfo.db = null);
          }
          return e.db = null, ee(e).then(function (n) {
            return e.db = n, a(e) ? oe(e) : n;
          }).then(function (n) {
            e.db = t.db = n;
            for (var f = 0; f < r.length; f++) r[f]._dbInfo.db = n;
          }).catch(function (n) {
            throw J(e, n), n;
          });
        }
        function D(e, t, r, o) {
          o === void 0 && (o = 1);
          try {
            var i = e.db.transaction(e.storeName, t);
            r(null, i);
          } catch (n) {
            if (o > 0 && (!e.db || n.name === "InvalidStateError" || n.name === "NotFoundError")) return m.resolve().then(function () {
              if (!e.db || n.name === "NotFoundError" && !e.db.objectStoreNames.contains(e.storeName) && e.version <= e.db.version) return e.db && (e.version = e.db.version + 1), oe(e);
            }).then(function () {
              return E(e).then(function () {
                D(e, t, r, o - 1);
              });
            }).catch(r);
            r(n);
          }
        }
        function G() {
          return {
            forages: [],
            db: null,
            dbReady: null,
            deferredOperations: []
          };
        }
        function fe(e) {
          var t = this,
            r = {
              db: null
            };
          if (e) for (var o in e) r[o] = e[o];
          var i = U[r.name];
          i || (i = G(), U[r.name] = i), i.forages.push(t), t._initReady || (t._initReady = t.ready, t.ready = _);
          var n = [];
          function f() {
            return m.resolve();
          }
          for (var u = 0; u < i.forages.length; u++) {
            var c = i.forages[u];
            c !== t && n.push(c._initReady().catch(f));
          }
          var l = i.forages.slice(0);
          return m.all(n).then(function () {
            return r.db = i.db, ee(r);
          }).then(function (d) {
            return r.db = d, a(r, t._defaultConfig.version) ? oe(r) : d;
          }).then(function (d) {
            r.db = i.db = d, t._dbInfo = r;
            for (var y = 0; y < l.length; y++) {
              var A = l[y];
              A !== t && (A._dbInfo.db = r.db, A._dbInfo.version = r.version);
            }
          });
        }
        function ie(e, t) {
          var r = this;
          e = z(e);
          var o = new m(function (i, n) {
            r.ready().then(function () {
              D(r._dbInfo, re, function (f, u) {
                if (f) return n(f);
                try {
                  var c = u.objectStore(r._dbInfo.storeName),
                    l = c.get(e);
                  l.onsuccess = function () {
                    var d = l.result;
                    d === void 0 && (d = null), b(d) && (d = v(d)), i(d);
                  }, l.onerror = function () {
                    n(l.error);
                  };
                } catch (d) {
                  n(d);
                }
              });
            }).catch(n);
          });
          return w(o, t), o;
        }
        function ce(e, t) {
          var r = this,
            o = new m(function (i, n) {
              r.ready().then(function () {
                D(r._dbInfo, re, function (f, u) {
                  if (f) return n(f);
                  try {
                    var c = u.objectStore(r._dbInfo.storeName),
                      l = c.openCursor(),
                      d = 1;
                    l.onsuccess = function () {
                      var y = l.result;
                      if (y) {
                        var A = y.value;
                        b(A) && (A = v(A));
                        var T = e(A, y.key, d++);
                        T !== void 0 ? i(T) : y.continue();
                      } else i();
                    }, l.onerror = function () {
                      n(l.error);
                    };
                  } catch (y) {
                    n(y);
                  }
                });
              }).catch(n);
            });
          return w(o, t), o;
        }
        function nr(e, t, r) {
          var o = this;
          e = z(e);
          var i = new m(function (n, f) {
            var u;
            o.ready().then(function () {
              return u = o._dbInfo, ae.call(t) === "[object Blob]" ? B(u.db).then(function (c) {
                return c ? t : s(t);
              }) : t;
            }).then(function (c) {
              D(o._dbInfo, h, function (l, d) {
                if (l) return f(l);
                try {
                  var y = d.objectStore(o._dbInfo.storeName);
                  c === null && (c = void 0);
                  var A = y.put(c, e);
                  d.oncomplete = function () {
                    c === void 0 && (c = null), n(c);
                  }, d.onabort = d.onerror = function () {
                    var T = A.error ? A.error : A.transaction.error;
                    f(T);
                  };
                } catch (T) {
                  f(T);
                }
              });
            }).catch(f);
          });
          return w(i, r), i;
        }
        function or(e, t) {
          var r = this;
          e = z(e);
          var o = new m(function (i, n) {
            r.ready().then(function () {
              D(r._dbInfo, h, function (f, u) {
                if (f) return n(f);
                try {
                  var c = u.objectStore(r._dbInfo.storeName),
                    l = c.delete(e);
                  u.oncomplete = function () {
                    i();
                  }, u.onerror = function () {
                    n(l.error);
                  }, u.onabort = function () {
                    var d = l.error ? l.error : l.transaction.error;
                    n(d);
                  };
                } catch (d) {
                  n(d);
                }
              });
            }).catch(n);
          });
          return w(o, t), o;
        }
        function ir(e) {
          var t = this,
            r = new m(function (o, i) {
              t.ready().then(function () {
                D(t._dbInfo, h, function (n, f) {
                  if (n) return i(n);
                  try {
                    var u = f.objectStore(t._dbInfo.storeName),
                      c = u.clear();
                    f.oncomplete = function () {
                      o();
                    }, f.onabort = f.onerror = function () {
                      var l = c.error ? c.error : c.transaction.error;
                      i(l);
                    };
                  } catch (l) {
                    i(l);
                  }
                });
              }).catch(i);
            });
          return w(r, e), r;
        }
        function ar(e) {
          var t = this,
            r = new m(function (o, i) {
              t.ready().then(function () {
                D(t._dbInfo, re, function (n, f) {
                  if (n) return i(n);
                  try {
                    var u = f.objectStore(t._dbInfo.storeName),
                      c = u.count();
                    c.onsuccess = function () {
                      o(c.result);
                    }, c.onerror = function () {
                      i(c.error);
                    };
                  } catch (l) {
                    i(l);
                  }
                });
              }).catch(i);
            });
          return w(r, e), r;
        }
        function fr(e, t) {
          var r = this,
            o = new m(function (i, n) {
              if (e < 0) {
                i(null);
                return;
              }
              r.ready().then(function () {
                D(r._dbInfo, re, function (f, u) {
                  if (f) return n(f);
                  try {
                    var c = u.objectStore(r._dbInfo.storeName),
                      l = !1,
                      d = c.openKeyCursor();
                    d.onsuccess = function () {
                      var y = d.result;
                      if (!y) {
                        i(null);
                        return;
                      }
                      e === 0 || l ? i(y.key) : (l = !0, y.advance(e));
                    }, d.onerror = function () {
                      n(d.error);
                    };
                  } catch (y) {
                    n(y);
                  }
                });
              }).catch(n);
            });
          return w(o, t), o;
        }
        function ur(e) {
          var t = this,
            r = new m(function (o, i) {
              t.ready().then(function () {
                D(t._dbInfo, re, function (n, f) {
                  if (n) return i(n);
                  try {
                    var u = f.objectStore(t._dbInfo.storeName),
                      c = u.openKeyCursor(),
                      l = [];
                    c.onsuccess = function () {
                      var d = c.result;
                      if (!d) {
                        o(l);
                        return;
                      }
                      l.push(d.key), d.continue();
                    }, c.onerror = function () {
                      i(c.error);
                    };
                  } catch (d) {
                    i(d);
                  }
                });
              }).catch(i);
            });
          return w(r, e), r;
        }
        function sr(e, t) {
          t = q.apply(this, arguments);
          var r = this.config();
          e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName);
          var o = this,
            i;
          if (!e.name) i = m.reject("Invalid arguments");else {
            var n = e.name === r.name && o._dbInfo.db,
              f = n ? m.resolve(o._dbInfo.db) : ee(e).then(function (u) {
                var c = U[e.name],
                  l = c.forages;
                c.db = u;
                for (var d = 0; d < l.length; d++) l[d]._dbInfo.db = u;
                return u;
              });
            e.storeName ? i = f.then(function (u) {
              if (!!u.objectStoreNames.contains(e.storeName)) {
                var c = u.version + 1;
                H(e);
                var l = U[e.name],
                  d = l.forages;
                u.close();
                for (var y = 0; y < d.length; y++) {
                  var A = d[y];
                  A._dbInfo.db = null, A._dbInfo.version = c;
                }
                var T = new m(function (x, V) {
                  var W = P.open(e.name, c);
                  W.onerror = function (X) {
                    var de = W.result;
                    de.close(), V(X);
                  }, W.onupgradeneeded = function () {
                    var X = W.result;
                    X.deleteObjectStore(e.storeName);
                  }, W.onsuccess = function () {
                    var X = W.result;
                    X.close(), x(X);
                  };
                });
                return T.then(function (x) {
                  l.db = x;
                  for (var V = 0; V < d.length; V++) {
                    var W = d[V];
                    W._dbInfo.db = x, j(W._dbInfo);
                  }
                }).catch(function (x) {
                  throw (J(e, x) || m.resolve()).catch(function () {}), x;
                });
              }
            }) : i = f.then(function (u) {
              H(e);
              var c = U[e.name],
                l = c.forages;
              u.close();
              for (var d = 0; d < l.length; d++) {
                var y = l[d];
                y._dbInfo.db = null;
              }
              var A = new m(function (T, x) {
                var V = P.deleteDatabase(e.name);
                V.onerror = V.onblocked = function (W) {
                  var X = V.result;
                  X && X.close(), x(W);
                }, V.onsuccess = function () {
                  var W = V.result;
                  W && W.close(), T(W);
                };
              });
              return A.then(function (T) {
                c.db = T;
                for (var x = 0; x < l.length; x++) {
                  var V = l[x];
                  j(V._dbInfo);
                }
              }).catch(function (T) {
                throw (J(e, T) || m.resolve()).catch(function () {}), T;
              });
            });
          }
          return w(i, t), i;
        }
        var cr = {
          _driver: "asyncStorage",
          _initStorage: fe,
          _support: K(),
          iterate: ce,
          getItem: ie,
          setItem: nr,
          removeItem: or,
          clear: ir,
          length: ar,
          key: fr,
          keys: ur,
          dropInstance: sr
        };
        function lr() {
          return typeof openDatabase == "function";
        }
        var te = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          dr = "~~local_forage_type~",
          xe = /^~~local_forage_type~([^~]+)~/,
          he = "__lfsc__:",
          ge = he.length,
          be = "arbf",
          _e = "blob",
          Oe = "si08",
          Ce = "ui08",
          Le = "uic8",
          Pe = "si16",
          Me = "si32",
          Fe = "ur16",
          Ue = "ui32",
          Ye = "fl32",
          ze = "fl64",
          We = ge + be.length,
          Ke = Object.prototype.toString;
        function He(e) {
          var t = e.length * .75,
            r = e.length,
            o,
            i = 0,
            n,
            f,
            u,
            c;
          e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--);
          var l = new ArrayBuffer(t),
            d = new Uint8Array(l);
          for (o = 0; o < r; o += 4) n = te.indexOf(e[o]), f = te.indexOf(e[o + 1]), u = te.indexOf(e[o + 2]), c = te.indexOf(e[o + 3]), d[i++] = n << 2 | f >> 4, d[i++] = (f & 15) << 4 | u >> 2, d[i++] = (u & 3) << 6 | c & 63;
          return l;
        }
        function we(e) {
          var t = new Uint8Array(e),
            r = "",
            o;
          for (o = 0; o < t.length; o += 3) r += te[t[o] >> 2], r += te[(t[o] & 3) << 4 | t[o + 1] >> 4], r += te[(t[o + 1] & 15) << 2 | t[o + 2] >> 6], r += te[t[o + 2] & 63];
          return t.length % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : t.length % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
        }
        function vr(e, t) {
          var r = "";
          if (e && (r = Ke.call(e)), e && (r === "[object ArrayBuffer]" || e.buffer && Ke.call(e.buffer) === "[object ArrayBuffer]")) {
            var o,
              i = he;
            e instanceof ArrayBuffer ? (o = e, i += be) : (o = e.buffer, r === "[object Int8Array]" ? i += Oe : r === "[object Uint8Array]" ? i += Ce : r === "[object Uint8ClampedArray]" ? i += Le : r === "[object Int16Array]" ? i += Pe : r === "[object Uint16Array]" ? i += Fe : r === "[object Int32Array]" ? i += Me : r === "[object Uint32Array]" ? i += Ue : r === "[object Float32Array]" ? i += Ye : r === "[object Float64Array]" ? i += ze : t(new Error("Failed to get type for BinaryArray"))), t(i + we(o));
          } else if (r === "[object Blob]") {
            var n = new FileReader();
            n.onload = function () {
              var f = dr + e.type + "~" + we(this.result);
              t(he + _e + f);
            }, n.readAsArrayBuffer(e);
          } else try {
            t(JSON.stringify(e));
          } catch (f) {
            console.error("Couldn't convert value into a JSON string: ", e), t(null, f);
          }
        }
        function hr(e) {
          if (e.substring(0, ge) !== he) return JSON.parse(e);
          var t = e.substring(We),
            r = e.substring(ge, We),
            o;
          if (r === _e && xe.test(t)) {
            var i = t.match(xe);
            o = i[1], t = t.substring(i[0].length);
          }
          var n = He(t);
          switch (r) {
            case be:
              return n;
            case _e:
              return Z([n], {
                type: o
              });
            case Oe:
              return new Int8Array(n);
            case Ce:
              return new Uint8Array(n);
            case Le:
              return new Uint8ClampedArray(n);
            case Pe:
              return new Int16Array(n);
            case Fe:
              return new Uint16Array(n);
            case Me:
              return new Int32Array(n);
            case Ue:
              return new Uint32Array(n);
            case Ye:
              return new Float32Array(n);
            case ze:
              return new Float64Array(n);
            default:
              throw new Error("Unkown type: " + r);
          }
        }
        var Ee = {
          serialize: vr,
          deserialize: hr,
          stringToBuffer: He,
          bufferToString: we
        };
        function Ve(e, t, r, o) {
          e.executeSql("CREATE TABLE IF NOT EXISTS " + t.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], r, o);
        }
        function mr(e) {
          var t = this,
            r = {
              db: null
            };
          if (e) for (var o in e) r[o] = typeof e[o] != "string" ? e[o].toString() : e[o];
          var i = new m(function (n, f) {
            try {
              r.db = openDatabase(r.name, String(r.version), r.description, r.size);
            } catch (u) {
              return f(u);
            }
            r.db.transaction(function (u) {
              Ve(u, r, function () {
                t._dbInfo = r, n();
              }, function (c, l) {
                f(l);
              });
            }, f);
          });
          return r.serializer = Ee, i;
        }
        function ne(e, t, r, o, i, n) {
          e.executeSql(r, o, i, function (f, u) {
            u.code === u.SYNTAX_ERR ? f.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [t.storeName], function (c, l) {
              l.rows.length ? n(c, u) : Ve(c, t, function () {
                c.executeSql(r, o, i, n);
              }, n);
            }, n) : n(f, u);
          }, n);
        }
        function yr(e, t) {
          var r = this;
          e = z(e);
          var o = new m(function (i, n) {
            r.ready().then(function () {
              var f = r._dbInfo;
              f.db.transaction(function (u) {
                ne(u, f, "SELECT * FROM " + f.storeName + " WHERE key = ? LIMIT 1", [e], function (c, l) {
                  var d = l.rows.length ? l.rows.item(0).value : null;
                  d && (d = f.serializer.deserialize(d)), i(d);
                }, function (c, l) {
                  n(l);
                });
              });
            }).catch(n);
          });
          return w(o, t), o;
        }
        function pr(e, t) {
          var r = this,
            o = new m(function (i, n) {
              r.ready().then(function () {
                var f = r._dbInfo;
                f.db.transaction(function (u) {
                  ne(u, f, "SELECT * FROM " + f.storeName, [], function (c, l) {
                    for (var d = l.rows, y = d.length, A = 0; A < y; A++) {
                      var T = d.item(A),
                        x = T.value;
                      if (x && (x = f.serializer.deserialize(x)), x = e(x, T.key, A + 1), x !== void 0) {
                        i(x);
                        return;
                      }
                    }
                    i();
                  }, function (c, l) {
                    n(l);
                  });
                });
              }).catch(n);
            });
          return w(o, t), o;
        }
        function Ge(e, t, r, o) {
          var i = this;
          e = z(e);
          var n = new m(function (f, u) {
            i.ready().then(function () {
              t === void 0 && (t = null);
              var c = t,
                l = i._dbInfo;
              l.serializer.serialize(t, function (d, y) {
                y ? u(y) : l.db.transaction(function (A) {
                  ne(A, l, "INSERT OR REPLACE INTO " + l.storeName + " (key, value) VALUES (?, ?)", [e, d], function () {
                    f(c);
                  }, function (T, x) {
                    u(x);
                  });
                }, function (A) {
                  if (A.code === A.QUOTA_ERR) {
                    if (o > 0) {
                      f(Ge.apply(i, [e, c, r, o - 1]));
                      return;
                    }
                    u(A);
                  }
                });
              });
            }).catch(u);
          });
          return w(n, r), n;
        }
        function gr(e, t, r) {
          return Ge.apply(this, [e, t, r, 1]);
        }
        function br(e, t) {
          var r = this;
          e = z(e);
          var o = new m(function (i, n) {
            r.ready().then(function () {
              var f = r._dbInfo;
              f.db.transaction(function (u) {
                ne(u, f, "DELETE FROM " + f.storeName + " WHERE key = ?", [e], function () {
                  i();
                }, function (c, l) {
                  n(l);
                });
              });
            }).catch(n);
          });
          return w(o, t), o;
        }
        function _r(e) {
          var t = this,
            r = new m(function (o, i) {
              t.ready().then(function () {
                var n = t._dbInfo;
                n.db.transaction(function (f) {
                  ne(f, n, "DELETE FROM " + n.storeName, [], function () {
                    o();
                  }, function (u, c) {
                    i(c);
                  });
                });
              }).catch(i);
            });
          return w(r, e), r;
        }
        function wr(e) {
          var t = this,
            r = new m(function (o, i) {
              t.ready().then(function () {
                var n = t._dbInfo;
                n.db.transaction(function (f) {
                  ne(f, n, "SELECT COUNT(key) as c FROM " + n.storeName, [], function (u, c) {
                    var l = c.rows.item(0).c;
                    o(l);
                  }, function (u, c) {
                    i(c);
                  });
                });
              }).catch(i);
            });
          return w(r, e), r;
        }
        function Er(e, t) {
          var r = this,
            o = new m(function (i, n) {
              r.ready().then(function () {
                var f = r._dbInfo;
                f.db.transaction(function (u) {
                  ne(u, f, "SELECT key FROM " + f.storeName + " WHERE id = ? LIMIT 1", [e + 1], function (c, l) {
                    var d = l.rows.length ? l.rows.item(0).key : null;
                    i(d);
                  }, function (c, l) {
                    n(l);
                  });
                });
              }).catch(n);
            });
          return w(o, t), o;
        }
        function Ir(e) {
          var t = this,
            r = new m(function (o, i) {
              t.ready().then(function () {
                var n = t._dbInfo;
                n.db.transaction(function (f) {
                  ne(f, n, "SELECT key FROM " + n.storeName, [], function (u, c) {
                    for (var l = [], d = 0; d < c.rows.length; d++) l.push(c.rows.item(d).key);
                    o(l);
                  }, function (u, c) {
                    i(c);
                  });
                });
              }).catch(i);
            });
          return w(r, e), r;
        }
        function Sr(e) {
          return new m(function (t, r) {
            e.transaction(function (o) {
              o.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (i, n) {
                for (var f = [], u = 0; u < n.rows.length; u++) f.push(n.rows.item(u).name);
                t({
                  db: e,
                  storeNames: f
                });
              }, function (i, n) {
                r(n);
              });
            }, function (o) {
              r(o);
            });
          });
        }
        function Ar(e, t) {
          t = q.apply(this, arguments);
          var r = this.config();
          e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName);
          var o = this,
            i;
          return e.name ? i = new m(function (n) {
            var f;
            e.name === r.name ? f = o._dbInfo.db : f = openDatabase(e.name, "", "", 0), e.storeName ? n({
              db: f,
              storeNames: [e.storeName]
            }) : n(Sr(f));
          }).then(function (n) {
            return new m(function (f, u) {
              n.db.transaction(function (c) {
                function l(T) {
                  return new m(function (x, V) {
                    c.executeSql("DROP TABLE IF EXISTS " + T, [], function () {
                      x();
                    }, function (W, X) {
                      V(X);
                    });
                  });
                }
                for (var d = [], y = 0, A = n.storeNames.length; y < A; y++) d.push(l(n.storeNames[y]));
                m.all(d).then(function () {
                  f();
                }).catch(function (T) {
                  u(T);
                });
              }, function (c) {
                u(c);
              });
            });
          }) : i = m.reject("Invalid arguments"), w(i, t), i;
        }
        var Rr = {
          _driver: "webSQLStorage",
          _initStorage: mr,
          _support: lr(),
          iterate: pr,
          getItem: yr,
          setItem: gr,
          removeItem: br,
          clear: _r,
          length: wr,
          key: Er,
          keys: Ir,
          dropInstance: Ar
        };
        function Dr() {
          try {
            return typeof localStorage != "undefined" && "setItem" in localStorage && !!localStorage.setItem;
          } catch {
            return !1;
          }
        }
        function je(e, t) {
          var r = e.name + "/";
          return e.storeName !== t.storeName && (r += e.storeName + "/"), r;
        }
        function Nr() {
          var e = "_localforage_support_test";
          try {
            return localStorage.setItem(e, !0), localStorage.removeItem(e), !1;
          } catch {
            return !0;
          }
        }
        function Tr() {
          return !Nr() || localStorage.length > 0;
        }
        function Br(e) {
          var t = this,
            r = {};
          if (e) for (var o in e) r[o] = e[o];
          return r.keyPrefix = je(e, t._defaultConfig), Tr() ? (t._dbInfo = r, r.serializer = Ee, m.resolve()) : m.reject();
        }
        function xr(e) {
          var t = this,
            r = t.ready().then(function () {
              for (var o = t._dbInfo.keyPrefix, i = localStorage.length - 1; i >= 0; i--) {
                var n = localStorage.key(i);
                n.indexOf(o) === 0 && localStorage.removeItem(n);
              }
            });
          return w(r, e), r;
        }
        function Or(e, t) {
          var r = this;
          e = z(e);
          var o = r.ready().then(function () {
            var i = r._dbInfo,
              n = localStorage.getItem(i.keyPrefix + e);
            return n && (n = i.serializer.deserialize(n)), n;
          });
          return w(o, t), o;
        }
        function Cr(e, t) {
          var r = this,
            o = r.ready().then(function () {
              for (var i = r._dbInfo, n = i.keyPrefix, f = n.length, u = localStorage.length, c = 1, l = 0; l < u; l++) {
                var d = localStorage.key(l);
                if (d.indexOf(n) === 0) {
                  var y = localStorage.getItem(d);
                  if (y && (y = i.serializer.deserialize(y)), y = e(y, d.substring(f), c++), y !== void 0) return y;
                }
              }
            });
          return w(o, t), o;
        }
        function Lr(e, t) {
          var r = this,
            o = r.ready().then(function () {
              var i = r._dbInfo,
                n;
              try {
                n = localStorage.key(e);
              } catch {
                n = null;
              }
              return n && (n = n.substring(i.keyPrefix.length)), n;
            });
          return w(o, t), o;
        }
        function Pr(e) {
          var t = this,
            r = t.ready().then(function () {
              for (var o = t._dbInfo, i = localStorage.length, n = [], f = 0; f < i; f++) {
                var u = localStorage.key(f);
                u.indexOf(o.keyPrefix) === 0 && n.push(u.substring(o.keyPrefix.length));
              }
              return n;
            });
          return w(r, e), r;
        }
        function Mr(e) {
          var t = this,
            r = t.keys().then(function (o) {
              return o.length;
            });
          return w(r, e), r;
        }
        function Fr(e, t) {
          var r = this;
          e = z(e);
          var o = r.ready().then(function () {
            var i = r._dbInfo;
            localStorage.removeItem(i.keyPrefix + e);
          });
          return w(o, t), o;
        }
        function Ur(e, t, r) {
          var o = this;
          e = z(e);
          var i = o.ready().then(function () {
            t === void 0 && (t = null);
            var n = t;
            return new m(function (f, u) {
              var c = o._dbInfo;
              c.serializer.serialize(t, function (l, d) {
                if (d) u(d);else try {
                  localStorage.setItem(c.keyPrefix + e, l), f(n);
                } catch (y) {
                  (y.name === "QuotaExceededError" || y.name === "NS_ERROR_DOM_QUOTA_REACHED") && u(y), u(y);
                }
              });
            });
          });
          return w(i, r), i;
        }
        function Yr(e, t) {
          if (t = q.apply(this, arguments), e = typeof e != "function" && e || {}, !e.name) {
            var r = this.config();
            e.name = e.name || r.name, e.storeName = e.storeName || r.storeName;
          }
          var o = this,
            i;
          return e.name ? i = new m(function (n) {
            e.storeName ? n(je(e, o._defaultConfig)) : n(e.name + "/");
          }).then(function (n) {
            for (var f = localStorage.length - 1; f >= 0; f--) {
              var u = localStorage.key(f);
              u.indexOf(n) === 0 && localStorage.removeItem(u);
            }
          }) : i = m.reject("Invalid arguments"), w(i, t), i;
        }
        var zr = {
            _driver: "localStorageWrapper",
            _initStorage: Br,
            _support: Dr(),
            iterate: Cr,
            getItem: Or,
            setItem: Ur,
            removeItem: Fr,
            clear: xr,
            length: Mr,
            key: Lr,
            keys: Pr,
            dropInstance: Yr
          },
          Wr = function (t, r) {
            return t === r || typeof t == "number" && typeof r == "number" && isNaN(t) && isNaN(r);
          },
          Kr = function (t, r) {
            for (var o = t.length, i = 0; i < o;) {
              if (Wr(t[i], r)) return !0;
              i++;
            }
            return !1;
          },
          Xe = Array.isArray || function (e) {
            return Object.prototype.toString.call(e) === "[object Array]";
          },
          le = {},
          Qe = {},
          ue = {
            INDEXEDDB: cr,
            WEBSQL: Rr,
            LOCALSTORAGE: zr
          },
          Hr = [ue.INDEXEDDB._driver, ue.WEBSQL._driver, ue.LOCALSTORAGE._driver],
          me = ["dropInstance"],
          Ie = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(me),
          Vr = {
            description: "",
            driver: Hr.slice(),
            name: "localforage",
            size: 4980736,
            storeName: "keyvaluepairs",
            version: 1
          };
        function Gr(e, t) {
          e[t] = function () {
            var r = arguments;
            return e.ready().then(function () {
              return e[t].apply(e, r);
            });
          };
        }
        function Se() {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            if (t) for (var r in t) t.hasOwnProperty(r) && (Xe(t[r]) ? arguments[0][r] = t[r].slice() : arguments[0][r] = t[r]);
          }
          return arguments[0];
        }
        var jr = function () {
            function e(t) {
              Y(this, e);
              for (var r in ue) if (ue.hasOwnProperty(r)) {
                var o = ue[r],
                  i = o._driver;
                this[r] = i, le[i] || this.defineDriver(o);
              }
              this._defaultConfig = Se({}, Vr), this._config = Se({}, this._defaultConfig, t), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function () {});
            }
            return e.prototype.config = function (r) {
              if ((typeof r == "undefined" ? "undefined" : C(r)) === "object") {
                if (this._ready) return new Error("Can't call config() after localforage has been used.");
                for (var o in r) {
                  if (o === "storeName" && (r[o] = r[o].replace(/\W/g, "_")), o === "version" && typeof r[o] != "number") return new Error("Database version must be a number.");
                  this._config[o] = r[o];
                }
                return "driver" in r && r.driver ? this.setDriver(this._config.driver) : !0;
              } else return typeof r == "string" ? this._config[r] : this._config;
            }, e.prototype.defineDriver = function (r, o, i) {
              var n = new m(function (f, u) {
                try {
                  var c = r._driver,
                    l = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                  if (!r._driver) {
                    u(l);
                    return;
                  }
                  for (var d = Ie.concat("_initStorage"), y = 0, A = d.length; y < A; y++) {
                    var T = d[y],
                      x = !Kr(me, T);
                    if ((x || r[T]) && typeof r[T] != "function") {
                      u(l);
                      return;
                    }
                  }
                  var V = function () {
                    for (var de = function (Jr) {
                        return function () {
                          var $r = new Error("Method " + Jr + " is not implemented by the current driver"),
                            Je = m.reject($r);
                          return w(Je, arguments[arguments.length - 1]), Je;
                        };
                      }, Ae = 0, Qr = me.length; Ae < Qr; Ae++) {
                      var Re = me[Ae];
                      r[Re] || (r[Re] = de(Re));
                    }
                  };
                  V();
                  var W = function (de) {
                    le[c] && console.info("Redefining LocalForage driver: " + c), le[c] = r, Qe[c] = de, f();
                  };
                  "_support" in r ? r._support && typeof r._support == "function" ? r._support().then(W, u) : W(!!r._support) : W(!0);
                } catch (X) {
                  u(X);
                }
              });
              return N(n, o, i), n;
            }, e.prototype.driver = function () {
              return this._driver || null;
            }, e.prototype.getDriver = function (r, o, i) {
              var n = le[r] ? m.resolve(le[r]) : m.reject(new Error("Driver not found."));
              return N(n, o, i), n;
            }, e.prototype.getSerializer = function (r) {
              var o = m.resolve(Ee);
              return N(o, r), o;
            }, e.prototype.ready = function (r) {
              var o = this,
                i = o._driverSet.then(function () {
                  return o._ready === null && (o._ready = o._initDriver()), o._ready;
                });
              return N(i, r, r), i;
            }, e.prototype.setDriver = function (r, o, i) {
              var n = this;
              Xe(r) || (r = [r]);
              var f = this._getSupportedDrivers(r);
              function u() {
                n._config.driver = n.driver();
              }
              function c(y) {
                return n._extend(y), u(), n._ready = n._initStorage(n._config), n._ready;
              }
              function l(y) {
                return function () {
                  var A = 0;
                  function T() {
                    for (; A < y.length;) {
                      var x = y[A];
                      return A++, n._dbInfo = null, n._ready = null, n.getDriver(x).then(c).catch(T);
                    }
                    u();
                    var V = new Error("No available storage method found.");
                    return n._driverSet = m.reject(V), n._driverSet;
                  }
                  return T();
                };
              }
              var d = this._driverSet !== null ? this._driverSet.catch(function () {
                return m.resolve();
              }) : m.resolve();
              return this._driverSet = d.then(function () {
                var y = f[0];
                return n._dbInfo = null, n._ready = null, n.getDriver(y).then(function (A) {
                  n._driver = A._driver, u(), n._wrapLibraryMethodsWithReady(), n._initDriver = l(f);
                });
              }).catch(function () {
                u();
                var y = new Error("No available storage method found.");
                return n._driverSet = m.reject(y), n._driverSet;
              }), N(this._driverSet, o, i), this._driverSet;
            }, e.prototype.supports = function (r) {
              return !!Qe[r];
            }, e.prototype._extend = function (r) {
              Se(this, r);
            }, e.prototype._getSupportedDrivers = function (r) {
              for (var o = [], i = 0, n = r.length; i < n; i++) {
                var f = r[i];
                this.supports(f) && o.push(f);
              }
              return o;
            }, e.prototype._wrapLibraryMethodsWithReady = function () {
              for (var r = 0, o = Ie.length; r < o; r++) Gr(this, Ie[r]);
            }, e.prototype.createInstance = function (r) {
              return new e(r);
            }, e;
          }(),
          Xr = new jr();
        M.exports = Xr;
      }, {
        "3": 3
      }]
    }, {}, [4])(4);
  });
});
var rr = $e((ye, er) => {
  (function (p, g) {
    typeof ye == "object" && typeof er != "undefined" ? g(ye) : typeof define == "function" && define.amd ? define("localforage-driver-memory", ["exports"], g) : g(p.LocalforageDriverMemory = {});
  })(typeof self != "undefined" ? self : ye, function (p) {

    var g = "localforage-driver-memory";
    function O(a) {
      var s = typeof Symbol == "function" && a[Symbol.iterator],
        v = 0;
      return s ? s.call(a) : {
        next: function () {
          return a && v >= a.length && (a = void 0), {
            value: a && a[v++],
            done: !a
          };
        }
      };
    }
    function L(a, s) {
      a = a || [], s = s || {};
      try {
        return new Blob(a, s);
      } catch (E) {
        if (E.name !== "TypeError") throw E;
        for (var v = typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder, b = new v(), _ = 0; _ < a.length; _ += 1) b.append(a[_]);
        return b.getBlob(s.type);
      }
    }
    var M = /^~~local_forage_type~([^~]+)~/,
      Q = "__lfsc__:".length,
      C = Q + "arbf".length,
      Y = Object.prototype.toString;
    function S(a) {
      var s = a.length * .75,
        v = a.length;
      a[a.length - 1] === "=" && (s--, a[a.length - 2] === "=" && s--);
      for (var b = new ArrayBuffer(s), _ = new Uint8Array(b), E = 0, D = 0; E < v; E += 4) {
        var G = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a[E]),
          fe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a[E + 1]),
          ie = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a[E + 2]),
          ce = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a[E + 3]);
        _[D++] = G << 2 | fe >> 4, _[D++] = (fe & 15) << 4 | ie >> 2, _[D++] = (ie & 3) << 6 | ce & 63;
      }
      return b;
    }
    function P(a) {
      for (var s = new Uint8Array(a), v = "", b = 0; b < s.length; b += 3) v += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[s[b] >> 2], v += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(s[b] & 3) << 4 | s[b + 1] >> 4], v += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(s[b + 1] & 15) << 2 | s[b + 2] >> 6], v += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[s[b + 2] & 63];
      return s.length % 3 === 2 ? v = v.substring(0, v.length - 1) + "=" : s.length % 3 === 1 && (v = v.substring(0, v.length - 2) + "=="), v;
    }
    function K(a, s) {
      var v = "";
      if (a && (v = Y.call(a)), a && (v === "[object ArrayBuffer]" || a.buffer && Y.call(a.buffer) === "[object ArrayBuffer]")) {
        var b = void 0,
          _ = "__lfsc__:";
        a instanceof ArrayBuffer ? (b = a, _ += "arbf") : (b = a.buffer, v === "[object Int8Array]" ? _ += "si08" : v === "[object Uint8Array]" ? _ += "ui08" : v === "[object Uint8ClampedArray]" ? _ += "uic8" : v === "[object Int16Array]" ? _ += "si16" : v === "[object Uint16Array]" ? _ += "ur16" : v === "[object Int32Array]" ? _ += "si32" : v === "[object Uint32Array]" ? _ += "ui32" : v === "[object Float32Array]" ? _ += "fl32" : v === "[object Float64Array]" ? _ += "fl64" : s(new Error("Failed to get type for BinaryArray"))), s(_ + P(b));
      } else if (v === "[object Blob]") {
        var E = new FileReader();
        E.onload = function () {
          var D = "~~local_forage_type~" + a.type + "~" + P(this.result);
          s("__lfsc__:blob" + D);
        }, E.readAsArrayBuffer(a);
      } else try {
        s(JSON.stringify(a));
      } catch (D) {
        console.error("Couldn't convert value into a JSON string: ", a), s(null, D);
      }
    }
    function Z(a) {
      if (a.substring(0, Q) !== "__lfsc__:") return JSON.parse(a);
      var s = a.substring(C),
        v = a.substring(Q, C),
        b;
      if (v === "blob" && M.test(s)) {
        var _ = s.match(M);
        b = _[1], s = s.substring(_[0].length);
      }
      var E = S(s);
      switch (v) {
        case "arbf":
          return E;
        case "blob":
          return L([E], {
            type: b
          });
        case "si08":
          return new Int8Array(E);
        case "ui08":
          return new Uint8Array(E);
        case "uic8":
          return new Uint8ClampedArray(E);
        case "si16":
          return new Int16Array(E);
        case "ur16":
          return new Uint16Array(E);
        case "si32":
          return new Int32Array(E);
        case "ui32":
          return new Uint32Array(E);
        case "fl32":
          return new Float32Array(E);
        case "fl64":
          return new Float64Array(E);
        default:
          throw new Error("Unkown type: " + v);
      }
    }
    function m(a) {
      var s, v;
      if (a === null || typeof a != "object" || "isActiveClone" in a) return a;
      var b = a instanceof Date ? new Date(a) : a.constructor();
      try {
        for (var _ = O(Object.keys(a)), E = _.next(); !E.done; E = _.next()) {
          var D = E.value;
          Object.prototype.hasOwnProperty.call(a, D) && (a.isActiveClone = null, b[D] = m(a[D]), delete a.isActiveClone);
        }
      } catch (G) {
        s = {
          error: G
        };
      } finally {
        try {
          E && !E.done && (v = _.return) && v.call(_);
        } finally {
          if (s) throw s.error;
        }
      }
      return b;
    }
    function w(a, s) {
      return (a.name || s.name) + "/" + (a.storeName || s.storeName) + "/";
    }
    function N(a, s) {
      s && a.then(function (v) {
        s(null, v);
      }, function (v) {
        s(v);
      });
    }
    function z() {
      for (var a = [], s = 0; s < arguments.length; s++) a[s] = arguments[s];
      if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1];
    }
    function q(a, s) {
      var v = this;
      if (s = z.apply(this, arguments), a = typeof a != "function" && a || {}, !a.name) {
        var b = this.config();
        a.name = a.name || b.name, a.storeName = a.storeName || b.storeName;
      }
      var _;
      return a.name ? _ = new Promise(function (E) {
        a.storeName ? E(w(a, v._defaultConfig)) : E(a.name + "/");
      }) : _ = Promise.reject("Invalid arguments"), {
        promise: _,
        callback: s
      };
    }
    function F(a) {
      return typeof a != "string" && (console.warn(a + " used as a key, but it is not a string."), a = String(a)), a;
    }
    var k = {
        bufferToString: P,
        deserialize: Z,
        serialize: K,
        stringToBuffer: S
      },
      U = {},
      ae = function () {
        function a(s) {
          this.kp = s, this.data = {};
        }
        return a.resolve = function (s) {
          return U[s] || (U[s] = new a(s)), U[s];
        }, a.prototype.clear = function () {
          this.data = {};
        }, a.prototype.drop = function () {
          this.clear(), delete U[this.kp];
        }, a.prototype.get = function (s) {
          return this.data[s];
        }, a.prototype.key = function (s) {
          return this.keys()[s];
        }, a.prototype.keys = function () {
          return Object.keys(this.data);
        }, a.prototype.rm = function (s) {
          delete this.data[s];
        }, a.prototype.set = function (s, v) {
          this.data[s] = v;
        }, a;
      }();
    function re(a) {
      var s = a ? m(a) : {},
        v = w(s, this._defaultConfig),
        b = ae.resolve(v);
      return this._dbInfo = s, this._dbInfo.serializer = k, this._dbInfo.keyPrefix = v, this._dbInfo.mStore = b, Promise.resolve();
    }
    function h(a) {
      var s = this,
        v = this.ready().then(function () {
          s._dbInfo.mStore.clear();
        });
      return N(v, a), v;
    }
    function R(a, s) {
      var v = q.apply(this, arguments),
        b = v.promise,
        _ = v.callback,
        E = b.then(function (D) {
          ae.resolve(D).drop();
        });
      return N(E, _), b;
    }
    function I(a, s) {
      var v = this;
      a = F(a);
      var b = this.ready().then(function () {
        var _ = v._dbInfo.mStore.get(a);
        return _ == null ? null : v._dbInfo.serializer.deserialize(_);
      });
      return N(b, s), b;
    }
    function B(a, s) {
      var v = this,
        b = this.ready().then(function () {
          for (var _ = v._dbInfo.mStore, E = _.keys(), D = 0; D < E.length; D++) {
            var G = _.get(E[D]);
            if (G && (G = v._dbInfo.serializer.deserialize(G)), G = a(G, E[D], D + 1), G !== void 0) return G;
          }
        });
      return N(b, s), b;
    }
    function H(a, s) {
      var v = this,
        b = this.ready().then(function () {
          var _;
          try {
            _ = v._dbInfo.mStore.key(a), _ === void 0 && (_ = null);
          } catch {
            _ = null;
          }
          return _;
        });
      return N(b, s), b;
    }
    function j(a) {
      var s = this,
        v = this.ready().then(function () {
          return s._dbInfo.mStore.keys();
        });
      return N(v, a), v;
    }
    function J(a) {
      var s = this.keys().then(function (v) {
        return v.length;
      });
      return N(s, a), s;
    }
    function $(a, s) {
      var v = this;
      a = F(a);
      var b = this.ready().then(function () {
        v._dbInfo.mStore.rm(a);
      });
      return N(b, s), b;
    }
    function ee(a, s, v) {
      var b = this;
      a = F(a);
      var _ = this.ready().then(function () {
        s === void 0 && (s = null);
        var E = s;
        return new Promise(function (D, G) {
          b._dbInfo.serializer.serialize(s, function (fe, ie) {
            if (ie) G(ie);else try {
              b._dbInfo.mStore.set(a, fe), D(E);
            } catch (ce) {
              G(ce);
            }
          });
        });
      });
      return N(_, v), _;
    }
    var oe = !0;
    p._support = oe, p._driver = g, p._initStorage = re, p.clear = h, p.dropInstance = R, p.getItem = I, p.iterate = B, p.key = H, p.keys = j, p.length = J, p.removeItem = $, p.setItem = ee, Object.defineProperty(p, "__esModule", {
      value: !0
    });
  });
});
var pe = Ze(ke()),
  Be = Ze(rr());
var ft = {
  display: "none",
  position: "fixed",
  top: "0",
  right: "0",
  width: "100%",
  height: "100%",
  borderRadius: "0",
  border: "none",
  zIndex: "2147483647"
};
function ut(p) {
  for (let [g, O] of Object.entries(ft)) p.style[g] = O;
}
function st(p) {
  let g = [].slice.call(document.querySelectorAll(".magic-iframe"));
  return Boolean(g.find(O => O.src.includes(p)));
}
var Te = class extends gt {
  constructor() {
    super(...arguments);
    this.activeElement = null;
  }
  init() {
    this.test = "hello", this.iframe = new Promise(g => {
      let O = () => {
        if (st(encodeURIComponent(this.parameters))) pr().log();else {
          let L = document.createElement("iframe");
          L.classList.add("magic-iframe"), L.dataset.magicIframeLabel = Ie(this.endpoint).host, L.title = "Secure Modal", L.src = Ie(`/send?params=${encodeURIComponent(this.parameters)}`, this.endpoint).href, ut(L), document.body.appendChild(L), g(L);
        }
      };
      ["loaded", "interactive", "complete"].includes(document.readyState) ? O() : window.addEventListener("load", O, !1);
    }), window.addEventListener("message", g => {
      var O;
      if (g.origin === this.endpoint && g.data && g.data.msgType && this.messageHandlers.size) {
        g.data.response = (O = g.data.response) != null ? O : {};
        for (let L of this.messageHandlers.values()) L(g);
      }
    });
  }
  showOverlay() {
    return se(this, null, function* () {
      let g = yield this.iframe;
      g.style.display = "block", this.activeElement = document.activeElement, g.focus();
    });
  }
  hideOverlay() {
    return se(this, null, function* () {
      var O;
      let g = yield this.iframe;
      g.style.display = "none", ((O = this.activeElement) == null ? void 0 : O.focus) && this.activeElement.focus(), this.activeElement = null;
    });
  }
  _post(g) {
    return se(this, null, function* () {
      let O = yield this.iframe;
      if (O && O.contentWindow) O.contentWindow.postMessage(g, this.endpoint);else throw lr();
    });
  }
};
var _t = Tn(be, {
  platform: "web",
  sdkName: "magic-sdk",
  version: "11.0.0",
  defaultEndpoint: "https://auth.magic.link/",
  ViewController: Te,
  configureStorage: () => se(void 0, null, function* () {
    let p = pe.default.createInstance({
      name: "MagicAuthLocalStorageDB",
      storeName: "MagicAuthLocalStorage"
    });
    return yield p.defineDriver(Be), yield p.setDriver([pe.default.INDEXEDDB, pe.default.LOCALSTORAGE, Be._driver]), p;
  })
});

var s = (t => (t.GetWalletInfo = "mc_get_wallet_info", t.ShowWallet = "mc_wallet", t.RequestUserInfo = "mc_request_user_info", t.Disconnect = "mc_disconnect", t))(s || {});
var l = class extends S.Internal {
  constructor() {
    super(...arguments);
    this.name = "connect";
    this.config = {
      mc: !0
    };
  }
  getWalletInfo() {
    let e = this.utils.createJsonRpcRequestPayload("mc_get_wallet_info");
    return this.request(e);
  }
  showWallet() {
    let e = this.utils.createJsonRpcRequestPayload("mc_wallet");
    return this.request(e);
  }
  requestUserInfo(e) {
    let n = this.utils.createJsonRpcRequestPayload("mc_request_user_info", e ? [e] : []);
    return this.request(n);
  }
  disconnect() {
    let e = this.utils.createJsonRpcRequestPayload("mc_disconnect");
    return this.request(e);
  }
};

/* global window */
class MagicWeb3Connector extends AbstractWeb3Connector$1 {
    type = "MagicLink";
    magic;
    ether = null;
    async activate() {
        let networkInfo = WidgetGlobals.Network;
        let network = {
            rpcUrl: networkInfo.RpcUrl,
            chainId: networkInfo.ChainId,
        };
        if (networkInfo.ChainId == 80001) {
            // @ts-ignore
            await window.ethereum.enable();
            // @ts-ignore
            this.ether = new Web3Provider(window.ethereum);
        }
        else {
            this.magic = new _t("pk_live_EA9DDC458FE21B24", {
                extensions: [new l()],
                network: network,
            });
            this.ether = new Web3Provider(this.magic.rpcProvider);
        }
        let accounts = await this.ether.listAccounts();
        console.log("accounts after new Magic", accounts);
        // Assign Constants
        this.account = accounts[0];
        this.provider = this.ether.provider;
        this.chainId = networkInfo.ChainId;
        this.subscribeToEvents(this.provider);
        return {
            provider: this.provider,
            account: this.account,
            chainId: this.chainId,
            ether: this.ether,
            magic: this.magic,
            signer: this.ether.getSigner(),
        };
    }
    deactivate = async () => {
        this.unsubscribeToEvents(this.provider);
        if (this.magic) {
            await this.magic.connect.disconnect().catch((e) => {
                console.error("error to disconnect:", e);
            });
        }
        this.account = null;
        this.chainId = null;
        this.provider = null;
    };
}

var dist = {};

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(lib_esm);

var HttpRequest = {};

var hasRequiredHttpRequest;
function requireHttpRequest() {
  if (hasRequiredHttpRequest) return HttpRequest;
  hasRequiredHttpRequest = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(HttpRequest, "__esModule", {
    value: true
  });
  const index_1 = __importDefault(requireDist());
  let HttpRequest$1 = class HttpRequest {
    constructor() {}
    async postAuth(path, data) {
      if (!index_1.default.Bearer) {
        throw new Error('You are not logged in.');
      }
      return await this.post(path, data);
    }
    async post(path, data) {
      if (!data) {
        data = {};
      }
      data.chainId = index_1.default.Network?.ChainId;
      data.address = index_1.default.WalletAddress;
      let url = this.getUrl(path);
      let response = await fetch(url, {
        method: 'POST',
        headers: {
          'Authentication': 'Bearer: ' + index_1.default.Bearer,
          'Content-Type': 'application/json;charset=UTF-8'
        },
        body: JSON.stringify(data)
      });
      let obj = await response.json();
      if (obj.success) return obj.result;
      throw new Error(obj.error);
    }
    async getAuth(path, data) {
      if (!index_1.default.Bearer) {
        throw new Error('You are not logged in.');
      }
      return this.get(path, data);
    }
    async get(path, data) {
      if (!index_1.default.Bearer) {
        throw new Error('You are not logged in.');
      }
      let params = new URLSearchParams(data);
      if (!params.has('chainId')) {
        params.set('chainId', index_1.default.Network.ChainId.toString());
      }
      if (!params.has('address')) {
        params.set('address', index_1.default.WalletAddress);
      }
      let response = await fetch(this.getUrl(path) + '?' + params.toString(), {
        method: 'GET',
        headers: {
          'Authentication': 'Bearer: ' + index_1.default.Bearer,
          'Content-Type': 'application/json'
        }
      });
      let obj = await response.json();
      return obj.result ? obj.result : obj;
    }
    getUrl(path) {
      if (path.startsWith('http')) return path;
      if (!index_1.default.Network) {
        throw new Error('No network available. User connected to unsupported network');
      }
      if (!path.startsWith('/')) path = '/' + path;
      return index_1.default.Network.ServerUrl + path;
    }
    static eventSource;
    static actionMap;
    async listen(method, action) {
      if (!index_1.default.Bearer) {
        throw new Error('You are not logged in.');
      }
      if (!HttpRequest.actionMap) {
        HttpRequest.actionMap = new Map();
      }
      HttpRequest.actionMap.set(method, action);
      if (!HttpRequest.eventSource) {
        HttpRequest.eventSource = new EventSource(this.getUrl('/listenForChanges?jwt=' + index_1.default.Bearer));
        HttpRequest.eventSource.onmessage = async event => {
          if (event.data == 'ok') return;
          this.runActions(event);
        };
      }
    }
    runActions(e) {
      let obj = this.getEventSourceObject(e);
      let action = HttpRequest.actionMap.get(obj.methodName);
      if (action) {
        action(obj);
      }
    }
    getEventSourceObject(e) {
      let data = e.data;
      if (!data || data == 'ok') return;
      try {
        return JSON.parse(data);
      } catch (error) {
        throw new Error('Error parsing event source object:' + e);
      }
    }
  };
  HttpRequest.default = HttpRequest$1;
  return HttpRequest;
}

var NetworkType$1 = {};

var LocalhostNetwork$1 = {};

var LocalhostNetworkDefaults$1 = {};

var TestNetwork$2 = {};

var Network$2 = {};

Object.defineProperty(Network$2, "__esModule", {
  value: true
});
let Network$1 = class Network {
  ServerUrl = "";
  ChainId = 0;
  Name = "";
  ChainName = '';
  NativeCurrencyName = "";
  NativeSymbol = "";
  NativeDecimal = 18;
  RpcUrl = '';
  BlockExplorer = '';
  TestNetwork = true;
  FaucetUrl = '';
  BuyUrl = '';
  KYC_ADDRESS = "";
  AUSD_ADDRESS = "";
  LIMINAL_MARKET_ADDRESS = "";
  MARKET_CALENDAR_ADDRESS = "";
  LM_ADDRESS = '';
  SERVICE_CONTRACT_ADDRESS = '';
  NO_FEE_SERVICE_CONTRACT_ADDRESS = "0x0d82EF4e843c1ca7bd2aa9B2Aa4239bd70b306df";
  static RpcUrl = '';
  static ChainId = 0;
  constructor() {}
  get ChainIdHex() {
    return '0x' + this.ChainId.toString(16);
  }
};
Network$2.default = Network$1;

var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(TestNetwork$2, "__esModule", {
  value: true
});
const Network_1 = __importDefault$5(Network$2);
let TestNetwork$1 = class TestNetwork extends Network_1.default {
  constructor() {
    super();
    this.ServerUrl = "https://testnet.liminal.market";
    this.TestNetwork = true;
  }
};
TestNetwork$2.default = TestNetwork$1;

var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(LocalhostNetworkDefaults$1, "__esModule", {
  value: true
});
const TestNetwork_1$1 = __importDefault$4(TestNetwork$2);
//localhost
class LocalhostNetworkDefaults extends TestNetwork_1$1.default {
  constructor() {
    super();
    this.ChainId = LocalhostNetworkDefaults.ChainId;
    this.Name = "localhost";
    this.ChainName = 'localhost test';
    this.NativeCurrencyName = "Ethereum";
    this.NativeSymbol = "ETH";
    this.NativeDecimal = 18;
    this.RpcUrl = LocalhostNetworkDefaults.RpcUrl;
    this.BlockExplorer = 'https://rinkeby.etherscan.io';
    this.ServerUrl = "http://127.0.0.1:10000";
  }
  static RpcUrl = 'http://127.0.0.1:8545/';
  static ChainId = 31337;
}
LocalhostNetworkDefaults$1.default = LocalhostNetworkDefaults;

var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(LocalhostNetwork$1, "__esModule", {
  value: true
});
const LocalhostNetworkDefaults_1 = __importDefault$3(LocalhostNetworkDefaults$1);
class LocalhostNetwork extends LocalhostNetworkDefaults_1.default {
  constructor() {
    super();
  }
  KYC_ADDRESS = "0xA700528a2B9Bd3126c96378b76f2c99f5F0e0F76";
  AUSD_ADDRESS = "0x7ad1630b2E9F0e5401f220A33B473C7E5551dd3e";
  LIMINAL_MARKET_ADDRESS = "0x19d5ABE7854b01960D4911e6536b26F8A38C3a18";
  MARKET_CALENDAR_ADDRESS = "0x12bA221061255c11EA4895C363633bD43F28F9c3";
  LM_ADDRESS = "0x012c686711d9532f7fD68fe6a40d86477288F1dc";
  SERVICE_CONTRACT_ADDRESS = "0x9B946889657e8f2D943A3841282fBf5751241E85";
  NO_FEE_SERVICE_CONTRACT_ADDRESS = "0x0d82EF4e843c1ca7bd2aa9B2Aa4239bd70b306df";
}
LocalhostNetwork$1.default = LocalhostNetwork;

var MumbaiNetwork$1 = {};

var MumbaiNetworkDefaults$1 = {};

var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(MumbaiNetworkDefaults$1, "__esModule", {
  value: true
});
const TestNetwork_1 = __importDefault$2(TestNetwork$2);
class MumbaiNetworkDefaults extends TestNetwork_1.default {
  constructor() {
    super();
    this.Name = "mumbai";
    this.ChainName = 'Polygon Mumbai';
    this.NativeCurrencyName = "Matic";
    this.NativeSymbol = "MATIC";
    this.NativeDecimal = 18;
    this.BlockExplorer = 'https://mumbai.polygonscan.com/';
    this.FaucetUrl = 'https://faucet.polygon.technology/';
    this.BuyUrl = 'https://www.moonpay.com/buy/matic';
    this.ChainId = MumbaiNetworkDefaults.ChainId;
    this.RpcUrl = MumbaiNetworkDefaults.RpcUrl;
  }
  static RpcUrl = 'https://polygon-mumbai.g.alchemy.com/v2/FILTBk8FT9RzcRVxkMXIg7Ipl8JCNdK2';
  static ChainId = 80001;
}
MumbaiNetworkDefaults$1.default = MumbaiNetworkDefaults;

var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(MumbaiNetwork$1, "__esModule", {
  value: true
});
const MumbaiNetworkDefaults_1 = __importDefault$1(MumbaiNetworkDefaults$1);
class MumbaiNetwork extends MumbaiNetworkDefaults_1.default {
  constructor() {
    super();
  }
  KYC_ADDRESS = "0xA5C844558a93590A32D1110D7031531A0bBf0773";
  AUSD_ADDRESS = "0xc4d1f8D35DB0f0d3E91a3fc8485792F4Df60C387";
  LIMINAL_MARKET_ADDRESS = "0x0D8c3D4F4B29EfC3c54172803dA8a7f1CA2E6189";
  MARKET_CALENDAR_ADDRESS = "0x67Dad7E344C6137DF922924a0aAb26bba862BFDe";
  LM_ADDRESS = "0x808C2F1bBE4C7fE72F77e84F57C346603E63291e";
  SERVICE_CONTRACT_ADDRESS = "0x0827C71852ba59661aAd9f1fab25B377B3f39C40";
  NO_FEE_SERVICE_CONTRACT_ADDRESS = "0x3BBc034e9dC74749000fE384eD504E7d58281065";
}
MumbaiNetwork$1.default = MumbaiNetwork;

var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(NetworkType$1, "__esModule", {
  value: true
});
const LocalhostNetwork_1 = __importDefault(LocalhostNetwork$1);
const MumbaiNetwork_1 = __importDefault(MumbaiNetwork$1);
class NetworkType {
  static Networks = [LocalhostNetwork_1.default, MumbaiNetwork_1.default];
  static getInstance(chainId) {
    let networkInfo = undefined;
    NetworkType.Networks.forEach(networkInfoType => {
      let tmp = new networkInfoType();
      if (tmp.ChainId == chainId) {
        networkInfo = tmp;
      }
    });
    return networkInfo;
  }
}
NetworkType$1.default = NetworkType;

var AccountService = {};

var Helper$1 = {};

Object.defineProperty(Helper$1, "__esModule", {
  value: true
});
class Helper {
  static AddressZero = '0x0000000000000000000000000000000000000000';
  static setCookie(name, value) {
    if (typeof document == 'undefined') return;
    let date = new Date();
    this.deleteCookie(name);
    document.cookie = name + "=" + value + "; expires=Mon, 2 Dec " + (date.getFullYear() + 1) + " 12:00:00 UTC;path=/;SameSite=Strict;";
  }
  static getCookieValue(name) {
    if (typeof document == 'undefined') return;
    return document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)')?.pop() || '';
  }
  static deleteCookie(name) {
    if (typeof document == 'undefined') return;
    document.cookie = name + "=0; expires=Mon, 2 Dec 2020 12:00:00 UTC;path=/";
  }
}
Helper$1.default = Helper;

var hasRequiredAccountService;
function requireAccountService() {
  if (hasRequiredAccountService) return AccountService;
  hasRequiredAccountService = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(AccountService, "__esModule", {
    value: true
  });
  const HttpRequest_1 = __importDefault(requireHttpRequest());
  const index_1 = __importDefault(requireDist());
  const Helper_1 = __importDefault(Helper$1);
  let AccountService$1 = class AccountService {
    signInMessage = "You are logging into Liminal.market.\n\nNonce:";
    httpRequest;
    constructor() {
      this.httpRequest = new HttpRequest_1.default();
    }
    async kycStatus() {
      let result = await this.httpRequest.getAuth("isValidKyc");
      if (!result.isValidKyc && result.status == 'ACTIVE') {
        result.message = 'Kyc status is being written down on blockchain. This can take few minutes. Ask again in few minutes';
      } else if (result.isValidKyc) {
        result.message = 'This account can execute trades';
      } else if (!result.isValidKyc) {
        result.message = 'KYC for this account has not been approved. Current status is ' + result.status;
      }
      if (result.alpacaId) {
        result.brokerId = result.alpacaId;
        delete result.alpacaId;
      }
      return result;
    }
    async login() {
      let account = await this.autoLogin();
      if (account) return account;
      let response = await this.httpRequest.post('/me/nonce', {
        address: index_1.default.WalletAddress
      });
      let signingMessage = this.signInMessage + response.nonce;
      let signedMessage = await index_1.default.Signer.signMessage(signingMessage);
      let loginResponse = await this.httpRequest.post('me/validate', {
        address: index_1.default.WalletAddress,
        signedMessage
      });
      account = loginResponse;
      account.brokerId = loginResponse.alpacaId;
      delete account.alpacaId;
      if (!account.address) {
        throw new Error('Login not successful:' + JSON.stringify(account));
      }
      index_1.default.Bearer = account.token;
      let base64 = btoa(JSON.stringify(account.token));
      Helper_1.default.setCookie('validate', base64);
      return account;
    }
    async fundSandboxAccount(accountFunded) {
      await this.httpRequest.listen('BalanceSet', async obj => {
        if (accountFunded) accountFunded(obj);
      });
      return await this.httpRequest.postAuth('/fundUser');
    }
    async createSandboxAccount(firstName, lastName, email, accountReadyEvent) {
      let response = await this.httpRequest.postAuth("sandboxCreateAccount", {
        given_name: firstName,
        family_name: lastName,
        email_address: email
      });
      if (accountReadyEvent) {
        await this.httpRequest.listen('BalanceSet', async event => {
          accountReadyEvent(event);
        });
      }
      return response;
    }
    async autoLogin() {
      try {
        let validate = Helper_1.default.getCookieValue('validate');
        if (validate) {
          let token = JSON.parse(atob(validate));
          index_1.default.Bearer = token;
          let result = await this.httpRequest.post('/me/jwt');
          if (result.jwt) {
            let account = {};
            account.brokerId = result.alpacaId;
            account.chainId = result.chainId;
            account.token = token;
            account.address = result.address;
            return account;
          }
        }
      } catch (e) {
        Helper_1.default.deleteCookie('validate');
      }
      return;
    }
  };
  AccountService.default = AccountService$1;
  return AccountService;
}

var BlockchainService$1 = {};

var hasRequiredBlockchainService;
function requireBlockchainService() {
  if (hasRequiredBlockchainService) return BlockchainService$1;
  hasRequiredBlockchainService = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(BlockchainService$1, "__esModule", {
    value: true
  });
  const ethers_1 = require$$0$1;
  const index_1 = __importDefault(requireDist());
  const HttpRequest_1 = __importDefault(requireHttpRequest());
  class BlockchainService {
    httpRequest;
    constructor() {
      this.httpRequest = new HttpRequest_1.default();
    }
    async executeOrder(side, symbol, quantity) {
      if (symbol.toLowerCase() == 'ausd') {
        throw new Error('You cannot send order for aUSD.');
      }
      let amountOrQty = 'quantity';
      let qty = ethers_1.ethers.utils.formatEther(quantity);
      if (side == 'buy') {
        amountOrQty = 'amount';
        qty = '$' + qty;
      }
      let time = new Date();
      let signMessage = `I confirm following order:\n${side} ${symbol} for the ${amountOrQty} of ${qty}

---------------
ChainId:${index_1.default.Network.ChainId}
ServiceContract:${index_1.default.ServiceContractAddress}
Time:${time.toISOString()}
`;
      let signedMessage = await index_1.default.Signer.signMessage(signMessage);
      return await this.httpRequest.postAuth('/executeOrder', {
        signedMessage: signedMessage,
        side: side,
        symbol: symbol,
        qty: quantity,
        spender: index_1.default.ServiceContractAddress,
        chainId: index_1.default.Network.ChainId,
        time: time.getTime()
      });
    }
  }
  BlockchainService$1.default = BlockchainService;
  return BlockchainService$1;
}

var abis = {};

Object.defineProperty(abis, "__esModule", {
  value: true
});
class Abis {
  static LiminalMarketExternalServiceAbi = [{
    "inputs": [{
      "internalType": "address",
      "name": "walletAddress",
      "type": "address"
    }, {
      "internalType": "string",
      "name": "symbol",
      "type": "string"
    }, {
      "internalType": "uint256",
      "name": "amount",
      "type": "uint256"
    }],
    "name": "buySecurityToken",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }, {
    "inputs": [{
      "internalType": "address",
      "name": "walletAddress",
      "type": "address"
    }, {
      "internalType": "string",
      "name": "symbol",
      "type": "string"
    }, {
      "internalType": "uint256",
      "name": "quantity",
      "type": "uint256"
    }],
    "name": "sellSecurityToken",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }];
  static LiminalMarketAbi = [{
    "anonymous": false,
    "inputs": [{
      "indexed": false,
      "internalType": "string",
      "name": "orderId",
      "type": "string"
    }, {
      "indexed": false,
      "internalType": "address",
      "name": "recipient",
      "type": "address"
    }, {
      "indexed": false,
      "internalType": "string",
      "name": "symbol",
      "type": "string"
    }, {
      "indexed": false,
      "internalType": "uint256",
      "name": "tsl",
      "type": "uint256"
    }, {
      "indexed": false,
      "internalType": "uint256",
      "name": "filledQty",
      "type": "uint256"
    }, {
      "indexed": false,
      "internalType": "uint256",
      "name": "filledAvgPrice",
      "type": "uint256"
    }, {
      "indexed": false,
      "internalType": "string",
      "name": "side",
      "type": "string"
    }, {
      "indexed": false,
      "internalType": "uint256",
      "name": "filledAt",
      "type": "uint256"
    }, {
      "indexed": false,
      "internalType": "uint256",
      "name": "serviceFee",
      "type": "uint256"
    }, {
      "indexed": false,
      "internalType": "uint256",
      "name": "aUsdBalance",
      "type": "uint256"
    }, {
      "indexed": false,
      "internalType": "address",
      "name": "spender",
      "type": "address"
    }],
    "name": "OrderExecuted",
    "type": "event"
  }, {
    "inputs": [{
      "internalType": "string",
      "name": "symbol",
      "type": "string"
    }],
    "name": "getSecurityToken",
    "outputs": [{
      "internalType": "address",
      "name": "",
      "type": "address"
    }],
    "stateMutability": "view",
    "type": "function"
  }];
  static BalanceOfAbi = [{
    "inputs": [{
      "internalType": "address",
      "name": "account",
      "type": "address"
    }],
    "name": "balanceOf",
    "outputs": [{
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }],
    "stateMutability": "view",
    "type": "function"
  }];
}
abis.default = Abis;

var Listener$1 = {};

var hasRequiredListener;
function requireListener() {
  if (hasRequiredListener) return Listener$1;
  hasRequiredListener = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(Listener$1, "__esModule", {
    value: true
  });
  const HttpRequest_1 = __importDefault(requireHttpRequest());
  class Listener {
    static httpRequest = new HttpRequest_1.default();
    static set onUpdatingAUsdOnChain(action) {
      this.httpRequest.listen('UpdatingAUsdOnChain', async event => {
        await action(event);
      });
    }
    static set onBalanceSet(action) {
      this.httpRequest.listen('BalanceSet', async event => {
        await action(event);
      });
    }
    static set onOrderSentToMarket(action) {
      this.httpRequest.listen('OrderSentToMarket', async event => {
        await action(event);
      });
    }
    static set onOrderExecutedWritingToChain(action) {
      this.httpRequest.listen('OrderExecutedWritingBlockchain', async event => {
        await action(event);
      });
    }
    static set onOrderExecuted(action) {
      this.httpRequest.listen('OrderExecuted', async event => {
        await action(event);
      });
    }
  }
  Listener$1.default = Listener;
  return Listener$1;
}

var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(dist, "__esModule", {
    value: true
  });
  const ethers_1 = require$$0$1;
  const HttpRequest_1 = __importDefault(requireHttpRequest());
  const NetworkType_1 = __importDefault(NetworkType$1);
  const TestNetwork_1 = __importDefault(TestNetwork$2);
  const AccountService_1 = __importDefault(requireAccountService());
  const BlockchainService_1 = __importDefault(requireBlockchainService());
  const abis_1 = __importDefault(abis);
  const Listener_1 = __importDefault(requireListener());
  class LiminalMarket {
    httpRequest;
    blockchainService;
    accountService;
    account;
    static Provider;
    static Signer;
    static ServiceContractAddress;
    static Network;
    static WalletAddress;
    static Bearer;
    static Instance;
    constructor() {
      this.httpRequest = new HttpRequest_1.default();
      this.blockchainService = new BlockchainService_1.default();
      this.accountService = new AccountService_1.default();
      this.account = {};
    }
    static async getInstanceUsingPrivateKey(privateKey, chainId, serviceContractAddress) {
      LiminalMarket.Network = NetworkType_1.default.getInstance(chainId) ?? new TestNetwork_1.default();
      if (LiminalMarket.Network.ChainId == 0) {
        throw new Error('Network is not supported. Using chainId ' + chainId + '. Try switching to different network, e.g. Mumbai');
      }
      let provider = new ethers_1.ethers.providers.JsonRpcProvider(LiminalMarket.Network.RpcUrl);
      let wallet = new ethers_1.Wallet(privateKey, provider);
      return await this.getInstanceByWallet(wallet, serviceContractAddress);
    }
    static async getInstance(provider, serviceContractAddress) {
      if (!provider) {
        // @ts-ignore
        provider = new ethers_1.ethers.providers.Web3Provider(window.ethereum);
      }
      let signer = await provider.getSigner();
      if (!signer) {
        throw new Error('Provider needs to have a signer.');
      }
      let address = await signer.getAddress();
      if (!address) {
        throw new Error('No account could be access');
      }
      let network = await provider.getNetwork();
      return await this.load(address, provider, signer, network.chainId, serviceContractAddress);
    }
    static async getInstanceByWallet(wallet, serviceContractAddress) {
      if (this.Instance) return this.Instance;
      if (!wallet) {
        throw new Error('Provider cannot be null');
      }
      let chainId = await wallet.getChainId();
      return await this.load(wallet.address, wallet.provider, wallet, chainId, serviceContractAddress);
    }
    static async load(walletAddress, provider, signer, chainId, serviceContractAddress) {
      LiminalMarket.Provider = provider;
      LiminalMarket.Signer = signer;
      LiminalMarket.Network = NetworkType_1.default.getInstance(chainId) ?? new TestNetwork_1.default();
      if (LiminalMarket.Network.ChainId == 0) {
        throw new Error('Network is not supported. Using chainId ' + chainId + '. Try switching to different network, e.g. Mumbai');
      }
      LiminalMarket.ServiceContractAddress = serviceContractAddress ? serviceContractAddress : LiminalMarket.Network.NO_FEE_SERVICE_CONTRACT_ADDRESS;
      if (!LiminalMarket.ServiceContractAddress) {
        throw new Error('ServiceContractAddress cannot be empty. You can get service contract address by signing contract at https://liminal.market/contract. No cost (except gas)');
      }
      if (LiminalMarket.ServiceContractAddress == LiminalMarket.Network.NO_FEE_SERVICE_CONTRACT_ADDRESS) {
        console.debug('No service contract address set. You will not receive any service fee. Check out https://liminal.market/contract/');
      }
      LiminalMarket.WalletAddress = walletAddress;
      let liminalMarket = new LiminalMarket();
      liminalMarket.account = await liminalMarket.accountService.login();
      this.Instance = liminalMarket;
      return liminalMarket;
    }
    static get Listener() {
      return Listener_1.default;
    }
    /**
     * Return true if market is open, else false
     */
    async isMarketOpen() {
      return (await this.httpRequest.get('isOpen')).marketIsOpen;
    }
    /**
     * Returns true if the user has been created at the broker, false if he does not exist at broker
     * If it returns false, you can call createSandboxAccount to create the user at broker.
     */
    hasAccount() {
      return this.account.brokerId !== undefined;
    }
    /**
     * Create user on sandbox at the broker. This is for running on Mumbai testnet.
     *
     * @param {function} accountReadyEvent - function is called when the account is ready
     */
    async createSandboxAccount(firstName, lastName, email, accountReadyEvent) {
      return await this.accountService.createSandboxAccount(firstName, lastName, email, accountReadyEvent);
    }
    /**
     * Returns the status of the account. Most important is if KYC has been approved.
     * Trades cannot be executed if KYC is not valid.
     */
    async kycStatus() {
      let accountService = new AccountService_1.default();
      return await accountService.kycStatus();
    }
    /**
     * Funds wallets sandbox account. There are limitation on how frequently you can fund your account.
     **/
    async fundSandboxAccount(accountFunded) {
      return await this.accountService.fundSandboxAccount(accountFunded);
    }
    /**
     * Get the balance of aUSD token.
     * @param {string} [address] - Optional. Uses the address from the provider is address is not provided
     */
    async getAUSDBalance(address) {
      if (!address) address = LiminalMarket.WalletAddress;
      return await this.getSecurityTokenQuantity(LiminalMarket.Network.AUSD_ADDRESS, address);
    }
    /**
     * Return all symbols available in the system.
     */
    async getSymbols() {
      return await this.httpRequest.get('https://app.liminal.market/securities/securities.json');
    }
    /**
     * Returns the position wallet address has. It is also possible to query any wallet address
     * @param address
     */
    async getPositions(address) {
      if (!address) address = LiminalMarket.WalletAddress;
      return await this.httpRequest.get('positions', {
        address: address
      });
    }
    /**
     * Get the balance of a security token.
     * @param {string} [address] - Optional. Uses the address from the provider is address is not provided
     */
    async getSecurityTokenQuantity(symbolOrAddress, address) {
      if (!address) address = LiminalMarket.WalletAddress;
      if (symbolOrAddress.indexOf('0x') == -1) {
        symbolOrAddress = await this.getSecurityTokenAddress(symbolOrAddress);
        if (symbolOrAddress == ethers_1.ethers.constants.AddressZero) return ethers_1.BigNumber.from(0);
      }
      const contract = new ethers_1.ethers.Contract(symbolOrAddress, abis_1.default.BalanceOfAbi, LiminalMarket.Provider);
      return await contract['balanceOf'](address);
    }
    /**
     * Get the address of a security token (symbol)
     */
    async getSecurityTokenAddress(symbol) {
      const contract = new ethers_1.ethers.Contract(LiminalMarket.Network.LIMINAL_MARKET_ADDRESS, abis_1.default.LiminalMarketAbi, LiminalMarket.Provider);
      return await contract['getSecurityToken'](symbol);
    }
    /**
     * Send the command to buy a security token
     * @param {string}  symbol - Symbol of the security to buy, e.g. AAPL for Apple.
     * @param {string}  amount - Dollar amount in Wei, $100 is equal to 100 * 10**18. Buying for $54.32 would be 5432 * 10**16
     * @param {function} [orderExecutedEvent] - Optional. Listens for the orderExecuted event on chain, then calls your function.
     *
     * */
    async buySecurityToken(symbol, amount) {
      return await this.blockchainService.executeOrder('buy', symbol, amount);
    }
    /**
     * Send the command to sell a security token
     * @param {string}  symbol - Symbol of the security to buy, e.g. AAPL for Apple.
     * @param {string}  quantity - Quantity of shares to sell in Wei. Selling 10 shares would be 10 * 10**18. Selling 1.234 shares would be 123 * 10*15
     * @param {function} [orderExecutedEvent] - Optional. Listens for the orderExecuted event on chain, then calls your function.
     *
     * */
    async sellSecurityToken(symbol, quantity) {
      return await this.blockchainService.executeOrder('sell', symbol, quantity);
    }
    /**
     * Send the command to execute order depending on side (buy or sell)
     * @param {string}  symbol - Symbol of the security to buy, e.g. AAPL for Apple.
     * @param {string}  quantity - Quantity of shares to sell in Wei. Selling 10 shares would be 10 * 10**18. Selling 1.234 shares would be 123 * 10*15
     * @param {function} [orderExecutedEvent] - Optional. Listens for the orderExecuted event on chain, then calls your function.
     *
     * */
    async executeOrder(side, symbol, quantity) {
      if (side != 'buy' && side != 'sell') {
        throw new Error('side [' + side + '] is not valid. You can only set "buy" or "sell"');
      }
      return await this.blockchainService.executeOrder(side, symbol, quantity);
    }
  }
  dist.default = LiminalMarket;
  return dist;
}

var distExports = requireDist();
var LiminalMarket = /*@__PURE__*/getDefaultExportFromCjs(distExports);

class AuthenticateService extends BaseService {
    constructor() {
        super();
    }
    static async enableWeb3() {
        if (WidgetGlobals.User.connector)
            return WidgetGlobals.User.connector;
        let magicWeb3Connector = new MagicWeb3Connector();
        let connector = await magicWeb3Connector.activate();
        WidgetGlobals.User.connector = connector;
        WidgetGlobals.User.magic = connector.magic;
        WidgetGlobals.User.provider = connector.provider;
        WidgetGlobals.User.ether = connector.ether;
        WidgetGlobals.User.signer = connector.signer;
        return connector;
    }
    async logOut() {
        let cookieHelper = new CookieHelper(document);
        cookieHelper.deleteCookie("validate");
        if (!WidgetGlobals.User.ether) {
            let connection = await AuthenticateService.enableWeb3();
            WidgetGlobals.User.magic = connection.magic;
        }
        WidgetGlobals.User.magic?.connect.disconnect();
        WidgetGlobals.User = new User(null, "", WidgetGlobals.Network.ChainId, "");
    }
    async login() {
        let connector = await AuthenticateService.enableWeb3();
        WidgetGlobals.User = new User(connector.provider, connector.account, connector.chainId, connector.ether);
        WidgetGlobals.User.magic = connector.magic;
        WidgetGlobals.User.signer = connector.signer;
        WidgetGlobals.User.isLoggedIn = true;
    }
    async isAuthenticated() {
        let provider = await AuthenticateService.enableWeb3();
        let liminalMarket = await LiminalMarket.getInstance(provider.ether, "0x19d5ABE7854b01960D4911e6536b26F8A38C3a18");
        if (liminalMarket.account.token == "")
            return false;
        WidgetGlobals.LiminalMarket = liminalMarket;
        WidgetGlobals.User.address = liminalMarket.account.address;
        WidgetGlobals.User.alpacaId = liminalMarket.account.brokerId;
        WidgetGlobals.User.chainId = liminalMarket.account.chainId;
        WidgetGlobals.User.token = liminalMarket.account.token;
        WidgetGlobals.User.isLoggedIn = true;
        console.log("liminalMarket.account.token", liminalMarket.account.token);
        return liminalMarket;
    }
    async authenticateUser(enableWeb3Callback, authenticatedCallback) {
        let connector = await AuthenticateService.enableWeb3();
        let liminalMarket = await this.isAuthenticated();
        if (!liminalMarket) {
            await this.logOut();
            return;
        }
        if (enableWeb3Callback && connector.provider) {
            enableWeb3Callback(connector.provider);
        }
        if (connector.chainId != WidgetGlobals.Network.ChainId) {
            let userNetwork = NetworkInfo.getNetworkInfoByChainId(connector.chainId);
            if (userNetwork) {
                NetworkInfo.setNetworkByChainId(connector.chainId);
            }
            else {
                let modal = new SwitchNetworkModal();
                modal.show();
                return;
            }
        }
        WidgetGlobals.User.setValidate(liminalMarket.account.token);
        if (authenticatedCallback) {
            authenticatedCallback();
        }
        else {
            location.reload();
        }
    }
}

class localhostContractAddresses {
    KYC_ADDRESS = "0xA700528a2B9Bd3126c96378b76f2c99f5F0e0F76";
    AUSD_ADDRESS = "0x7ad1630b2E9F0e5401f220A33B473C7E5551dd3e";
    LIMINAL_MARKET_ADDRESS = "0x19d5ABE7854b01960D4911e6536b26F8A38C3a18";
    MARKET_CALENDAR_ADDRESS = "0x12bA221061255c11EA4895C363633bD43F28F9c3";
}

class mumbaiContractAddresses {
    KYC_ADDRESS = "0xA5C844558a93590A32D1110D7031531A0bBf0773";
    AUSD_ADDRESS = "0xc4d1f8D35DB0f0d3E91a3fc8485792F4Df60C387";
    LIMINAL_MARKET_ADDRESS = "0x0D8c3D4F4B29EfC3c54172803dA8a7f1CA2E6189";
    MARKET_CALENDAR_ADDRESS = "0x67Dad7E344C6137DF922924a0aAb26bba862BFDe";
}

class fujiContractAddresses {
    KYC_ADDRESS = "0x0594D04FDB5C98Fb7F777a799139424Ae2414AaD";
    AUSD_ADDRESS = "0xbAc482aE0b0d652854df377be566445984A021ED";
    LIMINAL_MARKET_ADDRESS = "0x098A512B017408008a23ECe22843788799CDebFd";
    MARKET_CALENDAR_ADDRESS = "0x77E6A62Be8398B18d2dA81CDB6Eb097bD8132ccB";
}

class polygonContractAddresses {
    KYC_ADDRESS = "0xc7dA98E282cc30BD4fe0a7dE38372F876DB577E4";
    AUSD_ADDRESS = "0x9B780e71C2a8492E805e17616EB878f2e3874E21";
    LIMINAL_MARKET_ADDRESS = "0x8B4fc0bcaED76a6569525d8Fe51E57cAd32FDd94";
    MARKET_CALENDAR_ADDRESS = "0x77b54CbF3e1370af13da41196B4d99cd02eBcC44";
}

class ContractInfo {
    static getContractInfo(networkName) {
        let contractInfos = {
            localhostContractAddresses,
            mumbaiContractAddresses,
            fujiContractAddresses,
            polygonContractAddresses,
        };
        if (!networkName) {
            networkName = WidgetGlobals.Network.Name;
        }
        const contractInfoType = contractInfos[networkName + "ContractAddresses"];
        return new contractInfoType();
    }
}

let EventService$1 = class EventService {
    contracts;
    constructor() {
        this.contracts = ContractInfo.getContractInfo(WidgetGlobals.Network.Name);
    }
    subscribeToBuy(hash) {
        this.listen(hash, "BuyWithAUsd");
    }
    subscribeToSell(hash) {
        this.listen(hash, "SellSecurityToken");
    }
    listen(hash, eventName) {
        this.store(hash);
        const lmContract = new Contract(this.contracts.LIMINAL_MARKET_ADDRESS, this.lmAbi, WidgetGlobals.User.signer);
        let listeners = lmContract.listeners(eventName);
        if (listeners.length > 0) {
            return;
        }
        lmContract.on(eventName, (walletAddress, amount, accountId, symbol, tokenAddress, spender) => {
            console.log(eventName + " event");
            lmContract.off(eventName, WidgetGlobals.User.provider);
            this.remove(hash);
        });
    }
    store(hash) {
        if (!window.localStorage)
            return;
        let hashes = [];
        let obj = window.localStorage.getItem("hashes");
        if (obj) {
            hashes = JSON.parse(obj);
        }
        hashes.push(hash);
        window.localStorage.setItem("hashes", JSON.stringify(hashes));
    }
    remove(hash) {
        if (!window.localStorage)
            return;
        let json = window.localStorage.getItem("hashes");
        if (!json)
            return;
        let hashes = JSON.parse(json);
        let idx = hashes.indexOf(hash);
        hashes.splice(idx, 1);
        if (hashes.length == 0) {
            window.localStorage.removeItem("hashes");
        }
        else {
            window.localStorage.setItem("hashes", JSON.stringify(hashes));
        }
    }
    lmAbi = [
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: "address",
                    name: "walletAddress",
                    type: "address",
                },
                {
                    indexed: false,
                    internalType: "uint256",
                    name: "amount",
                    type: "uint256",
                },
                {
                    indexed: false,
                    internalType: "string",
                    name: "accountId",
                    type: "string",
                },
                {
                    indexed: false,
                    internalType: "string",
                    name: "symbol",
                    type: "string",
                },
                {
                    indexed: false,
                    internalType: "address",
                    name: "tokenAddress",
                    type: "address",
                },
                {
                    indexed: false,
                    internalType: "address",
                    name: "spender",
                    type: "address",
                },
            ],
            name: "BuyWithAUsd",
            type: "event",
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: "string",
                    name: "accountId",
                    type: "string",
                },
                {
                    indexed: false,
                    internalType: "address",
                    name: "walletAddress",
                    type: "address",
                },
                {
                    indexed: false,
                    internalType: "address",
                    name: "aUsdAddress",
                    type: "address",
                },
                {
                    indexed: false,
                    internalType: "string",
                    name: "symbol",
                    type: "string",
                },
                {
                    indexed: false,
                    internalType: "uint256",
                    name: "amount",
                    type: "uint256",
                },
                {
                    indexed: false,
                    internalType: "address",
                    name: "spender",
                    type: "address",
                },
            ],
            name: "SellSecurityToken",
            type: "event",
        },
    ];
};

class BlockchainService extends BaseService {
    network;
    contracts;
    constructor() {
        super();
        this.network = WidgetGlobals.Network;
        this.contracts = ContractInfo.getContractInfo(this.network.Name);
    }
    async getBalanceOf(tokenAddress, ethAddress) {
        await this.loadEther();
        if (!WidgetGlobals.User.ether) {
            return BigNumber.from(0);
        }
        const contract = new Contract(tokenAddress, this.balanceOfAbi, WidgetGlobals.User.ether);
        return await contract.balanceOf(ethAddress);
    }
    async transferInner(tokenAddress, to, qty) {
        await this.loadEther();
        let qtyWei = parseUnits(qty.toString(), "ether");
        console.log("transferInner", qtyWei.toString(), tokenAddress, to);
        const contract = new Contract(tokenAddress, this.transferAbi, WidgetGlobals.User.signer);
        let result = await contract.transfer(to, qtyWei);
        let eventService = new EventService$1();
        if (tokenAddress == this.contracts.AUSD_ADDRESS) {
            eventService.subscribeToBuy(result.hash);
        }
        else {
            eventService.subscribeToSell(result.hash);
        }
        console.log("transfer result", result);
        return result;
    }
    async loadEther() {
        if (WidgetGlobals.User.ether)
            return;
        await AuthenticateService.enableWeb3();
    }
    async getNativeBalance() {
        const balanceInWei = await WidgetGlobals.User.ether.getBalance(WidgetGlobals.User.address);
        const balanceInEther = formatEther(balanceInWei);
        return balanceInEther;
    }
    balanceOfAbi = [
        {
            inputs: [
                {
                    internalType: "address",
                    name: "account",
                    type: "address",
                },
            ],
            name: "balanceOf",
            outputs: [
                {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
    ];
    transferAbi = ["function transfer(address to, uint amount)"];
}

class Network {
    ServerUrl = "";
    AppId = "";
    ChainId = 0;
    Name = "";
    ChainName = '';
    NativeCurrencyName = "";
    NativeSymbol = "";
    NativeDecimal = 18;
    RpcUrl = '';
    BlockExplorer = '';
    TestNetwork = true;
    FaucetUrl = '';
    BuyUrl = '';
    constructor() {
    }
    get ChainIdHex() {
        return '0x' + this.ChainId.toString(16);
    }
    async addNetworkToWallet() {
        const web3 = await AuthenticateService.enableWeb3();
        if (!web3 || !web3.provider.request)
            return;
        web3.provider.request({
            method: 'wallet_addEthereumChain',
            params: [{
                    chainId: '0x' + this.ChainId.toString(16),
                    chainName: this.ChainName,
                    nativeCurrency: {
                        name: this.NativeCurrencyName,
                        symbol: this.NativeSymbol,
                        decimals: this.NativeDecimal
                    },
                    rpcUrls: [this.RpcUrl],
                    blockExplorerUrls: [this.BlockExplorer]
                }]
        }).catch((error) => {
            console.log(error);
        });
    }
    async hasEnoughNativeTokens() {
        let blockchainService = new BlockchainService();
        let balanceNative = await blockchainService.getNativeBalance();
        const balance = parseFloat(balanceNative);
        if (balance < 0.005) {
            return false;
        }
        return true;
    }
    ;
}

class TestNetwork extends Network {
    constructor() {
        super();
        this.ServerUrl = "https://testnet.liminal.market";
        this.TestNetwork = true;
    }
}

//localhost
class localhostNetwork extends TestNetwork {
    constructor() {
        super();
        this.ChainId = 31337;
        this.Name = "localhost";
        this.ChainName = 'localhost test';
        this.NativeCurrencyName = "Ethereum";
        this.NativeSymbol = "ETH";
        this.NativeDecimal = 18;
        this.RpcUrl = 'http://127.0.0.1:8545/';
        this.BlockExplorer = 'https://rinkeby.etherscan.io';
        this.ServerUrl = "http://localhost:10000";
    }
}

class mumbaiNetwork extends TestNetwork {
    constructor() {
        super();
        this.ChainId = 80001;
        this.Name = "mumbai";
        this.ChainName = "Polygon Mumbai";
        this.NativeCurrencyName = "Matic";
        this.NativeSymbol = "MATIC";
        this.NativeDecimal = 18;
        this.RpcUrl =
            "https://polygon-mumbai.g.alchemy.com/v2/FILTBk8FT9RzcRVxkMXIg7Ipl8JCNdK2";
        this.BlockExplorer = "https://mumbai.polygonscan.com/";
        this.FaucetUrl = "https://faucet.polygon.technology/";
        this.BuyUrl = "https://www.moonpay.com/buy/matic";
    }
}

const networkInfos = [localhostNetwork, mumbaiNetwork];
class NetworkInfo {
    static instance;
    constructor() {
    }
    static getInstance() {
        if (NetworkInfo.instance)
            return NetworkInfo.instance;
        NetworkInfo.instance = this.getNetworkInfo();
        return NetworkInfo.instance;
    }
    static loadNetwork(networkName) {
        NetworkInfo.instance = this.getNetworkInfo(networkName);
        this.setNetworkByChainId(NetworkInfo.instance.ChainId);
    }
    static setNetworkByName(name) {
        let network = this.getNetworkByName(name);
        this.setNetworkByChainId(network.ChainId);
    }
    static setNetworkByChainId(chainId) {
        let network = this.getNetworkInfoByChainId(chainId);
        if (network) {
            NetworkInfo.instance = network;
            console.log('setCookie', network.Name);
            let cookieHelper = new CookieHelper(document);
            cookieHelper.setCookie('network', network.Name);
        }
    }
    static getNetworks(networkType) {
        let networks = new Array();
        let isLocalhost = window.location.host.indexOf('localhost') != -1;
        networkInfos.forEach(networkInfoType => {
            let tmp = new networkInfoType();
            if (!isLocalhost && tmp.Name == "localhost")
                return;
            if (networkType === undefined) {
                networks.push(tmp);
            }
            else {
                if (networkType == NetworkType$2.Mainnet && !tmp.TestNetwork) {
                    networks.push(tmp);
                }
                else if (networkType == NetworkType$2.Testnet && tmp.TestNetwork) {
                    networks.push(tmp);
                }
            }
        });
        return networks;
    }
    static getNetworkInfoByChainId(chainId) {
        let networkInfo;
        networkInfos.forEach(networkInfoType => {
            let tmp = new networkInfoType();
            if (tmp.ChainId == chainId) {
                networkInfo = tmp;
            }
        });
        return networkInfo;
    }
    static getNetworkInfo(networkName) {
        let cookieHelper = new CookieHelper(document);
        // @ts-ignore
        if (window.ethereum && window.ethereum.chainId) {
            // @ts-ignore
            let networkInfo = this.getNetworkNameByChainIdHex(window.ethereum.chainId);
            if (networkInfo) {
                return networkInfo;
            }
        }
        if (!networkName)
            networkName = cookieHelper.getCookieValue('network');
        if (!networkName)
            networkName = 'mumbai';
        let networkInfo = this.getNetworkByName(networkName);
        return networkInfo;
    }
    static getNetworkNameByChainIdHex(chainIdHex) {
        let networkInfo = undefined;
        networkInfos.forEach(networkInfoType => {
            let tmp = new networkInfoType();
            if (tmp.ChainIdHex == chainIdHex) {
                networkInfo = tmp;
            }
        });
        return networkInfo;
    }
    static getNetworkByName(networkName) {
        let networkInfo = null;
        networkInfos.forEach(networkInfoType => {
            let tmp = new networkInfoType();
            if (tmp.Name == networkName) {
                networkInfo = tmp;
            }
        });
        if (networkInfo)
            return networkInfo;
        console.error("Network '" + networkName + "' could not be found. Defaulting to Mumbai network.");
        return new mumbaiNetwork();
    }
}

class UserService extends BaseService {
    static signedMessage = "signedMessage";
    constructor() {
        super();
    }
    async isMarketOpenOrUserOffHours() {
        return await WidgetGlobals.LiminalMarket.isMarketOpen();
    }
    getUser() {
        let cookieHelper = new CookieHelper(document);
        let signedMessage = cookieHelper.getCookieValue("signedMessage");
        if (!signedMessage) {
            WidgetGlobals.User = new User(null, "", WidgetGlobals.Network.ChainId, null);
            return WidgetGlobals.User;
        }
        const signingAddress = recoverAddress("", signedMessage);
        WidgetGlobals.User = new User(null, signingAddress, WidgetGlobals.Network.ChainId, null);
        return WidgetGlobals.User;
    }
    async load(address) {
        let response = await fetch("https://app.liminal.market/user", {
            body: address,
        });
        await response.json();
    }
    async getAlpacaId() {
        let user = await this.getUser();
        if (user.alpacaId)
            return user.alpacaId;
        let result = (await fetch("https://app.liminal.market/"));
        user.alpacaId = result.alpacaId;
        return user.alpacaId;
    }
    async getAccount() {
        return await this.get("account");
    }
    getEthAddress() {
        return WidgetGlobals.User.address;
    }
    async kycActionRequired() {
        let kycResults = (await this.get("kycActionRequired"));
        return kycResults;
    }
    async updateName(given_name, middle_name, family_name) {
        return await this.post("updateName", {
            given_name: given_name,
            middle_name: middle_name,
            family_name: family_name,
        });
    }
    async updateContact(data) {
        return await this.post("updateContact", data);
    }
    async updateTrustedContact(data) {
        return await this.post("updateTrustedContact", data);
    }
    async createAchRelationship(account_owner_name, bank_account_type, bank_account_number, bank_routing_number) {
        return await this.post("createAchRelationship", {
            account_owner_name,
            bank_account_type,
            bank_account_number,
            bank_routing_number,
        });
    }
    async getBankRelationship() {
        return (await this.get("getBankRelationship"));
    }
    async getLatestTransfers(direction) {
        return (await this.get("getTransfers", {
            direction: direction,
        }));
    }
    async createTransfer(amount, direction) {
        return await this.post("createTransfer", {
            amount: amount,
            direction: direction,
        });
    }
    async deleteTransfer(id) {
        return await this.post("deleteTransfer", { id: id });
    }
    async registerWireTransferRelationship(params) {
        return await this.post("createWireRelationship", params);
    }
}

var UserInfoElement = "<div id=\"userMenuPanel\">\n    <a href=\"#\" id=\"userInfoAction\" aria-expanded=\"false\">\n        <img src=\"https://effigy.im/a/{{ethAddress}}.png\" width=\"24\">\n        <span id=\"user_info_ethAddress\">{{shortEthAddress}}</span>\n    </a>\n\n    <div id=\"userInfoDropdown\" class=\"d-none\">\n        <div class=\"grid account_info\">\n            <h6>Account</h6>\n            <a id=\"disconnectFromNetwork\" href=\"#\">Disconnect</a>\n\n        </div>\n        <div class=\"edit_account\">\n            <a id=\"editName\" href=\"#\">Edit name</a><br>\n            <a id=\"editContact\" href=\"#\">Edit contact info</a><br>\n            <a id=\"editTrustedContact\" href=\"#\">Edit trusted contact</a>\n        </div>\n        <hr>\n        <div class=\"grid\">\n            <div>\n                <img src=\"https://effigy.im/a/{{ethAddress}}.png\">\n            </div>\n            <div>\n                <strong class=\"d-block\"><a href=\"{{blockchainExplorer}}{{ethAddress}}\" target=\"_blank\">{{shortEthAddress}}</a></strong>\n                <br>\n                {{#if isMagic}}\n                <a href=\"#\" id=\"wallet\">Open my wallet</a>\n                {{/if}}\n                <a href=\"https://info.liminal.market/#/chain/{{chainId}}/{{ethAddress}}\" target=\"_blank\">View\n                    positions</a>\n            </div>\n        </div>\n        <hr>\n        <div class=\"hidden\" id=\"userInfoAUsdBalance\">\n            <div class=\"grid\">\n                <div><img src=\"https://app.liminal.market/img/ausd.png\"></div>\n                <div>\n                    <strong class=\"d-block\">aUSD <span id=\"user_info_ausd_balance\"></span></strong>\n                    <a href=\"\" class=\"add_aUSD_to_wallet\">Add aUSD to wallet</a>\n                </div>\n            </div>\n            <div id=\"fund_account_options\">\n                <h6>Fund your account</h6>\n                <div class=\"grid\">\n                    <a href=\"#\" class=\"fund_account\">Fund my account</a>\n                    <!--\n                    <a href=\"#\" id=\"withdraw_from_account\">Withdraw from account</a>\n                    -->\n                </div>\n            </div>\n            <hr>\n        </div>\n        <div class=\"grid\">\n            <strong class=\"d-block\">Network</strong>\n            <small>{{networkName}}<br>\n                <!--\n                <a href=\"#\" id=\"switch_network\">Change network</a>\n                -->\n            </small>\n        </div>\n\n    </div>\n\n</div>";

var utils = {};

var require$$0 = /*@__PURE__*/getAugmentedNamespace(lib_esm$c);

var require$$1 = /*@__PURE__*/getAugmentedNamespace(lib_esm$g);

var require$$2 = /*@__PURE__*/getAugmentedNamespace(lib_esm$e);

var require$$3 = /*@__PURE__*/getAugmentedNamespace(lib_esm$9);

var require$$4 = /*@__PURE__*/getAugmentedNamespace(lib_esm$k);

var require$$5 = /*@__PURE__*/getAugmentedNamespace(lib_esm$d);

var require$$6 = /*@__PURE__*/getAugmentedNamespace(lib_esm$7);

var require$$7 = /*@__PURE__*/getAugmentedNamespace(lib_esm$5);

var require$$8 = /*@__PURE__*/getAugmentedNamespace(lib_esm$i);

var require$$9 = /*@__PURE__*/getAugmentedNamespace(lib_esm$l);

var require$$10 = /*@__PURE__*/getAugmentedNamespace(lib_esm$8);

var require$$11 = /*@__PURE__*/getAugmentedNamespace(lib_esm$2);

var require$$12 = /*@__PURE__*/getAugmentedNamespace(lib_esm$6);

var require$$13 = /*@__PURE__*/getAugmentedNamespace(lib_esm$j);

var require$$14 = /*@__PURE__*/getAugmentedNamespace(lib_esm$h);

var require$$15 = /*@__PURE__*/getAugmentedNamespace(lib_esm$b);

var require$$16 = /*@__PURE__*/getAugmentedNamespace(lib_esm$f);

var require$$17 = /*@__PURE__*/getAugmentedNamespace(lib_esm$a);

var require$$18 = /*@__PURE__*/getAugmentedNamespace(lib_esm$1);

var require$$19 = /*@__PURE__*/getAugmentedNamespace(lib_esm$4);

var require$$20 = /*@__PURE__*/getAugmentedNamespace(lib_esm$3);

(function (exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function () {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
  exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
  var abi_1 = require$$0;
  Object.defineProperty(exports, "AbiCoder", {
    enumerable: true,
    get: function () {
      return abi_1.AbiCoder;
    }
  });
  Object.defineProperty(exports, "checkResultErrors", {
    enumerable: true,
    get: function () {
      return abi_1.checkResultErrors;
    }
  });
  Object.defineProperty(exports, "ConstructorFragment", {
    enumerable: true,
    get: function () {
      return abi_1.ConstructorFragment;
    }
  });
  Object.defineProperty(exports, "defaultAbiCoder", {
    enumerable: true,
    get: function () {
      return abi_1.defaultAbiCoder;
    }
  });
  Object.defineProperty(exports, "ErrorFragment", {
    enumerable: true,
    get: function () {
      return abi_1.ErrorFragment;
    }
  });
  Object.defineProperty(exports, "EventFragment", {
    enumerable: true,
    get: function () {
      return abi_1.EventFragment;
    }
  });
  Object.defineProperty(exports, "FormatTypes", {
    enumerable: true,
    get: function () {
      return abi_1.FormatTypes;
    }
  });
  Object.defineProperty(exports, "Fragment", {
    enumerable: true,
    get: function () {
      return abi_1.Fragment;
    }
  });
  Object.defineProperty(exports, "FunctionFragment", {
    enumerable: true,
    get: function () {
      return abi_1.FunctionFragment;
    }
  });
  Object.defineProperty(exports, "Indexed", {
    enumerable: true,
    get: function () {
      return abi_1.Indexed;
    }
  });
  Object.defineProperty(exports, "Interface", {
    enumerable: true,
    get: function () {
      return abi_1.Interface;
    }
  });
  Object.defineProperty(exports, "LogDescription", {
    enumerable: true,
    get: function () {
      return abi_1.LogDescription;
    }
  });
  Object.defineProperty(exports, "ParamType", {
    enumerable: true,
    get: function () {
      return abi_1.ParamType;
    }
  });
  Object.defineProperty(exports, "TransactionDescription", {
    enumerable: true,
    get: function () {
      return abi_1.TransactionDescription;
    }
  });
  var address_1 = require$$1;
  Object.defineProperty(exports, "getAddress", {
    enumerable: true,
    get: function () {
      return address_1.getAddress;
    }
  });
  Object.defineProperty(exports, "getCreate2Address", {
    enumerable: true,
    get: function () {
      return address_1.getCreate2Address;
    }
  });
  Object.defineProperty(exports, "getContractAddress", {
    enumerable: true,
    get: function () {
      return address_1.getContractAddress;
    }
  });
  Object.defineProperty(exports, "getIcapAddress", {
    enumerable: true,
    get: function () {
      return address_1.getIcapAddress;
    }
  });
  Object.defineProperty(exports, "isAddress", {
    enumerable: true,
    get: function () {
      return address_1.isAddress;
    }
  });
  var base64 = __importStar(require$$2);
  exports.base64 = base64;
  var basex_1 = require$$3;
  Object.defineProperty(exports, "base58", {
    enumerable: true,
    get: function () {
      return basex_1.Base58;
    }
  });
  var bytes_1 = require$$4;
  Object.defineProperty(exports, "arrayify", {
    enumerable: true,
    get: function () {
      return bytes_1.arrayify;
    }
  });
  Object.defineProperty(exports, "concat", {
    enumerable: true,
    get: function () {
      return bytes_1.concat;
    }
  });
  Object.defineProperty(exports, "hexConcat", {
    enumerable: true,
    get: function () {
      return bytes_1.hexConcat;
    }
  });
  Object.defineProperty(exports, "hexDataSlice", {
    enumerable: true,
    get: function () {
      return bytes_1.hexDataSlice;
    }
  });
  Object.defineProperty(exports, "hexDataLength", {
    enumerable: true,
    get: function () {
      return bytes_1.hexDataLength;
    }
  });
  Object.defineProperty(exports, "hexlify", {
    enumerable: true,
    get: function () {
      return bytes_1.hexlify;
    }
  });
  Object.defineProperty(exports, "hexStripZeros", {
    enumerable: true,
    get: function () {
      return bytes_1.hexStripZeros;
    }
  });
  Object.defineProperty(exports, "hexValue", {
    enumerable: true,
    get: function () {
      return bytes_1.hexValue;
    }
  });
  Object.defineProperty(exports, "hexZeroPad", {
    enumerable: true,
    get: function () {
      return bytes_1.hexZeroPad;
    }
  });
  Object.defineProperty(exports, "isBytes", {
    enumerable: true,
    get: function () {
      return bytes_1.isBytes;
    }
  });
  Object.defineProperty(exports, "isBytesLike", {
    enumerable: true,
    get: function () {
      return bytes_1.isBytesLike;
    }
  });
  Object.defineProperty(exports, "isHexString", {
    enumerable: true,
    get: function () {
      return bytes_1.isHexString;
    }
  });
  Object.defineProperty(exports, "joinSignature", {
    enumerable: true,
    get: function () {
      return bytes_1.joinSignature;
    }
  });
  Object.defineProperty(exports, "zeroPad", {
    enumerable: true,
    get: function () {
      return bytes_1.zeroPad;
    }
  });
  Object.defineProperty(exports, "splitSignature", {
    enumerable: true,
    get: function () {
      return bytes_1.splitSignature;
    }
  });
  Object.defineProperty(exports, "stripZeros", {
    enumerable: true,
    get: function () {
      return bytes_1.stripZeros;
    }
  });
  var hash_1 = require$$5;
  Object.defineProperty(exports, "_TypedDataEncoder", {
    enumerable: true,
    get: function () {
      return hash_1._TypedDataEncoder;
    }
  });
  Object.defineProperty(exports, "dnsEncode", {
    enumerable: true,
    get: function () {
      return hash_1.dnsEncode;
    }
  });
  Object.defineProperty(exports, "hashMessage", {
    enumerable: true,
    get: function () {
      return hash_1.hashMessage;
    }
  });
  Object.defineProperty(exports, "id", {
    enumerable: true,
    get: function () {
      return hash_1.id;
    }
  });
  Object.defineProperty(exports, "isValidName", {
    enumerable: true,
    get: function () {
      return hash_1.isValidName;
    }
  });
  Object.defineProperty(exports, "namehash", {
    enumerable: true,
    get: function () {
      return hash_1.namehash;
    }
  });
  var hdnode_1 = require$$6;
  Object.defineProperty(exports, "defaultPath", {
    enumerable: true,
    get: function () {
      return hdnode_1.defaultPath;
    }
  });
  Object.defineProperty(exports, "entropyToMnemonic", {
    enumerable: true,
    get: function () {
      return hdnode_1.entropyToMnemonic;
    }
  });
  Object.defineProperty(exports, "getAccountPath", {
    enumerable: true,
    get: function () {
      return hdnode_1.getAccountPath;
    }
  });
  Object.defineProperty(exports, "HDNode", {
    enumerable: true,
    get: function () {
      return hdnode_1.HDNode;
    }
  });
  Object.defineProperty(exports, "isValidMnemonic", {
    enumerable: true,
    get: function () {
      return hdnode_1.isValidMnemonic;
    }
  });
  Object.defineProperty(exports, "mnemonicToEntropy", {
    enumerable: true,
    get: function () {
      return hdnode_1.mnemonicToEntropy;
    }
  });
  Object.defineProperty(exports, "mnemonicToSeed", {
    enumerable: true,
    get: function () {
      return hdnode_1.mnemonicToSeed;
    }
  });
  var json_wallets_1 = require$$7;
  Object.defineProperty(exports, "getJsonWalletAddress", {
    enumerable: true,
    get: function () {
      return json_wallets_1.getJsonWalletAddress;
    }
  });
  var keccak256_1 = require$$8;
  Object.defineProperty(exports, "keccak256", {
    enumerable: true,
    get: function () {
      return keccak256_1.keccak256;
    }
  });
  var logger_1 = require$$9;
  Object.defineProperty(exports, "Logger", {
    enumerable: true,
    get: function () {
      return logger_1.Logger;
    }
  });
  var sha2_1 = require$$10;
  Object.defineProperty(exports, "computeHmac", {
    enumerable: true,
    get: function () {
      return sha2_1.computeHmac;
    }
  });
  Object.defineProperty(exports, "ripemd160", {
    enumerable: true,
    get: function () {
      return sha2_1.ripemd160;
    }
  });
  Object.defineProperty(exports, "sha256", {
    enumerable: true,
    get: function () {
      return sha2_1.sha256;
    }
  });
  Object.defineProperty(exports, "sha512", {
    enumerable: true,
    get: function () {
      return sha2_1.sha512;
    }
  });
  var solidity_1 = require$$11;
  Object.defineProperty(exports, "solidityKeccak256", {
    enumerable: true,
    get: function () {
      return solidity_1.keccak256;
    }
  });
  Object.defineProperty(exports, "solidityPack", {
    enumerable: true,
    get: function () {
      return solidity_1.pack;
    }
  });
  Object.defineProperty(exports, "soliditySha256", {
    enumerable: true,
    get: function () {
      return solidity_1.sha256;
    }
  });
  var random_1 = require$$12;
  Object.defineProperty(exports, "randomBytes", {
    enumerable: true,
    get: function () {
      return random_1.randomBytes;
    }
  });
  Object.defineProperty(exports, "shuffled", {
    enumerable: true,
    get: function () {
      return random_1.shuffled;
    }
  });
  var properties_1 = require$$13;
  Object.defineProperty(exports, "checkProperties", {
    enumerable: true,
    get: function () {
      return properties_1.checkProperties;
    }
  });
  Object.defineProperty(exports, "deepCopy", {
    enumerable: true,
    get: function () {
      return properties_1.deepCopy;
    }
  });
  Object.defineProperty(exports, "defineReadOnly", {
    enumerable: true,
    get: function () {
      return properties_1.defineReadOnly;
    }
  });
  Object.defineProperty(exports, "getStatic", {
    enumerable: true,
    get: function () {
      return properties_1.getStatic;
    }
  });
  Object.defineProperty(exports, "resolveProperties", {
    enumerable: true,
    get: function () {
      return properties_1.resolveProperties;
    }
  });
  Object.defineProperty(exports, "shallowCopy", {
    enumerable: true,
    get: function () {
      return properties_1.shallowCopy;
    }
  });
  var RLP = __importStar(require$$14);
  exports.RLP = RLP;
  var signing_key_1 = require$$15;
  Object.defineProperty(exports, "computePublicKey", {
    enumerable: true,
    get: function () {
      return signing_key_1.computePublicKey;
    }
  });
  Object.defineProperty(exports, "recoverPublicKey", {
    enumerable: true,
    get: function () {
      return signing_key_1.recoverPublicKey;
    }
  });
  Object.defineProperty(exports, "SigningKey", {
    enumerable: true,
    get: function () {
      return signing_key_1.SigningKey;
    }
  });
  var strings_1 = require$$16;
  Object.defineProperty(exports, "formatBytes32String", {
    enumerable: true,
    get: function () {
      return strings_1.formatBytes32String;
    }
  });
  Object.defineProperty(exports, "nameprep", {
    enumerable: true,
    get: function () {
      return strings_1.nameprep;
    }
  });
  Object.defineProperty(exports, "parseBytes32String", {
    enumerable: true,
    get: function () {
      return strings_1.parseBytes32String;
    }
  });
  Object.defineProperty(exports, "_toEscapedUtf8String", {
    enumerable: true,
    get: function () {
      return strings_1._toEscapedUtf8String;
    }
  });
  Object.defineProperty(exports, "toUtf8Bytes", {
    enumerable: true,
    get: function () {
      return strings_1.toUtf8Bytes;
    }
  });
  Object.defineProperty(exports, "toUtf8CodePoints", {
    enumerable: true,
    get: function () {
      return strings_1.toUtf8CodePoints;
    }
  });
  Object.defineProperty(exports, "toUtf8String", {
    enumerable: true,
    get: function () {
      return strings_1.toUtf8String;
    }
  });
  Object.defineProperty(exports, "Utf8ErrorFuncs", {
    enumerable: true,
    get: function () {
      return strings_1.Utf8ErrorFuncs;
    }
  });
  var transactions_1 = require$$17;
  Object.defineProperty(exports, "accessListify", {
    enumerable: true,
    get: function () {
      return transactions_1.accessListify;
    }
  });
  Object.defineProperty(exports, "computeAddress", {
    enumerable: true,
    get: function () {
      return transactions_1.computeAddress;
    }
  });
  Object.defineProperty(exports, "parseTransaction", {
    enumerable: true,
    get: function () {
      return transactions_1.parse;
    }
  });
  Object.defineProperty(exports, "recoverAddress", {
    enumerable: true,
    get: function () {
      return transactions_1.recoverAddress;
    }
  });
  Object.defineProperty(exports, "serializeTransaction", {
    enumerable: true,
    get: function () {
      return transactions_1.serialize;
    }
  });
  Object.defineProperty(exports, "TransactionTypes", {
    enumerable: true,
    get: function () {
      return transactions_1.TransactionTypes;
    }
  });
  var units_1 = require$$18;
  Object.defineProperty(exports, "commify", {
    enumerable: true,
    get: function () {
      return units_1.commify;
    }
  });
  Object.defineProperty(exports, "formatEther", {
    enumerable: true,
    get: function () {
      return units_1.formatEther;
    }
  });
  Object.defineProperty(exports, "parseEther", {
    enumerable: true,
    get: function () {
      return units_1.parseEther;
    }
  });
  Object.defineProperty(exports, "formatUnits", {
    enumerable: true,
    get: function () {
      return units_1.formatUnits;
    }
  });
  Object.defineProperty(exports, "parseUnits", {
    enumerable: true,
    get: function () {
      return units_1.parseUnits;
    }
  });
  var wallet_1 = require$$19;
  Object.defineProperty(exports, "verifyMessage", {
    enumerable: true,
    get: function () {
      return wallet_1.verifyMessage;
    }
  });
  Object.defineProperty(exports, "verifyTypedData", {
    enumerable: true,
    get: function () {
      return wallet_1.verifyTypedData;
    }
  });
  var web_1 = require$$20;
  Object.defineProperty(exports, "_fetchData", {
    enumerable: true,
    get: function () {
      return web_1._fetchData;
    }
  });
  Object.defineProperty(exports, "fetchJson", {
    enumerable: true,
    get: function () {
      return web_1.fetchJson;
    }
  });
  Object.defineProperty(exports, "poll", {
    enumerable: true,
    get: function () {
      return web_1.poll;
    }
  });
  ////////////////////////
  // Enums
  var sha2_2 = require$$10;
  Object.defineProperty(exports, "SupportedAlgorithm", {
    enumerable: true,
    get: function () {
      return sha2_2.SupportedAlgorithm;
    }
  });
  var strings_2 = require$$16;
  Object.defineProperty(exports, "UnicodeNormalizationForm", {
    enumerable: true,
    get: function () {
      return strings_2.UnicodeNormalizationForm;
    }
  });
  Object.defineProperty(exports, "Utf8ErrorReason", {
    enumerable: true,
    get: function () {
      return strings_2.Utf8ErrorReason;
    }
  });
})(utils);

const roundNumber = function (number) {
    return Math.round(number * 100) / 100;
};
const roundNumberDecimal = function (number, decimal) {
    let hundred = parseInt("1" + "0".repeat(decimal));
    return Math.round(number * hundred) / hundred;
};
const roundBigNumber = function (number) {
    return BigNumber.from(Math.round(parseFloat(utils.formatUnits(number)) * 100) / 100);
};
const roundBigNumberDecimal = function (number, decimal) {
    let hundred = parseInt("1" + "0".repeat(decimal));
    return BigNumber.from(Math.round(parseFloat(utils.formatUnits(number)) * hundred) / hundred);
};
const AddressZero = "0x0000000000000000000000000000000000000000";
const isJSON = function (str) {
    try {
        return JSON.parse(str);
    }
    catch (e) {
        return false;
    }
};
const shortEth = function (ethAddress) {
    if (!ethAddress)
        return "";
    return (ethAddress.substring(0, 6) +
        "..." +
        ethAddress.substring(ethAddress.length - 4));
};

var KycEditNameHtml = "<fieldset id=\"kycEditName\">\n    <div class=\"warningBar\">\n        <strong>Warning</strong><br>\n        You can only change the name once. Be careful of what you change.\n        <br><br>\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\n        trades\n        until it has been approved.\n    </div>\n    <div>\n        <label for=\"given_name\">Legal First name</label>\n        <input required id=\"given_name\" name=\"given_name\" placeholder=\"Ron\" value=\"{{given_name}}\" autocomplete=\"given-name\">\n    </div>\n    <div>\n        <label for=\"middle_name\">Legal Middle name</label>\n        <input id=\"middle_name\" name=\"middle_name\" placeholder=\"\" value=\"{{middle_name}}\" autocomplete=\"additional-name\">\n    </div>\n    <div>\n        <label for=\"family_name\">Legal Last name</label>\n        <input required id=\"family_name\" name=\"family_name\" placeholder=\"Swanson\" value=\"{{family_name}}\" autocomplete=\"family-name\">\n    </div>\n\n    <div class=\"buttons\">\n        <button id=\"kycEditNameConfirm\">Confirm</button>\n    </div>\n</fieldset>\n\n<fieldset class=\"hidden\" id=\"confirmNameFieldset\">\n    <div class=\"confirm_name\">\n        <label for=\"confirm_name\" id=\"label_confirm_name\">Please type</label>\n        <input name=\"confirm_name\" id=\"confirm_name\">\n    </div>\n\n    <div class=\"input_error\" id=\"kycEditNameError\"></div>\n\n    <div class=\"buttons grid\">\n        <button id=\"kycEditNameBack\">Back</button>\n        <button type=\"submit\" id=\"kycEditNameSave\">Confirm</button>\n    </div>\n</fieldset>";

class StringHelper {
    static isNullOrEmpty(str) {
        return !str || str.toString().trim().length == 0;
    }
}

class KycEditNameForm {
    modal;
    constructor() {
        this.modal = new Modal();
    }
    async show() {
        let kycEditNameError = document.getElementById("kycEditNameError");
        if (kycEditNameError)
            kycEditNameError.style.display = "none";
        let userService = new UserService();
        let account = await userService.getAccount();
        let given_name = account.identity.given_name;
        let middle_name = account.identity.middle_name;
        let family_name = account.identity.family_name;
        let template = WidgetGlobals.HandlebarsInstance.compile(KycEditNameHtml);
        let content = template({
            given_name: given_name,
            middle_name: middle_name,
            family_name: family_name,
        });
        this.modal.showModal("Edit name", content);
        this.bindEvents();
    }
    bindEvents() {
        let kycEditNameConfirm = document.getElementById("kycEditNameConfirm");
        kycEditNameConfirm?.addEventListener("click", async (evt) => {
            let given_name = document.getElementById("given_name");
            document.getElementById("middle_name");
            let family_name = document.getElementById("family_name");
            if (StringHelper.isNullOrEmpty(given_name.value)) {
                this.showError("Given name cannot be empty");
                return;
            }
            if (StringHelper.isNullOrEmpty(family_name.value)) {
                this.showError("Family name cannot be empty");
                return;
            }
            let full_name = this.getFullName();
            let label_confirm_name = document.getElementById("label_confirm_name");
            if (!label_confirm_name) {
                //TODO: report error in form
                return;
            }
            label_confirm_name.innerHTML =
                'Please type in the full name "' +
                    full_name +
                    '" in the box below to confirm. You WILL NOT be able to change it again.';
            document
                .getElementById("confirmNameFieldset")
                ?.classList.remove("hidden");
            document.getElementById("kycEditName")?.classList.add("hidden");
        });
        let kycEditNameBack = document.getElementById("kycEditNameBack");
        kycEditNameBack?.addEventListener("click", (evt) => {
            document.getElementById("confirmNameFieldset")?.classList.add("hidden");
            document.getElementById("kycEditName")?.classList.remove("hidden");
        });
        let confirm_name = document.getElementById("confirm_name");
        if (!confirm_name) {
            //TODO: report error in form
            return;
        }
        let kycEditNameSave = document.getElementById("kycEditNameSave");
        kycEditNameSave.disabled = true;
        confirm_name.setAttribute("aria-invalid", "true");
        confirm_name.addEventListener("keyup", (evt) => {
            if (confirm_name.value == this.getFullName()) {
                confirm_name.setAttribute("aria-invalid", "false");
                kycEditNameSave.disabled = false;
            }
            else {
                confirm_name.setAttribute("aria-invalid", "true");
                kycEditNameSave.disabled = true;
            }
        });
        kycEditNameSave?.addEventListener("click", async (evt) => {
            let confirm_name = document.getElementById("confirm_name");
            if (confirm_name && confirm_name.value != this.getFullName()) {
                alert(confirm_name.value +
                    " is not same as " +
                    this.getFullName() +
                    ". Go over the name and make sure it is identical");
                return;
            }
            let given_name = document.getElementById("given_name");
            let middle_name = document.getElementById("middle_name");
            let family_name = document.getElementById("family_name");
            LoadingHelper.setLoading(kycEditNameSave);
            let userService = new UserService();
            await userService
                .updateName(given_name.value, middle_name.value, family_name.value)
                .then((response) => {
                if (response.message) {
                    this.showError(response.message);
                    return;
                }
                this.modal.hideModal();
            })
                .catch((reason) => {
                if (reason.message) {
                    this.showError(JSON.parse(reason.message).message);
                }
                else {
                    this.showError(reason);
                }
            })
                .finally(() => {
                LoadingHelper.removeLoading();
            });
        });
    }
    showError(message) {
        let kycEditNameError = document.getElementById("kycEditNameError");
        if (!kycEditNameError)
            return;
        kycEditNameError.innerHTML = message;
        kycEditNameError.style.display = "block";
    }
    getFullName() {
        let given_name = document.getElementById("given_name");
        let middle_name = document.getElementById("middle_name");
        let family_name = document.getElementById("family_name");
        return (given_name.value +
            " " +
            (!StringHelper.isNullOrEmpty(middle_name.value)
                ? middle_name.value + " "
                : "") +
            family_name.value);
    }
}

var KycEditContactFormHtml = "<fieldset id=\"kycEditContactFieldset\">\n    <div class=\"warningBar\">\n        <strong>Warning</strong><br>\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\n        trades until it has been approved.\n    </div>\n    <form id=\"kycEditContactForm\">\n        <div>\n            <label for=\"email_address\">Email</label>\n            <input type=\"email\" required class=\"form-control\" id=\"email_address\" name=\"email_address\" placeholder=\"name@example.com\" autocomplete=\"email\" value=\"\">\n        </div>\n        <div>\n            <label for=\"phone_number\">Phone</label>\n            <input type=\"tel\" class=\"form-control\" id=\"phone_number\" name=\"phone_number\" placeholder=\"+1-555-666-7788\" autocomplete=\"tel\" value=\"\">\n        </div>\n        <div>\n            <label for=\"street_address\">Permanent Residential Address</label>\n            <div class=\"explain\">It must be a physical address, not a PO box.</div>\n            <input required id=\"street_address\" name=\"street_address\" placeholder=\"20 N San Mateo Dr\" value=\"\" autocomplete=\"address-line1\">\n        </div>\n        <div>\n            <label for=\"unit\">Unit / Apt #</label>\n            <input id=\"unit\" name=\"unit\" value=\"\">\n        </div>\n        <div>\n            <label for=\"city\">City</label>\n            <input id=\"city\" name=\"city\" placeholder=\"Pawnee\" value=\"\" autocomplete=\"address-level2\">\n        </div>\n        <div>\n            <label for=\"postal_code\">Postal code</label>\n            <input required id=\"postal_code\" autocomplete=\"postal-code\" name=\"postal_code\" placeholder=\"94401\" value=\"\">\n        </div>\n        {{#if usa}}\n        <div id=\"state_div\">\n            <label for=\"state\">State (2 letters)</label>\n            <input required maxlength=\"2\" id=\"state\" name=\"state\" placeholder=\"NY\" value=\"\" autocomplete=\"address-level1\">\n        </div>\n        {{/if}}\n        <div class=\"input_error\" id=\"kycEditContactError\"></div>\n        <div class=\"buttons\">\n            <button type=\"submit\" id=\"kycEditContactSave\">Save</button>\n        </div>\n    </form>\n</fieldset>";

class FormHelper {
    static getParams(selector) {
        let form = document.querySelector(selector);
        if (!form)
            return;
        let data = new FormData(form);
        return this.serialize(data);
    }
    static serialize(data) {
        let obj = {};
        for (let [key, value] of data) {
            if (obj[key] !== undefined) {
                if (!Array.isArray(obj[key])) {
                    obj[key] = [obj[key]];
                }
                obj[key].push(value);
            }
            else {
                obj[key] = value;
            }
        }
        return obj;
    }
    static fillInputs(properties, item) {
        properties.forEach((value) => {
            let input = document.querySelector('input[name=' + value + ']');
            if (input) {
                if (input.type == 'radio') {
                    console.log('checkbox', input, item[value]);
                    input.value = item[value];
                }
                else {
                    input.value = item[value];
                }
                input.dispatchEvent(new Event('change'));
            }
            else {
                let select = document.querySelector('select[name=' + value + ']');
                if (select) {
                    select.value = item[value];
                    select.dispatchEvent(new Event('change'));
                }
            }
        });
    }
    static validate(selector) {
        let inputs = document.querySelectorAll(selector + ' input[required], ' + selector + ' select[required]');
        for (let i = 0; i < inputs.length; i++) {
            let input = inputs[i];
            input.setAttribute('aria-invalid', 'false');
            if (StringHelper.isNullOrEmpty(input.value)) {
                input.setAttribute('aria-invalid', 'true');
                input.focus();
                input.addEventListener('change', (evt) => {
                    if (!StringHelper.isNullOrEmpty(input.value)) {
                        input.setAttribute('aria-invalid', 'false');
                    }
                });
                return false;
            }
        }
        return true;
    }
}

class KycEditContactForm {
    modal;
    constructor() {
        this.modal = new Modal();
    }
    async show() {
        let userService = new UserService();
        let account = await userService.getAccount();
        let usa = account.identity.country_of_tax_residence == "USA";
        let template = WidgetGlobals.HandlebarsInstance.compile(KycEditContactFormHtml);
        this.modal.showModal("Edit contact information", template({ usa: usa }));
        let contactProperties = Object.getOwnPropertyNames(account.contact);
        FormHelper.fillInputs(contactProperties, account.contact);
        this.bindEvents();
    }
    bindEvents() {
        let kycEditContactSave = document.getElementById("kycEditContactSave");
        kycEditContactSave?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            if (!this.validate())
                return;
            LoadingHelper.setLoading(kycEditContactSave);
            let data = FormHelper.getParams("#kycEditContactForm");
            let userService = new UserService();
            await userService
                .updateContact(data)
                .then((response) => {
                if (response.message) {
                    this.showError(response.message);
                    return;
                }
                let accountInfo = response;
                let email_address = document.getElementById("email_address");
                if (accountInfo.contact.email_address != email_address?.value) {
                    this.showError("Email was not changed. The email " +
                        email_address?.value +
                        " is already registered under different account.");
                    return;
                }
                this.modal.hideModal();
            })
                .catch((reason) => {
                if (reason.message) {
                    this.showError(JSON.parse(reason.message).message);
                }
                else {
                    this.showError(reason);
                }
            })
                .finally(() => {
                LoadingHelper.removeLoading();
            });
        });
    }
    showError(message) {
        let kycEditNameError = document.getElementById("kycEditContactError");
        if (!kycEditNameError)
            return;
        kycEditNameError.innerHTML = message;
        kycEditNameError.style.display = "block";
    }
    validate() {
        let inputs = document.querySelectorAll("#kycEditContactFieldset input[required]");
        for (let i = 0; i < inputs.length; i++) {
            let input = inputs[i];
            if (StringHelper.isNullOrEmpty(input.value)) {
                input.setAttribute("aria-invalid", "true");
                input.addEventListener("change", (evt) => {
                    if (!StringHelper.isNullOrEmpty(input.value)) {
                        input.setAttribute("aria-invalid", "false");
                    }
                });
                return false;
            }
        }
        return true;
    }
}

var KycEditTrustedContactHtml = "<fieldset class=\"kycTrustedContact\">\n    <div class=\"warningBar\">\n        <strong>Warning</strong><br>\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\n        trades until it has been approved.\n    </div>\n\n    <form id=\"kycTrustedContactForm\" method=\"post\">\n        <div class=\"explain\">\n            A trusted contact is a person you authorize your financial firm to contact in limited circumstances,\n            such as if there is a concern about activity in your account and they have been unable to get in touch with\n            you.\n            <br><br>\n            A trusted contact may be a family member, attorney, accountant or another third-party who you believe would\n            respect your privacy and know how to handle the responsibility.\n            The trusted person should be 18 years old or older.\n        </div>\n        <div>\n            <label for=\"given_name\">Legal given name of trusted contact</label>\n            <input required id=\"given_name\" name=\"given_name\">\n        </div>\n        <div>\n            <label for=\"family_name\">Legal family name of trusted contact</label>\n            <input required id=\"family_name\" name=\"family_name\">\n        </div>\n        <div>\n            If you fill in name, you are required to fill in one of the following, email, phone or address\n        </div>\n        <div class=\"input_error\" id=\"contact_missing_info\"></div>\n        <div>\n            <label for=\"email_address\">Email of trusted contact</label>\n            <input id=\"email_address\" type=\"email\" name=\"email_address\">\n        </div>\n        <div>\n            <label for=\"phone_number\">Phone of trusted contact</label>\n            <input id=\"phone_number\" type=\"tel\" name=\"phone_number\">\n        </div>\n        <div>\n            <label for=\"street_address\">Address of trusted contact</label>\n            <input id=\"street_address\" name=\"street_address\">\n        </div>\n        <div>\n            <label for=\"city\">City of trusted contact</label>\n            <input id=\"city\" name=\"city\">\n        </div>\n        <div>\n            <label for=\"state\">State of trusted contact</label>\n            <input id=\"state\" name=\"state\">\n        </div>\n        <div>\n            <label for=\"postal_code\">Postal code of trusted contact</label>\n            <input id=\"postal_code\" name=\"postal_code\">\n        </div>\n        <div>\n            <label for=\"country\">Country of trusted contact</label>\n            <select required id=\"country\" required name=\"country\">\n                <option value=\"\"></option>\n                {{#each countries}}\n                <option value=\"{{code}}\">{{name}}</option>\n                {{/each}}\n            </select>\n        </div>\n        <div class=\"input_error\" id=\"kycEditNameError\"></div>\n        <div class=\"buttons\">\n            <button type=\"submit\" id=\"trustedContactSubmit\">Submit</button>\n        </div>\n    </form>\n</fieldset>";

class CountryHelper {
    static Countries = [
        { "name": "United States of America", "code": "USA" },
        { "name": "United Kingdom", "code": "GBR" },
        { "name": "Afghanistan", "code": "AFG" }, { "name": "Albania", "code": "ALB" }, {
            "name": "Algeria",
            "code": "DZA"
        }, { "name": "American Samoa", "code": "ASM" }, { "name": "Andorra", "code": "AND" }, {
            "name": "Angola",
            "code": "AGO"
        }, { "name": "Anguilla", "code": "AIA" }, { "name": "Antarctica", "code": "ATA" }, {
            "name": "Antigua and Barbuda",
            "code": "ATG"
        }, { "name": "Argentina", "code": "ARG" }, { "name": "Armenia", "code": "ARM" }, {
            "name": "Aruba",
            "code": "ABW"
        }, { "name": "Australia", "code": "AUS" }, { "name": "Austria", "code": "AUT" }, {
            "name": "Azerbaijan",
            "code": "AZE"
        }, { "name": "Åland Islands", "code": "ALA" }, { "name": "Bahamas", "code": "BHS" }, {
            "name": "Bahrain",
            "code": "BHR"
        }, { "name": "Bangladesh", "code": "BGD" }, { "name": "Barbados", "code": "BRB" }, {
            "name": "Belarus",
            "code": "BLR"
        }, { "name": "Belgium", "code": "BEL" }, { "name": "Belize", "code": "BLZ" }, {
            "name": "Benin",
            "code": "BEN"
        }, { "name": "Bermuda", "code": "BMU" }, {
            "name": "Bhutan",
            "code": "BTN"
        }, { "name": "Bolivia (Plurinational State of)", "code": "BOL" }, {
            "name": "Bonaire, Sint Eustatius and Saba",
            "code": "BES"
        }, { "name": "Bosnia and Herzegovina", "code": "BIH" }, {
            "name": "Botswana",
            "code": "BWA"
        }, { "name": "Bouvet Island", "code": "BVT" }, {
            "name": "Brazil",
            "code": "BRA"
        }, { "name": "British Indian Ocean Territory", "code": "IOT" }, {
            "name": "Brunei Darussalam",
            "code": "BRN"
        }, { "name": "Bulgaria", "code": "BGR" }, { "name": "Burkina Faso", "code": "BFA" }, {
            "name": "Burundi",
            "code": "BDI"
        }, { "name": "Cabo Verde", "code": "CPV" }, { "name": "Cambodia", "code": "KHM" }, {
            "name": "Cameroon",
            "code": "CMR"
        }, { "name": "Canada", "code": "CAN" }, {
            "name": "Cayman Islands",
            "code": "CYM"
        }, { "name": "Central African Republic", "code": "CAF" }, { "name": "Chad", "code": "TCD" }, {
            "name": "Chile",
            "code": "CHL"
        }, { "name": "China", "code": "CHN" }, {
            "name": "Christmas Island",
            "code": "CXR"
        }, { "name": "Cocos (Keeling) Islands", "code": "CCK" }, { "name": "Colombia", "code": "COL" }, {
            "name": "Comoros",
            "code": "COM"
        }, { "name": "Congo (the Democratic Republic of the)", "code": "COD" }, {
            "name": "Congo",
            "code": "COG"
        }, { "name": "Cook Islands", "code": "COK" }, { "name": "Costa Rica", "code": "CRI" }, {
            "name": "Croatia",
            "code": "HRV"
        }, { "name": "Cuba", "code": "CUB" }, { "name": "Curaçao", "code": "CUW" }, {
            "name": "Cyprus",
            "code": "CYP"
        }, { "name": "Czechia", "code": "CZE" }, { "name": "Côte d'Ivoire", "code": "CIV" }, {
            "name": "Denmark",
            "code": "DNK"
        }, { "name": "Djibouti", "code": "DJI" }, { "name": "Dominica", "code": "DMA" }, {
            "name": "Dominican Republic",
            "code": "DOM"
        }, { "name": "Ecuador", "code": "ECU" }, { "name": "Egypt", "code": "EGY" }, {
            "name": "El Salvador",
            "code": "SLV"
        }, { "name": "Equatorial Guinea", "code": "GNQ" }, { "name": "Eritrea", "code": "ERI" }, {
            "name": "Estonia",
            "code": "EST"
        }, { "name": "Eswatini", "code": "SWZ" }, {
            "name": "Ethiopia",
            "code": "ETH"
        }, { "name": "Falkland Islands [Malvinas]", "code": "FLK" }, {
            "name": "Faroe Islands",
            "code": "FRO"
        }, { "name": "Fiji", "code": "FJI" }, { "name": "Finland", "code": "FIN" }, {
            "name": "France",
            "code": "FRA"
        }, { "name": "French Guiana", "code": "GUF" }, {
            "name": "French Polynesia",
            "code": "PYF"
        }, { "name": "French Southern Territories", "code": "ATF" }, { "name": "Gabon", "code": "GAB" }, {
            "name": "Gambia",
            "code": "GMB"
        }, { "name": "Georgia", "code": "GEO" }, { "name": "Germany", "code": "DEU" }, {
            "name": "Ghana",
            "code": "GHA"
        }, { "name": "Gibraltar", "code": "GIB" }, { "name": "Greece", "code": "GRC" }, {
            "name": "Greenland",
            "code": "GRL"
        }, { "name": "Grenada", "code": "GRD" }, { "name": "Guadeloupe", "code": "GLP" }, {
            "name": "Guam",
            "code": "GUM"
        }, { "name": "Guatemala", "code": "GTM" }, { "name": "Guernsey", "code": "GGY" }, {
            "name": "Guinea",
            "code": "GIN"
        }, { "name": "Guinea-Bissau", "code": "GNB" }, { "name": "Guyana", "code": "GUY" }, {
            "name": "Haiti",
            "code": "HTI"
        }, { "name": "Heard Island and McDonald Islands", "code": "HMD" }, {
            "name": "Holy See",
            "code": "VAT"
        }, { "name": "Honduras", "code": "HND" }, { "name": "Hong Kong", "code": "HKG" }, {
            "name": "Hungary",
            "code": "HUN"
        }, { "name": "Iceland", "code": "ISL" }, { "name": "India", "code": "IND" }, {
            "name": "Indonesia",
            "code": "IDN"
        }, { "name": "Iran (Islamic Republic of)", "code": "IRN" }, { "name": "Iraq", "code": "IRQ" }, {
            "name": "Ireland",
            "code": "IRL"
        }, { "name": "Isle of Man", "code": "IMN" }, { "name": "Israel", "code": "ISR" }, {
            "name": "Italy",
            "code": "ITA"
        }, { "name": "Jamaica", "code": "JAM" }, { "name": "Japan", "code": "JPN" }, {
            "name": "Jersey",
            "code": "JEY"
        }, { "name": "Jordan", "code": "JOR" }, { "name": "Kazakhstan", "code": "KAZ" }, {
            "name": "Kenya",
            "code": "KEN"
        }, { "name": "Kiribati", "code": "KIR" }, {
            "name": "Korea (the Democratic People's Republic of)",
            "code": "PRK"
        }, { "name": "Korea (the Republic of)", "code": "KOR" }, { "name": "Kuwait", "code": "KWT" }, {
            "name": "Kyrgyzstan",
            "code": "KGZ"
        }, { "name": "Lao People's Democratic Republic", "code": "LAO" }, {
            "name": "Latvia",
            "code": "LVA"
        }, { "name": "Lebanon", "code": "LBN" }, { "name": "Lesotho", "code": "LSO" }, {
            "name": "Liberia",
            "code": "LBR"
        }, { "name": "Libya", "code": "LBY" }, { "name": "Liechtenstein", "code": "LIE" }, {
            "name": "Lithuania",
            "code": "LTU"
        }, { "name": "Luxembourg", "code": "LUX" }, { "name": "Macao", "code": "MAC" }, {
            "name": "Madagascar",
            "code": "MDG"
        }, { "name": "Malawi", "code": "MWI" }, { "name": "Malaysia", "code": "MYS" }, {
            "name": "Maldives",
            "code": "MDV"
        }, { "name": "Mali", "code": "MLI" }, { "name": "Malta", "code": "MLT" }, {
            "name": "Marshall Islands",
            "code": "MHL"
        }, { "name": "Martinique", "code": "MTQ" }, { "name": "Mauritania", "code": "MRT" }, {
            "name": "Mauritius",
            "code": "MUS"
        }, { "name": "Mayotte", "code": "MYT" }, {
            "name": "Mexico",
            "code": "MEX"
        }, { "name": "Micronesia (Federated States of)", "code": "FSM" }, {
            "name": "Moldova (the Republic of)",
            "code": "MDA"
        }, { "name": "Monaco", "code": "MCO" }, { "name": "Mongolia", "code": "MNG" }, {
            "name": "Montenegro",
            "code": "MNE"
        }, { "name": "Montserrat", "code": "MSR" }, { "name": "Morocco", "code": "MAR" }, {
            "name": "Mozambique",
            "code": "MOZ"
        }, { "name": "Myanmar", "code": "MMR" }, { "name": "Namibia", "code": "NAM" }, {
            "name": "Nauru",
            "code": "NRU"
        }, { "name": "Nepal", "code": "NPL" }, { "name": "Netherlands", "code": "NLD" }, {
            "name": "New Caledonia",
            "code": "NCL"
        }, { "name": "New Zealand", "code": "NZL" }, { "name": "Nicaragua", "code": "NIC" }, {
            "name": "Niger",
            "code": "NER"
        }, { "name": "Nigeria", "code": "NGA" }, { "name": "Niue", "code": "NIU" }, {
            "name": "Norfolk Island",
            "code": "NFK"
        }, { "name": "Northern Mariana Islands", "code": "MNP" }, { "name": "Norway", "code": "NOR" }, {
            "name": "Oman",
            "code": "OMN"
        }, { "name": "Pakistan", "code": "PAK" }, { "name": "Palau", "code": "PLW" }, {
            "name": "Palestine, State of",
            "code": "PSE"
        }, { "name": "Panama", "code": "PAN" }, { "name": "Papua New Guinea", "code": "PNG" }, {
            "name": "Paraguay",
            "code": "PRY"
        }, { "name": "Peru", "code": "PER" }, { "name": "Philippines", "code": "PHL" }, {
            "name": "Pitcairn",
            "code": "PCN"
        }, { "name": "Poland", "code": "POL" }, { "name": "Portugal", "code": "PRT" }, {
            "name": "Puerto Rico",
            "code": "PRI"
        }, { "name": "Qatar", "code": "QAT" }, { "name": "Republic of North Macedonia", "code": "MKD" }, {
            "name": "Romania",
            "code": "ROU"
        }, { "name": "Russian Federation", "code": "RUS" }, { "name": "Rwanda", "code": "RWA" }, {
            "name": "Réunion",
            "code": "REU"
        }, { "name": "Saint Barthélemy", "code": "BLM" }, {
            "name": "Saint Helena, Ascension and Tristan da Cunha",
            "code": "SHN"
        }, { "name": "Saint Kitts and Nevis", "code": "KNA" }, {
            "name": "Saint Lucia",
            "code": "LCA"
        }, { "name": "Saint Martin (French part)", "code": "MAF" }, {
            "name": "Saint Pierre and Miquelon",
            "code": "SPM"
        }, { "name": "Saint Vincent and the Grenadines", "code": "VCT" }, {
            "name": "Samoa",
            "code": "WSM"
        }, { "name": "San Marino", "code": "SMR" }, {
            "name": "Sao Tome and Principe",
            "code": "STP"
        }, { "name": "Saudi Arabia", "code": "SAU" }, { "name": "Senegal", "code": "SEN" }, {
            "name": "Serbia",
            "code": "SRB"
        }, { "name": "Seychelles", "code": "SYC" }, { "name": "Sierra Leone", "code": "SLE" }, {
            "name": "Singapore",
            "code": "SGP"
        }, { "name": "Sint Maarten (Dutch part)", "code": "SXM" }, {
            "name": "Slovakia",
            "code": "SVK"
        }, { "name": "Slovenia", "code": "SVN" }, { "name": "Solomon Islands", "code": "SLB" }, {
            "name": "Somalia",
            "code": "SOM"
        }, { "name": "South Africa", "code": "ZAF" }, {
            "name": "South Georgia and the South Sandwich Islands",
            "code": "SGS"
        }, { "name": "South Sudan", "code": "SSD" }, { "name": "Spain", "code": "ESP" }, {
            "name": "Sri Lanka",
            "code": "LKA"
        }, { "name": "Sudan", "code": "SDN" }, { "name": "Suriname", "code": "SUR" }, {
            "name": "Svalbard and Jan Mayen",
            "code": "SJM"
        }, { "name": "Sweden", "code": "SWE" }, { "name": "Switzerland", "code": "CHE" }, {
            "name": "Syrian Arab Republic",
            "code": "SYR"
        }, { "name": "Taiwan (Province of China)", "code": "TWN" }, {
            "name": "Tajikistan",
            "code": "TJK"
        }, { "name": "Tanzania, United Republic of", "code": "TZA" }, {
            "name": "Thailand",
            "code": "THA"
        }, { "name": "Timor-Leste", "code": "TLS" }, { "name": "Togo", "code": "TGO" }, {
            "name": "Tokelau",
            "code": "TKL"
        }, { "name": "Tonga", "code": "TON" }, { "name": "Trinidad and Tobago", "code": "TTO" }, {
            "name": "Tunisia",
            "code": "TUN"
        }, { "name": "Turkey", "code": "TUR" }, {
            "name": "Turkmenistan",
            "code": "TKM"
        }, { "name": "Turks and Caicos Islands", "code": "TCA" }, { "name": "Tuvalu", "code": "TUV" }, {
            "name": "Uganda",
            "code": "UGA"
        }, { "name": "Ukraine", "code": "UKR" }, {
            "name": "United Arab Emirates",
            "code": "ARE"
        }, {
            "name": "United Kingdom of Great Britain and Northern Ireland",
            "code": "GBR"
        }, { "name": "United States Minor Outlying Islands", "code": "UMI" }, {
            "name": "United States of America",
            "code": "USA"
        }, { "name": "Uruguay", "code": "URY" }, { "name": "Uzbekistan", "code": "UZB" }, {
            "name": "Vanuatu",
            "code": "VUT"
        }, { "name": "Venezuela (Bolivarian Republic of)", "code": "VEN" }, {
            "name": "Viet Nam",
            "code": "VNM"
        }, { "name": "Virgin Islands (British)", "code": "VGB" }, {
            "name": "Virgin Islands (U.S.)",
            "code": "VIR"
        }, { "name": "Wallis and Futuna", "code": "WLF" }, { "name": "Western Sahara", "code": "ESH" }, {
            "name": "Yemen",
            "code": "YEM"
        }, { "name": "Zambia", "code": "ZMB" }, { "name": "Zimbabwe", "code": "ZWE" }
    ];
}

class KycEditTrustedContact {
    modal;
    constructor() {
        this.modal = new Modal();
    }
    async show() {
        let userService = new UserService();
        let account = await userService.getAccount();
        let template = WidgetGlobals.HandlebarsInstance.compile(KycEditTrustedContactHtml);
        this.modal.showModal("Edit trusted contact", template({ countries: CountryHelper.Countries }));
        if (account.trusted_contact) {
            let contactProperties = Object.getOwnPropertyNames(account.trusted_contact);
            FormHelper.fillInputs(contactProperties, account.trusted_contact);
        }
        this.bindEvents();
    }
    bindEvents() {
        let trustedContactSubmit = document.getElementById("trustedContactSubmit");
        trustedContactSubmit?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            if (!FormHelper.validate("#kycTrustedContactForm"))
                return;
            LoadingHelper.setLoading(trustedContactSubmit);
            let params = FormHelper.getParams("#kycTrustedContactForm");
            let userService = new UserService();
            await userService
                .updateTrustedContact(params)
                .then((response) => {
                if (response.message) {
                    this.showError(response.message);
                    return;
                }
                this.modal.hideModal();
            })
                .catch((reason) => {
                if (reason.message) {
                    this.showError(JSON.parse(reason.message).message);
                }
                else {
                    this.showError(reason);
                }
            })
                .finally(() => {
                LoadingHelper.removeLoading();
            });
        });
    }
    showError(message) {
        let kycEditNameError = document.getElementById("kycEditNameError");
        if (!kycEditNameError)
            return;
        kycEditNameError.innerHTML = message;
        kycEditNameError.style.display = "block";
    }
}

var FakeFundingHtml = "<article>\n    <div id=\"beforeFunding\">\n        To use liminal.market you need some aUSD. aUSD is the same value as USD.\n        We can give you some aUSD (this is all fake money), so you can play with the system.\n\n        First, you need to add aUSD to you wallet.\n\n        <button id=\"addTokenToWallet\">Add aUSD to wallet</button>\n        <blockquote id=\"needToCopy\" class=\"d-none\">\n            If the button didn't work, you can copy the address here and import it into your wallet\n            <input value=\"{{aUSDAddress}}\">\n        </blockquote>\n        When you have aUSD to you wallet, you can request some money to trade with.\n\n        <button id=\"requestFakeAUSD\">Request some aUSD</button>\n        <div class=\"warningBar notificationBar d-none\" id=\"fundingError\"></div>\n    </div>\n    <div id=\"afterFunding\" class=\"d-none center\">\n        We have now sending aUSD to your wallet. This usually takes few minutes, so lets wait.\n        <br><br>\n        When you have the aUSD in you wallet, we will tell you.\n        <div>\n            <h3>Current aUSD balance</h3>\n            <div id=\"currentAUSDBalance\"></div>\n        </div>\n        <div class=\"hidden center\" id=\"fake_funding_writing_to_ausd\">\n            <strong aria-busy=\"true\">Writing amount to aUSD token. Few more seconds...</strong>\n        </div>\n    </div>\n    <div id=\"errorAfterTryFunding\" class=\"d-none\">\n        We had an error while trying to fund you. We'll be cracking at the issue soon to fix it.\n        Try again in few minutes. If not, try again in few hours.\n    </div>\n\n</article>";

var SelectFundingTypeHtml = "<p>Setup your bank relationship with Liminal.market. Please choose the type of transfer you want to make</p>\n<ul class=\"funding_type\">\n    <li><label><input type=\"radio\" name=\"bank_transfer\" id=\"ach_transfer\" value=\"1\"> ACH bank transfer (US)</label>\n    </li>\n    <li><label><input type=\"radio\" name=\"bank_transfer\" id=\"wire_transfer\" value=\"2\"> Wire transfer\n        (International)</label></li>\n</ul>\n<div id=\"selectFundingTypeError\" class=\"input_error\"></div>\n<button id=\"next_bank_information\">Next: Bank information</button>\n";

class SelectFundingType {
    aUsdFund;
    constructor(aUsdFund) {
        this.aUsdFund = aUsdFund;
    }
    show() {
        let template = WidgetGlobals.HandlebarsInstance.compile(SelectFundingTypeHtml);
        this.aUsdFund.modal.showModal("Select funding type", template({}));
        this.bindEvent();
    }
    bindEvent() {
        let next_bank_information = document.getElementById("next_bank_information");
        next_bank_information?.addEventListener("click", (evt) => {
            this.aUsdFund.hideError("selectFundingTypeError");
            let ach_transfer = document.getElementById("ach_transfer");
            if (ach_transfer?.checked) {
                this.aUsdFund.achRelationship.show();
            }
            let wire_transfer = document.getElementById("wire_transfer");
            if (wire_transfer?.checked) {
                this.aUsdFund.wireTransferRelationship.show();
            }
            this.aUsdFund.showError("selectFundingTypeError", "Please select funding type");
        });
    }
}

var ACHRelationshipHtml = "<fieldset>\n    <p>Before you can transfer, you need to set up your bank information</p>\n\n    <form id=\"achForm\">\n        <div class=\"grid\">\n            <label>\n                Account owner name\n                <input name=\"account_owner_name\" required id=\"account_owner_name\">\n            </label>\n            <label>Bank Account Type\n                <select name=\"bank_account_type\" id=\"bank_account_type\" required>\n                    <option value=\"\"></option>\n                    <option value=\"CHECKING\">Checking</option>\n                    <option value=\"SAVINGS\">Savings</option>\n                </select>\n            </label>\n        </div>\n        <div class=\"grid\">\n            <label>\n                Bank account number\n                <input name=\"bank_account_number\" id=\"bank_account_number\" required>\n            </label>\n            <label>\n                Bank routing number\n                <input name=\"bank_routing_number\" id=\"bank_routing_number\" required>\n            </label>\n        </div>\n        <div class=\"input_error\" id=\"relationshipError\"></div>\n        <div class=\"grid\">\n            <button id=\"ach_previous\">Previous: Funding type</button>\n            <button id=\"ach_next\">Next: Save bank information</button>\n        </div>\n\n    </form>\n\n</fieldset>";

var TransferDirectionEnum;
(function (TransferDirectionEnum) {
    TransferDirectionEnum["Incoming"] = "INCOMING";
    TransferDirectionEnum["Outgoing"] = "OUTGOING";
})(TransferDirectionEnum || (TransferDirectionEnum = {}));

class RelationshipBase {
    aUsdFund;
    constructor(aUsdFund) {
        this.aUsdFund = aUsdFund;
    }
    show(title, html, param) {
        let template = WidgetGlobals.HandlebarsInstance.compile(html);
        this.aUsdFund.modal.showModal(title, template(param));
        this.bindEvents();
    }
    async handleErrorResponse(reason) {
        if (!reason.message) {
            alert(reason);
            return;
        }
        let obj = JSON.parse(reason.message);
        let errorElement = document.getElementById("relationshipError");
        if (!errorElement) {
            let message = obj.serverError ? obj.serverError.message : reason.message;
            alert(message);
            return;
        }
        if (obj.serverError.message.indexOf("only one bank association") != -1) {
            let userService = new UserService();
            let bankRelationship = await userService.getBankRelationship();
            if (!bankRelationship) {
                errorElement.innerText =
                    'We cannot create the bank connection. Something is not working as it should. Please contact us at <a href="mailto:info@liminal.market">info@liminal.market</a>';
                errorElement.style.display = "block";
            }
            else {
                let transfers = await userService.getLatestTransfers(TransferDirectionEnum.Incoming);
                await this.aUsdFund.transferNotification.show(bankRelationship, transfers);
            }
        }
        else {
            errorElement.innerText = obj.serverError.message;
            errorElement.style.display = "block";
        }
    }
}

class ACHRelationship extends RelationshipBase {
    constructor(aUsdFund) {
        super(aUsdFund);
    }
    show() {
        super.show('Bank information', ACHRelationshipHtml);
    }
    bindEvents() {
        let ach_next = document.getElementById('ach_next');
        ach_next?.addEventListener('click', async (evt) => {
            evt.preventDefault();
            if (!this.validate())
                return;
            let params = FormHelper.getParams('#achForm');
            let userService = new UserService();
            userService.createAchRelationship(params.account_owner_name, params.bank_account_type, params.bank_account_number, params.bank_routing_number)
                .then(result => {
                this.aUsdFund.firstTransferSetup.show(result);
            })
                .catch(async (reason) => {
                await this.handleErrorResponse(reason);
            });
        });
        let ach_previous = document.getElementById('ach_previous');
        ach_previous?.addEventListener('click', (evt) => {
            evt.preventDefault();
            this.aUsdFund.selectFundingType.show();
        });
    }
    validate() {
        if (!FormHelper.validate('#achForm'))
            return false;
        return true;
    }
}

var TransferNotificationHtml = "<fieldset>\n\n\n    <p>\n        To fill up your broker account, you need to notify Liminal.market first about your transfer,\n        we can then match it with your account.\n        <a href=\"#\" id=\"first_transfer_setup\">Need bank information? Click here</a>\n    </p>\n    <br>\n\n    {{{moneyTransferred}}}\n\n    {{{transfers}}}\n</fieldset>";

var TransfersListHtml = "<hr>\n<h3>{{Direction}} transfers</h3>\n{{#if transfers.length}}\n<p>Below is a list of transfers, confirmed and not confirmed.</p>\n<table>\n    <thead>\n    <tr>\n        <th>Amount</th>\n        <th>Status</th>\n        <th>Created</th>\n        <th>Expires</th>\n    </tr>\n    </thead>\n    <tbody>\n    {{#each transfers}}\n    <tr>\n        <td>${{amount}}</td>\n        <td id=\"status_{{id}}\">{{status}}</td>\n        <td>{{dateTimeFormat created_at}}</td>\n        <td>{{dateTimeFormat expires_at}}</td>\n        <td id=\"delete_{{id}}\" class=\"{{classByStatus status}}\"><a href=\"#\" class=\"deleteTransfer\" data-id=\"{{id}}\">Cancel</a>\n        </td>\n    </tr>\n    {{/each}}\n    </tbody>\n</table>\n{{else}}\n<p>No transfers registered</p>\n{{/if}}";

class HandlebarHelpers {
    static registerHelpers() {
        WidgetGlobals.HandlebarsInstance.registerHelper("perc", function (number) {
            return Math.round(parseFloat(number) * 10000) / 100 + "%";
        });
        WidgetGlobals.HandlebarsInstance.registerHelper("round", function (number) {
            return Math.round(parseFloat(number) * 100) / 100;
        });
        WidgetGlobals.HandlebarsInstance.registerHelper("round2", function (number) {
            return Math.round(parseFloat(number) * 10000) / 10000;
        });
        WidgetGlobals.HandlebarsInstance.registerHelper("classColor", function (number) {
            return number > 0 ? "green" : "red";
        });
        WidgetGlobals.HandlebarsInstance.registerHelper("dateTimeFormat", function (strDate) {
            let date = new Date(strDate);
            return date.toLocaleString();
        });
        WidgetGlobals.HandlebarsInstance.registerHelper("classByStatus", function (status) {
            return status == "QUEUED" || status == "APPROVAL_PENDING"
                ? ""
                : "hidden";
        });
    }
}

class TransfersList {
    userService;
    constructor() {
        this.userService = new UserService();
    }
    async render(direction, transfers) {
        HandlebarHelpers.registerHelpers();
        let transfersTemplate = WidgetGlobals.HandlebarsInstance.compile(TransfersListHtml);
        return transfersTemplate({ Direction: direction, transfers: transfers });
    }
    bindEvents() {
        let deleteTransfers = document.querySelectorAll(".deleteTransfer");
        for (let i = 0; i < deleteTransfers.length; i++) {
            deleteTransfers[i]?.addEventListener("click", async (evt) => {
                evt.preventDefault();
                if (!confirm("Are you sure you want to cancel this withdraw request?")) {
                    return;
                }
                let id = deleteTransfers[i].dataset["id"];
                if (!id)
                    return;
                let userService = new UserService();
                await userService.deleteTransfer(id).then(() => {
                    let statusTd = document.getElementById("status_" + id);
                    if (statusTd) {
                        statusTd.innerText = "CANCELED";
                    }
                    let deleteTd = document.getElementById("delete_" + id);
                    deleteTd?.remove();
                });
            });
        }
    }
}

class FirstTransferSetupBase {
    bankRelationship;
    aUsdFund;
    constructor(aUsdFund, bankRelationship) {
        this.aUsdFund = aUsdFund;
        this.bankRelationship = bankRelationship;
    }
    render(html) {
        let element = document.getElementById('html_to_fill');
        if (!element)
            return;
        element.innerHTML = html;
    }
}

var MoneyTransferredHtml = "<form>\n    <label>Type in the amount in US Dollars ($) that you transferred\n        <input name=\"amount\" class=\"amount\" type=\"tel\" id=\"amount\" minlength=\"1\" required>\n    </label>\n    <div class=\"input_error\" id=\"transferError\"></div>\n    <button id=\"notifyTransfer\">Notify Liminal.market of incoming transfer</button>\n\n    <input type=\"hidden\" name=\"transfer_type\" id=\"transfer_type\" value=\"{{transfer_type}}\">\n    <input type=\"hidden\" name=\"relationship_id\" id=\"relationship_id\" value=\"{{relationshipId}}\">\n    <input type=\"hidden\" name=\"direction\" id=\"direction\" value=\"INCOMING\">\n</form>";

class MoneyTransferred extends FirstTransferSetupBase {
    constructor(aUsdFund, bankRelationship) {
        super(aUsdFund, bankRelationship);
    }
    show() {
        let template = WidgetGlobals.HandlebarsInstance.compile(MoneyTransferredHtml);
        super.render(template({}));
        this.bindEvents();
    }
    render() {
        let template = WidgetGlobals.HandlebarsInstance.compile(MoneyTransferredHtml);
        return template({
            transfer_type: this.bankRelationship.transfer_type,
            relationshipId: this.bankRelationship.id,
        });
    }
    bindEvents() {
        let notifyTransfer = document.getElementById("notifyTransfer");
        notifyTransfer?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            this.aUsdFund.hideError("transferError");
            let amount = document.getElementById("amount");
            if (StringHelper.isNullOrEmpty(amount.value) ||
                parseFloat(amount.value) < 10) {
                this.aUsdFund.showError("amountError", "Amount cannot be empty or below $10");
            }
            LoadingHelper.setLoading(notifyTransfer);
            let userService = new UserService();
            await userService
                .createTransfer(amount.value, "INCOMING")
                .then(() => {
                this.aUsdFund.transferNotified.show(this.bankRelationship, amount.value);
            })
                .catch((reason) => {
                let httpError = JSON.parse(reason.message);
                this.aUsdFund.showError("transferError", httpError.serverError.message);
            })
                .finally(() => {
                LoadingHelper.removeLoading();
            });
        });
    }
}

class TransferNotification {
    aUsdFund;
    bankRelationship;
    transfersList;
    moneyTransferred;
    constructor(aUsdFund) {
        this.aUsdFund = aUsdFund;
        this.transfersList = new TransfersList();
    }
    async show(bankRelationship, transfers) {
        this.bankRelationship = bankRelationship;
        let template = WidgetGlobals.HandlebarsInstance.compile(TransferNotificationHtml);
        let transfersListHtml = await this.transfersList.render(TransferDirectionEnum.Incoming, transfers);
        this.moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);
        this.aUsdFund.modal.showModal("Create transfer notification", template({
            moneyTransferred: this.moneyTransferred.render(),
            transfers: transfersListHtml,
        }));
        this.bindEvents();
    }
    bindEvents() {
        this.moneyTransferred?.bindEvents();
        this.transfersList.bindEvents();
        let first_transfer_setup = document.getElementById("first_transfer_setup");
        first_transfer_setup?.addEventListener("click", (evt) => {
            evt.preventDefault();
            this.aUsdFund.firstTransferSetup.show(this.bankRelationship);
        });
    }
}

var WireTransferHtml = "<fieldset>\n    <p>Before you can transfer, you need to set up your bank information</p>\n    <form id=\"wireTransferForm\">\n        <label>Bank name\n            <input name=\"name\" required id=\"name\">\n        </label>\n        <div class=\"input_error\" id=\"swift_error\">BIC/SWIFT code should be 8 or 11 characters</div>\n        <label>\n            Bank code (BIC/SWIFT)\n            <input name=\"bank_code\" maxlength=\"11\" id=\"bank_code\" required>\n        </label>\n        <label>\n            Bank Street address\n            <input name=\"street_address\" id=\"street_address\" required>\n        </label>\n        <label>\n            Bank Postal code\n            <input name=\"postal_code\" id=\"postal_code\" required>\n        </label>\n        <label>\n            Bank City\n            <input name=\"city\" id=\"city\" required>\n        </label>\n\n        <label>Bank State\n            <input name=\"state_province\" id=\"state_province\" required>\n        </label>\n        <label>\n            Country where bank account is located\n            <select required id=\"country\" required name=\"country\">\n                <option value=\"\"></option>\n                {{#each countries}}\n                <option value=\"{{code}}\">{{name}}</option>\n                {{/each}}\n            </select>\n        </label>\n        <label>\n            Account number (IBAN)\n            <input name=\"account_number\" id=\"account_number\" required>\n        </label>\n        <input type=\"hidden\" name=\"bank_code_type\" value=\"BIC\">\n        <div id=\"relationshipError\" class=\"input_error\"></div>\n        <div class=\"grid\">\n            <button id=\"wire_transfer_previous\">Previous: Funding type</button>\n            <button id=\"save_international_bank_information\">Next: Transfer</button>\n        </div>\n    </form>\n</fieldset>";

class WireTransferRelationship extends RelationshipBase {
    constructor(aUsdFund) {
        super(aUsdFund);
    }
    show() {
        super.show('Create bank information', WireTransferHtml, { countries: CountryHelper.Countries });
    }
    bindEvents() {
        let wire_transfer_previous = document.getElementById('wire_transfer_previous');
        wire_transfer_previous?.addEventListener('click', (evt) => {
            this.aUsdFund.selectFundingType.show();
        });
        let save_international_bank_information = document.getElementById('save_international_bank_information');
        save_international_bank_information?.addEventListener('click', async (evt) => {
            evt.preventDefault();
            if (!this.validate())
                return;
            let params = FormHelper.getParams('#wireTransferForm');
            let userService = new UserService();
            await userService.registerWireTransferRelationship(params)
                .then(async (bankRelationship) => {
                let transfers = await userService.getLatestTransfers(TransferDirectionEnum.Incoming);
                await this.aUsdFund.transferNotification.show(bankRelationship, transfers);
            })
                .catch(async (reason) => {
                await this.handleErrorResponse(reason);
            });
        });
    }
    validate() {
        let swift_error = document.getElementById('swift_error');
        if (swift_error)
            swift_error.style.display = 'none';
        let writeTransferError = document.getElementById('writeTransferError');
        if (writeTransferError)
            writeTransferError.style.display = 'none';
        if (!FormHelper.validate('#wireTransferForm'))
            return false;
        let bank_code = document.getElementById('bank_code');
        if (bank_code.value.length != 8 && bank_code.value.length != 11) {
            bank_code.setAttribute('aria-invalid', 'true');
            let swift_error = document.getElementById('swift_error');
            if (swift_error)
                swift_error.style.display = 'block';
            return false;
        }
        return true;
    }
}

var TransferInfoHtml = "<h2>You should transfer your money now</h2>\n\n<ul>\n    <li>Amount: {{amount}}</li>\n    <li>From Account: {{account_number}}</li>\n</ul>";

class TransferNotified {
    aUsdFund;
    constructor(aUsdFund) {
        this.aUsdFund = aUsdFund;
    }
    show(bankRelationship, amount) {
        let template = WidgetGlobals.HandlebarsInstance.compile(TransferInfoHtml);
        let obj = {
            amount,
            account_number: bankRelationship.alpaca_account_number,
            wire: bankRelationship.transfer_type == "wire",
        };
        this.aUsdFund.modal.showModal("Transfer information", template(obj));
    }
}

var FirstTransferSetupHtml = "<div id=\"html_to_fill\">\n    {{{html}}}\n</div>\n";

var BankInfoHtml = "Create the bank information you need in your internet bank\n<table>\n    <tr>\n        <td>Bank name</td>\n        <td>BMO Harris Bank NA</td>\n    </tr>\n    <tr>\n        <td>Bank address</td>\n        <td>BMO Harris Bank\n            111. W. Monroe Street\n            Chicago, IL 60603, USA\n        </td>\n    </tr>\n    <tr>\n        <td>Recipient - Account name</td>\n        <td>Alpaca Securities LLC</td>\n    </tr>\n    <tr>\n        <td>Alpaca address</td>\n        <td>Alpaca Securities LLC\n            3 East Third Ave, Suite 233\n            San Mateo, CA 94401, USA\n        </td>\n    </tr>\n    <tr>\n        <td>Account number / IBAN</td>\n        <td>1636877</td>\n    </tr>\n    {{#if wire}}\n    <tr>\n        <td>SWIFT CODE</td>\n        <td>HATRUS44</td>\n    </tr>\n    {{^}}\n    <tr>\n        <td>ABA ROUTING NUMBER (ACH)</td>\n        <td>071000288</td>\n    </tr>\n    {{/if}}\n    <tr>\n        <td>Please specify the following in the reference of the wire:</td>\n        <td>FFC LMKT-{{account_number}}</td>\n    </tr>\n</table>\n<button id=\"bank_info_next\">Next: I set up the information in my bank</button>";

var WireTransferMoneyHtml = "<h3>Transfer money</h3>\nYou can now log in to your internet bank and transfer the money to Alpaca.\n<br><br>\nAfter you have transferred the money, you need to let us know the amount that you transferred.\n\n<div class=\"grid\">\n    <button id=\"prev_wire_transfer_money\">Previous: See bank information</button>\n    <button id=\"next_wire_transfer_money\">Next: I have transferred the money</button>\n</div>";

class WireTransferMoney extends FirstTransferSetupBase {
    constructor(aUsdFund, bankRelationship) {
        super(aUsdFund, bankRelationship);
    }
    show() {
        let template = WidgetGlobals.HandlebarsInstance.compile(WireTransferMoneyHtml);
        this.render(template({}));
        this.bindEvents();
    }
    bindEvents() {
        let next = document.getElementById("next_wire_transfer_money");
        next?.addEventListener("click", (evt) => {
            evt.preventDefault();
            let moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);
            moneyTransferred.show();
        });
        let prev = document.getElementById("prev_wire_transfer_money");
        prev?.addEventListener("click", (evt) => {
            evt.preventDefault();
            let transferSetup = new FirstTransferSetup(this.aUsdFund);
            transferSetup.show(this.bankRelationship);
        });
    }
}

var ACHTransferAccountNumberHtml = "The money should come from bank account number <strong>{{bank_account_number}}</strong>\n<div class=\"grid\">\n    <button id=\"next_ach_account_number\">Yes, it's coming from {{bank_account_number}}</button>\n</div>";

class ACHTransferAccountNumber extends FirstTransferSetupBase {
    constructor(aUsdFund, bankRelationship) {
        super(aUsdFund, bankRelationship);
    }
    show() {
        let template = WidgetGlobals.HandlebarsInstance.compile(ACHTransferAccountNumberHtml);
        this.render(template({
            bank_account_number: this.bankRelationship.alpaca_account_number,
        }));
        this.bindEvents();
    }
    bindEvents() {
        let next = document.getElementById("next_ach_account_number");
        next?.addEventListener("click", (evt) => {
            evt.preventDefault();
            let moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);
            moneyTransferred.show();
        });
    }
}

class BankInfo extends FirstTransferSetupBase {
    constructor(aUsdFund, bankRelationship) {
        super(aUsdFund, bankRelationship);
    }
    show() {
        let bankInfoTemplate = WidgetGlobals.HandlebarsInstance.compile(BankInfoHtml);
        let bankInfoHtml = bankInfoTemplate({
            wire: this.bankRelationship.transfer_type == "wire",
            account_number: this.bankRelationship.alpaca_account_number,
        });
        this.render(bankInfoHtml);
        this.bindEvents();
    }
    bindEvents() {
        let next = document.getElementById("bank_info_next");
        next?.addEventListener("click", (evt) => {
            evt.preventDefault();
            if (this.bankRelationship.transfer_type == "wire") {
                let wireTransferMoney = new WireTransferMoney(this.aUsdFund, this.bankRelationship);
                wireTransferMoney.show();
            }
            else {
                let ach = new ACHTransferAccountNumber(this.aUsdFund, this.bankRelationship);
                ach.show();
            }
        });
    }
}

class FirstTransferSetup {
    aUsdFund;
    bankRelationship;
    constructor(aUsdFund) {
        this.aUsdFund = aUsdFund;
    }
    show(bankRelationship) {
        this.bankRelationship = bankRelationship;
        let template = WidgetGlobals.HandlebarsInstance.compile(FirstTransferSetupHtml);
        this.aUsdFund.modal.showModal("Setup transfer", template({}));
        let bankInfo = new BankInfo(this.aUsdFund, bankRelationship);
        bankInfo.show();
    }
}

class AUSDFund {
    modal;
    selectFundingType;
    achRelationship;
    wireTransferRelationship;
    firstTransferSetup;
    transferNotification;
    transferNotified;
    constructor() {
        this.modal = new Modal();
        this.selectFundingType = new SelectFundingType(this);
        this.achRelationship = new ACHRelationship(this);
        this.wireTransferRelationship = new WireTransferRelationship(this);
        this.firstTransferSetup = new FirstTransferSetup(this);
        this.transferNotification = new TransferNotification(this);
        this.transferNotified = new TransferNotified(this);
    }
    async show() {
        let userService = new UserService();
        let bankRelationship = await userService.getBankRelationship();
        if (bankRelationship) {
            let transfers = await userService.getLatestTransfers(TransferDirectionEnum.Incoming);
            if (transfers.length > 0) {
                await this.transferNotification.show(bankRelationship, transfers);
            }
            else {
                this.firstTransferSetup.show(bankRelationship);
            }
        }
        else {
            this.selectFundingType.show();
        }
    }
    showError(elementId, reason) {
        let element = document.getElementById(elementId);
        if (element) {
            element.innerText = reason;
            element.style.display = 'block';
        }
    }
    hideError(elementId) {
        let element = document.getElementById(elementId);
        if (element) {
            element.style.display = 'none';
        }
    }
}

class FakeAUSDFund {
    currentBalance;
    modal;
    constructor() {
        this.currentBalance = BigNumber.from(-1);
        this.modal = new Modal();
    }
    showAUSDFund() {
        let aUsdFund = new AUSDFund();
        aUsdFund.show();
    }
    static writingToChain() {
        let element = document.getElementById("fake_funding_writing_to_ausd");
        element?.classList.remove("hidden");
    }
    showAUSDFakeFund() {
        let networkInfo = WidgetGlobals.Network;
        if (!networkInfo.TestNetwork) {
            this.showAUSDFund();
            return;
        }
        let template = WidgetGlobals.HandlebarsInstance.compile(FakeFundingHtml);
        let contractInfo = ContractInfo.getContractInfo();
        let content = template({ aUSDAddress: contractInfo.AUSD_ADDRESS });
        this.modal.showModal("Fund my account (Fake money)", content);
        let addToWallet = document.getElementById("addTokenToWallet");
        addToWallet?.addEventListener("click", async (evt) => {
            let contractInfo = ContractInfo.getContractInfo();
            let walletHelper = new WalletHelper();
            let result = await walletHelper.addTokenToWallet(contractInfo.AUSD_ADDRESS, "aUSD", () => {
                this.showCopyField();
            });
            if (!result)
                this.showCopyField();
        });
        let registerBankInfo = document.getElementById("registerBankInfo");
        registerBankInfo?.addEventListener("click", (evt) => {
            this.modal.hideModal();
            let aUsdFund = new AUSDFund();
            aUsdFund.show();
        });
        let requestFakeAUSD = document.getElementById("requestFakeAUSD");
        requestFakeAUSD?.addEventListener("click", async (evt) => {
            requestFakeAUSD.setAttribute("aria-busy", "true");
            let result = await WidgetGlobals.LiminalMarket.fundSandboxAccount(async (obj) => {
                console.log("Funding is done", obj);
            });
            if (!result)
                return;
            if (!result.success) {
                let fundingError = document.getElementById("fundingError");
                if (fundingError) {
                    requestFakeAUSD.removeAttribute("aria-busy");
                    fundingError.classList.remove("d-none");
                    fundingError.innerHTML = result.message;
                    setTimeout(() => {
                        fundingError.classList.add("d-none");
                    }, 10 * 1000);
                }
            }
            else if (result.success) {
                let beforeFunding = document.getElementById("beforeFunding");
                let afterFunding = document.getElementById("afterFunding");
                if (!beforeFunding || !afterFunding)
                    return;
                await this.loadAUSDBalance();
                beforeFunding.classList.add("d-none");
                afterFunding.classList.remove("d-none");
            }
            else {
                this.errorWhileFunding(result);
            }
            //callback();
        });
    }
    async loadAUSDBalance() {
        let currentAUSDBalance = document.getElementById("currentAUSDBalance");
        if (!currentAUSDBalance)
            return;
        let userService = new UserService();
        let ethAddress = userService.getEthAddress();
        let amount = BigNumber.from(0);
        if (ethAddress) {
            amount = await WidgetGlobals.LiminalMarket.getAUSDBalance(ethAddress);
        }
        currentAUSDBalance.innerHTML = "$" + roundBigNumber(amount).toString();
        if (this.currentBalance.eq(-1)) {
            this.currentBalance = amount;
        }
        if (this.currentBalance.eq(amount)) {
            setTimeout(async () => {
                await this.loadAUSDBalance();
            }, 5 * 1000);
        }
        else {
            window.location.reload();
        }
    }
    showCopyField() {
        let needToCopy = document.getElementById("needToCopy");
        if (!needToCopy)
            return;
        needToCopy.classList.remove("d-none");
    }
    errorWhileFunding(result) {
        let beforeFunding = document.getElementById("beforeFunding");
        let errorAfterFunding = document.getElementById("errorAfterTryFunding");
        if (!beforeFunding || !errorAfterFunding)
            return;
        if (result.message) {
            errorAfterFunding.innerHTML = result.message;
        }
        beforeFunding.classList.add("d-none");
        errorAfterFunding.classList.remove("d-none");
    }
}

var WithdrawModalHtml = "<fieldset id=\"withdrawInput\">\n\n    {{#if bank.bank_code_type}}\n    Your money will be sent to {{bank.name}} to account number {{bank.account_number}}.\n    <br><br>\n    Outgoing International Wire Transfers cost is ${{transferCost}}.<br>\n    Fees will be deducted from the amount.\n    {{/if}}\n    {{#unless bank.bank_code_type}}\n    Your money will be sent to account number {{bank.bank_account_number}}.\n    <br><br>\n    ACH transfer costs is ${{transferCost}}. Fees will be deducted from the amount.\n    {{/unless}}\n    <form id=\"withdrawForm\">\n        <label>Amount to withdraw\n            <input type=\"tel\" name=\"amount\" id=\"amount\">\n        </label>\n        <div class=\"input_error\" id=\"withdrawAmountError\">The amount is lower than the cost of transfer</div>\n        <button id=\"confirmWithdraw\">Confirm withdraw</button>\n    </form>\n    {{{Transfers}}}\n</fieldset>\n\n<fieldset id=\"withdrawConfirm\" class=\"hidden\">\n    You are about to withdraw $<span id=\"withdrawAmountText\"></span> from your account\n    <div class=\"warningBar\">\n        Warning: The fee of this transaction will be $<span id=\"feeWarning\"></span>\n        and is <span id=\"feePercentage\"></span>% of the amount.\n    </div>\n    <div class=\"input_error\" id=\"withdrawError\"></div>\n    <button id=\"confirmWithdrawButton\">Execute transfer</button>\n</fieldset>";

class WithdrawModal {
    userService;
    bankInfo;
    wireTransferCost = 50;
    achTransferCost = 25;
    transferCost;
    currentBalance;
    transfersList;
    constructor() {
        this.userService = new UserService();
        this.transferCost = this.wireTransferCost;
        this.transfersList = new TransfersList();
    }
    async show() {
        let modal = new Modal();
        let bankRelationships = await this.userService.getBankRelationship();
        if (!bankRelationships) {
            modal.showModal("Withdraw information", "You haven't setup bank connection. You cannot withdraw from without bank connection");
            return;
        }
        let transfers = await this.userService.getLatestTransfers(TransferDirectionEnum.Outgoing);
        let transfersHtml = await this.transfersList.render(TransferDirectionEnum.Outgoing, transfers);
        let ethAddress = this.userService.getEthAddress();
        this.currentBalance = BigNumber.from(0);
        if (ethAddress) {
            this.currentBalance = await WidgetGlobals.LiminalMarket.getAUSDBalance(ethAddress);
        }
        if (this.currentBalance.eq(0)) {
            let tmp = WidgetGlobals.HandlebarsInstance.compile("Your current balance is $0. There is nothing to withdraw. {{{transfers}}}");
            modal.showModal("Withdraw information", tmp({ transfers: transfersHtml }));
            return;
        }
        let withdrawTemplate = WidgetGlobals.HandlebarsInstance.compile(WithdrawModalHtml);
        this.bankInfo = bankRelationships;
        this.transferCost = this.bankInfo.bank_code_type
            ? this.wireTransferCost
            : this.achTransferCost;
        let obj = {
            amount: this.currentBalance,
            transferCost: this.transferCost,
            Transfers: transfersHtml,
            bank: this.bankInfo,
        };
        modal.showModal("Withdraw information", withdrawTemplate(obj));
        this.bindEvents();
        this.transfersList.bindEvents();
    }
    bindEvents() {
        let confirmWithdraw = document.getElementById("confirmWithdraw");
        confirmWithdraw?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            if (!this.bankInfo)
                return;
            let amount = document.getElementById("amount");
            if (StringHelper.isNullOrEmpty(amount.value)) {
                amount.setAttribute("aria-invalid", "true");
                return;
            }
            else if (parseFloat(amount.value) <= this.transferCost) {
                let withdrawAmountError = document.getElementById("withdrawAmountError");
                withdrawAmountError.style.display = "block";
                amount.setAttribute("aria-invalid", "true");
                return;
            }
            else {
                amount.setAttribute("aria-invalid", "false");
            }
            this.showWithdrawConfirmation();
        });
    }
    showWithdrawConfirmation() {
        if (!this.bankInfo)
            return;
        let amount = document.getElementById("amount");
        let withdrawInput = document.getElementById("withdrawInput");
        withdrawInput?.classList.add("hidden");
        let withdrawConfirm = document.getElementById("withdrawConfirm");
        withdrawConfirm?.classList.remove("hidden");
        let withdrawAmountText = document.getElementById("withdrawAmountText");
        let feeWarning = document.getElementById("feeWarning");
        let feePercentage = document.getElementById("feePercentage");
        withdrawAmountText.innerText = amount.value;
        feeWarning.innerText = this.transferCost.toString();
        feePercentage.innerText = roundNumber((this.transferCost / parseFloat(amount.value)) * 100).toString();
        let confirmWithdrawButton = document.getElementById("confirmWithdrawButton");
        confirmWithdrawButton?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            await this.userService
                .createTransfer(amount.value, TransferDirectionEnum.Outgoing)
                .then(async (response) => {
                let transfers = await this.userService.getLatestTransfers(TransferDirectionEnum.Outgoing);
                withdrawConfirm.innerHTML = await this.transfersList.render(TransferDirectionEnum.Outgoing, transfers);
                this.transfersList.bindEvents();
            })
                .catch((reason) => {
                let withdrawError = document.getElementById("withdrawError");
                if (!withdrawError)
                    return;
                if (withdrawError && isJSON(reason.message)) {
                    let error = JSON.parse(reason.message);
                    withdrawError.innerText = error.serverError.message;
                }
                else {
                    withdrawError.innerText = reason.toString();
                }
                withdrawError.style.display = "block";
            });
        });
    }
}

var AddToWalletHtml = "<article>\n    Some wallets detect automatically the coins that are registered to your address.\n    Those that don't do automatic detection, you need to add them manually.\n    <br><br>\n    This is the address for the symbol {{symbol}},\n    you need to copy it and import the token in your wallet\n    <br><br>\n    Contract address:<br>\n    <input value=\"{{address}}\">\n    Symbol:<br>\n    <input value=\"{{symbol}}\">\n    Decimal:<br>\n    <input value=\"18\">\n</article>\n";

class AUsdBalance {
    constructor() { }
    static async forceLoadAUSDBalanceUI() {
        let ui = new AUsdBalance();
        await ui.loadAUSDBalanceUI();
    }
    async loadAUSDBalanceUI() {
        if (!WidgetGlobals.User.ether) {
            await AuthenticateService.enableWeb3();
            if (!WidgetGlobals.User.ether)
                return;
        }
        let aUsdValueWei = await WidgetGlobals.LiminalMarket.getAUSDBalance(WidgetGlobals.User.address);
        this.updateUIBalance(aUsdValueWei);
        this.bindEvents();
    }
    bindEvents() {
        let networkInfo = WidgetGlobals.Network;
        let add_aUSD_to_wallet = document.querySelectorAll(".add_aUSD_to_wallet");
        add_aUSD_to_wallet.forEach((element) => {
            element.addEventListener("click", async (evt) => {
                evt.preventDefault();
                let contractInfo = ContractInfo.getContractInfo(networkInfo.Name);
                let walletHelper = new WalletHelper();
                await walletHelper.addTokenToWallet(contractInfo.AUSD_ADDRESS, "aUSD", () => {
                    let template = WidgetGlobals.HandlebarsInstance.compile(AddToWalletHtml);
                    let obj = { symbol: "aUSD", address: contractInfo.AUSD_ADDRESS };
                    let modal = new Modal();
                    modal.showModal("Add aUSD token", template(obj));
                });
            });
        });
        let fund_accountButtons = document.querySelectorAll(".fund_account");
        fund_accountButtons.forEach((element) => {
            let aUSDFundingModal = new FakeAUSDFund();
            if (networkInfo.TestNetwork) {
                element.innerHTML = "Click for some aUSD";
                element.addEventListener("click", (evt) => {
                    evt.preventDefault();
                    aUSDFundingModal.showAUSDFakeFund();
                });
            }
            else {
                element.addEventListener("click", async (evt) => {
                    evt.preventDefault();
                    let aUsdFund = new AUSDFund();
                    await aUsdFund.show();
                });
            }
        });
        let withdraw_from_account = document.getElementById("withdraw_from_account");
        withdraw_from_account?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            let withdrawModal = new WithdrawModal();
            await withdrawModal.show();
        });
    }
    updateUIBalance(aUsdValueWei) {
        let aUsdValue = roundBigNumber(aUsdValueWei);
        let balance_value = document.querySelector(".balance_value");
        if (balance_value) {
            alert("balance_value " + aUsdValue.toString());
            balance_value.innerHTML = "$" + parseFloat(utils.formatEther(aUsdValue));
            balance_value.title = utils.formatEther(aUsdValueWei);
            balance_value.dataset["tooltip"] = utils.formatEther(aUsdValueWei);
        }
        if (aUsdValue.lt(10)) {
            let frontpage_fund_account = document.getElementById("frontpage_fund_account");
            frontpage_fund_account?.classList.remove("hidden");
        }
        let userInfoAUsdBalance = document.getElementById("userInfoAUsdBalance");
        let frontpageAUsdBalance = document.getElementById("frontpageAUsdBalance");
        if (!WidgetGlobals.User.alpacaId) {
            frontpageAUsdBalance?.classList.add("hidden");
            userInfoAUsdBalance?.classList.add("hidden");
        }
        else {
            frontpageAUsdBalance?.classList.remove("hidden");
            userInfoAUsdBalance?.classList.remove("hidden");
        }
        let frontpageAUSDBalance = document.getElementById("front_page_aUSD_balance");
        if (frontpageAUSDBalance)
            frontpageAUSDBalance.innerHTML = "$" + aUsdValue.toString();
        let user_info_ausd_balance = document.getElementById("user_info_ausd_balance");
        if (user_info_ausd_balance)
            user_info_ausd_balance.innerHTML = "$" + aUsdValue.toString();
    }
}

var TestNetworkBannerHtml = "<div class=\"errorBar\">You are running on testnet. No real trades will be executed.\n    <!--<a href=\"#\" id=\"switch_from_test_network\">Switch to mainnet</a>-->\n</div>";

class UserInfo {
    authenticationService;
    userService;
    providerInfo;
    walletHelper;
    walletLoaded = false;
    static onUserLoggedIn = [];
    constructor(providerInfo) {
        this.authenticationService = new AuthenticateService();
        this.userService = new UserService();
        this.providerInfo = providerInfo;
        this.walletHelper = new WalletHelper();
    }
    async render(elementId) {
        this.listenForWalletChanges();
        this.loadUserMenuUI(elementId);
        this.loadIfTestNetwork();
        this.ifTradePage();
        LoadingHelper.removeLoading();
        let aUsdBalance = new AUsdBalance();
        await aUsdBalance.loadAUSDBalanceUI();
    }
    listenForWalletChanges() {
        /*
            TODO: need fixing
            this.moralis.onChainChanged(function () {
                location.reload();
            });
            this.moralis.onAccountChanged(function () {
                location.reload();
            });
            this.moralis.onDisconnect(function () {
                location.reload();
            });
            this.moralis.onConnect(function () {
                location.reload();
            });
    
             */
    }
    async loadUserMenuUI(elementId) {
        let userInfoDiv = document.getElementById(elementId);
        if (!userInfoDiv)
            return;
        let networkInfo = WidgetGlobals.Network;
        let obj = {
            ethAddress: WidgetGlobals.User.address,
            shortEthAddress: shortEth(WidgetGlobals.User.address),
            walletName: this.providerInfo.WalletName,
            networkName: networkInfo.ChainName +
                (networkInfo.TestNetwork ? " - (Test network)" : ""),
            blockchainExplorer: networkInfo.BlockExplorer + "/address/",
            isMagic: await this.walletHelper.isMagic(),
            chainId: networkInfo.ChainId,
        };
        let template = WidgetGlobals.HandlebarsInstance.compile(UserInfoElement);
        let html = template(obj);
        userInfoDiv.innerHTML = html;
        this.bindEvents();
        this.bindUserActionEvents();
        for (let i = 0; i < UserInfo.onUserLoggedIn.length; i++) {
            UserInfo.onUserLoggedIn[i]();
        }
        if (networkInfo.TestNetwork || !WidgetGlobals.User.alpacaId) {
            let edit_account = document.querySelector(".edit_account");
            edit_account?.classList.add("hidden");
        }
    }
    bindUserActionEvents() {
        let editName = document.getElementById("editName");
        editName?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            let kycModal = new KycEditNameForm();
            await kycModal.show();
        });
        let editContact = document.getElementById("editContact");
        editContact?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            let kycModal = new KycEditContactForm();
            await kycModal.show();
        });
        let editTrustedContact = document.getElementById("editTrustedContact");
        editTrustedContact?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            let kycModal = new KycEditTrustedContact();
            await kycModal.show();
        });
    }
    bindEvents() {
        let userInfoDropdown = document.getElementById("userInfoDropdown");
        if (!userInfoDropdown)
            return;
        document.body.addEventListener("click", (evt) => {
            if (userInfoDropdown && !userInfoDropdown.classList.contains("d-none")) {
                userInfoDropdown.classList.add("d-none");
                evt.stopPropagation();
                evt.preventDefault();
            }
        });
        let userInfoAction = document.getElementById("userInfoAction");
        userInfoAction?.addEventListener("click", (evt) => {
            evt.preventDefault();
            evt.stopPropagation();
            userInfoDropdown?.classList.toggle("d-none");
            userInfoDropdown?.addEventListener("click", (evt) => {
                evt.stopPropagation();
            });
            WalletHelper.hideMagicWallet();
        });
        let disconnectFromNetwork = document.getElementById("disconnectFromNetwork");
        disconnectFromNetwork?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            await this.authenticationService.logOut();
            window.location.reload();
        });
        let wallet = document.getElementById("wallet");
        wallet?.addEventListener("click", async (evt) => {
            evt.preventDefault();
            LoadingHelper.setLoading(evt.target);
            if (this.walletLoaded) {
                let magicIframe = document.querySelector(".magic-iframe");
                if (magicIframe)
                    magicIframe.style.display = "block";
                LoadingHelper.removeLoading();
                userInfoDropdown?.classList.add("d-none");
                return;
            }
            WidgetGlobals.User.magic?.connect.showWallet().catch(async (e) => {
                this.walletLoaded = false;
                if (e.message.indexOf("User denied account access") != -1) {
                    await this.authenticationService.logOut();
                    alert("You have been logged out of you wallet and need to log back in. We will now reload the page and you can log in.");
                    location.reload();
                    return;
                }
                throw e;
            });
            let closeMenuInterval = setInterval(() => {
                let magicIframe = document.querySelector(".magic-iframe");
                if (!magicIframe)
                    clearInterval(closeMenuInterval);
                if (magicIframe && magicIframe.style.display == "block") {
                    LoadingHelper.removeLoading();
                    userInfoDropdown?.classList.add("d-none");
                    this.walletLoaded = true;
                    clearInterval(closeMenuInterval);
                }
            }, 1000);
        });
        let switch_network = document.getElementById("switch_network");
        switch_network?.addEventListener("click", (evt) => {
            evt.preventDefault();
            let switchNetworkModal = new SwitchNetworkModal();
            switchNetworkModal.show();
        });
    }
    loadIfTestNetwork() {
        if (!WidgetGlobals.User.provider)
            return;
        if (!WidgetGlobals.Network.TestNetwork)
            return;
        let header = document.querySelector("header");
        if (!header)
            return;
        let template = WidgetGlobals.HandlebarsInstance.compile(TestNetworkBannerHtml);
        header.insertAdjacentHTML("beforebegin", template({}));
        let switch_from_test_network = document.getElementById("switch_from_test_network");
        switch_from_test_network?.addEventListener("click", (evt) => {
            let switchNetworkModal = new SwitchNetworkModal();
            switchNetworkModal.show();
        });
    }
    ifTradePage() {
        let btn = document.getElementById("liminal_market_execute_order");
        if (!btn)
            return;
        ExecuteOrderButton.Instance.renderButton();
    }
}

var walletButton = "<button class=\"liminal_market_connect_wallet outline\">Connect wallet</button>";

var InfoBarType;
(function (InfoBarType) {
    InfoBarType["Info"] = "infoBar";
    InfoBarType["Warning"] = "warningBar";
    InfoBarType["Error"] = "errorBar";
})(InfoBarType || (InfoBarType = {}));

class InfoBar {
    static show(message, type, timeoutInSeconds = 4) {
        let infoBar = document.getElementById('infoBar');
        if (!infoBar) {
            infoBar = document.createElement('div');
            infoBar.classList.add('notificationBar');
            infoBar.id = 'infoBar';
            document.body.insertAdjacentElement('afterbegin', infoBar);
        }
        infoBar.innerHTML = message;
        infoBar.classList.remove('hidden');
        infoBar.classList.remove(InfoBarType.Info);
        infoBar.classList.remove(InfoBarType.Warning);
        infoBar.classList.remove(InfoBarType.Error);
        infoBar.classList.add(type);
        if (timeoutInSeconds > 0) {
            setTimeout(() => {
                infoBar?.classList.add('hidden');
            }, timeoutInSeconds * 1000);
        }
    }
}

var WalletMissingHtml = "\nYou need to set up a wallet in your browser before you can use liminal.market.\n<br><br>\nTo make it simple, we would like to suggest two options. In your browser or your phone.\n<ul>\n    <li>For the browser we recommend <a href=\"https://metamask.io/download/\" target=\"_blank\">Metamask</a>.\n    </li>\n    <li>\n        For your phone, we like <a href=\"https://www.tokenpocket.pro/en/download/app\" target=\"_blank\">Token Poket</a>\n    </li>\n</ul>\n<br>\nBut, you have <a href=\"https://ethereum.org/en/wallets/\" target=\"_blank\">many options</a> if you want to learn more.";

class PredefinedErrorHandlers {
    errorMessageMapping = new Map();
    SentLoginRequest = "We have sent request to you wallet to login. Open your wallet to login";
    constructor() {
        this.errorMessageMapping.set("chain not supported", () => {
            let div = 'Network is not supported. <a href="" id="switchNetworkLink">Click me to switch to supported network</a>';
            InfoBar.show(div, InfoBarType.Warning, 120);
            let switchNetworkLink = document.getElementById("switchNetworkLink");
            switchNetworkLink?.addEventListener("click", (evt) => {
                evt.preventDefault();
                let modal = new SwitchNetworkModal();
                modal.show();
            });
        });
        this.errorMessageMapping.set("already processing eth_requestaccounts", this.SentLoginRequest);
        this.errorMessageMapping.set("request of type 'wallet_requestPermissions' already pending", this.SentLoginRequest);
        this.errorMessageMapping.set("already has been called, but is not finished yet", this.SentLoginRequest);
        this.errorMessageMapping.set("request is already in progress", this.SentLoginRequest);
        this.errorMessageMapping.set("web3 instance", () => {
            let elements = document.querySelectorAll(".liminal_market_connect_wallet");
            if (elements.length > 0) {
                elements[0].dispatchEvent(new MouseEvent("click"));
                return;
            }
        });
        this.errorMessageMapping.set("user rejected the request", async () => {
            let authenticationService = new AuthenticateService();
            await authenticationService.logOut();
            window.location.reload();
        });
        this.errorMessageMapping.set("Non ethereum enabled browser", () => {
            let modal = new Modal();
            let template = WidgetGlobals.HandlebarsInstance.compile(WalletMissingHtml);
            modal.showModal("New to blockchain?", template(null), false, () => {
                //window.location.reload();
            });
        });
    }
    handle(message) {
        let handled = false;
        this.errorMessageMapping.forEach((value, key) => {
            if (!handled && message.toLowerCase().indexOf(key.toLowerCase()) != -1) {
                if (typeof value == "string") {
                    InfoBar.show(value.toString(), InfoBarType.Warning, 10);
                }
                else {
                    value();
                }
                handled = true;
                return handled;
            }
        });
        return handled;
    }
}

class ErrorInfo {
    errorInfo;
    constructor(errorInfo) {
        this.errorInfo = errorInfo;
    }
    getErrorInfo() {
        return this.errorInfo;
    }
    static report(error) {
        LoadingHelper.removeLoading();
        if (!error)
            return;
        let errorHandler = new PredefinedErrorHandlers();
        if (errorHandler.handle(error.message)) {
            return;
        }
        if (error.callback) {
            error.callback();
            return;
        }
        if (error) {
            console.error(error.toString());
        }
        //InfoBar.show(error.message, InfoBarType.Error);
    }
    static log(obj) {
        ErrorInfo.report(new GeneralError(obj));
    }
    static info(obj) {
        ErrorInfo.report(new GeneralError(obj));
    }
    static error(obj) {
        console.log(obj);
        ErrorInfo.report(new GeneralError(obj));
    }
}

class ConnectWallet {
    static Provider;
    providerInfo;
    constructor() {
        this.providerInfo = new ProviderInfo(null);
    }
    renderButton(elementId) {
        if (!document.getElementById(elementId))
            return;
        document.getElementById(elementId).innerHTML = walletButton;
        LoadingHelper.removeLoading();
        let elements = document.querySelectorAll(".liminal_market_connect_wallet");
        elements.forEach(async (el) => {
            el.addEventListener("click", async (evt) => {
                evt.preventDefault();
                await this.connectWallet(evt.target);
            });
        });
    }
    async connectWallet(button) {
        LoadingHelper.setLoading(button);
        let magicIframe = document.querySelector(".magic-iframe");
        if (magicIframe && magicIframe.style.display == "none")
            magicIframe.style.display = "block";
        let authenticationService = new AuthenticateService();
        await authenticationService
            .authenticateUser((walletConnectionInfo) => {
            this.web3EnabledResult(walletConnectionInfo);
        }, async () => {
            let userInfo = new UserInfo(this.providerInfo);
            await userInfo.render("user_header_info");
            if (document.getElementById("liminal_market_execute_order")) ;
        })
            .catch((reason) => {
            ErrorInfo.report(reason);
        })
            .finally(() => {
            LoadingHelper.removeLoading();
        });
    }
    web3EnabledResult(walletConnectionInfo) {
        this.providerInfo = new ProviderInfo(walletConnectionInfo);
    }
}

var ExecuteOrderButtonHtml = "<button id=\"liminal_market_execute_order\"></button>\n";

var FakeNativeTokenNeededHtml = "You need to have {{symbol}} currency in your wallet. You use {{symbol}} to pay for using the blockchain.\n\nTo get some {{symbol}} currency\n<ol>\n    <li>Copy your address shown below\n        <input value=\"{{ethAddress}}\">\n    </li>\n    <li>Open <a href=\"{{faucetUrl}}\" id=\"getNativeTokens\" target=\"_blank\">{{faucetUrl}}</a></li>\n    <li>Paste in your address you just copied and click the submit button</li>\n</ol>\n\n<div class=\"infoBar d-none\" id=\"waitingForNativeToken\">Waiting for {{symbol}}. Window will close when you have some in\n    you wallet.\n    It might take few minutes after you requested it.\n    <progress></progress>\n</div>\n\n\n\n\n\n\n\n";

var NativeTokenNeededHtml = "You need to have {{symbol}} currency in your wallet. You use {{symbol}} to pay for using the blockchain.\n\nTo get some {{symbol}} currency\n<ol>\n    <li>Copy your address shown below\n        <input value=\"{{ethAddress}}\">\n    </li>\n    <li>Open <a href=\"{{buyUrl}}\" target=\"_blank\">{{buyUrl}}</a></li>\n    <li>Paste in your address you just copied and click the submit button</li>\n</ol>\n\n\n\n\n\n\n";

class NativeTokenNeeded {
    onNativeTokenArrived;
    timeOut = undefined;
    modal;
    constructor(onNativeTokenArrived) {
        this.onNativeTokenArrived = onNativeTokenArrived;
        this.modal = new Modal();
    }
    show() {
        let networkInfo = WidgetGlobals.Network;
        let userService = new UserService();
        let ethAddress = userService.getEthAddress();
        if (networkInfo.TestNetwork) {
            let template = WidgetGlobals.HandlebarsInstance.compile(FakeNativeTokenNeededHtml);
            let content = template({
                symbol: networkInfo.NativeSymbol,
                faucetUrl: networkInfo.FaucetUrl,
                ethAddress: ethAddress,
            });
            this.modal.showModal("Get some " + networkInfo.NativeSymbol, content, false, () => {
                this.cancelTimer();
            });
        }
        else {
            let template = WidgetGlobals.HandlebarsInstance.compile(NativeTokenNeededHtml);
            let content = template({
                symbol: networkInfo.NativeSymbol,
                buyUrl: networkInfo.BuyUrl,
                ethAddress: ethAddress,
            });
            this.modal.showModal("Get some " + networkInfo.NativeSymbol, content, false, () => {
                this.cancelTimer();
            });
        }
        let link = document.getElementById("getNativeTokens");
        if (!link)
            return;
        link.addEventListener("click", async () => {
            let waitingForNativeToken = document.getElementById("waitingForNativeToken");
            waitingForNativeToken?.classList.remove("d-none");
            await this.checkForNativeTokens();
        });
    }
    cancelTimer() {
        if (this.timeOut)
            clearTimeout(this.timeOut);
    }
    async checkForNativeTokens() {
        let networkInfo = WidgetGlobals.Network;
        let hasEnoughNativeTokens = await networkInfo.hasEnoughNativeTokens();
        if (hasEnoughNativeTokens) {
            this.modal.hideModal();
            this.onNativeTokenArrived();
        }
        else {
            this.timeOut = setTimeout(() => this.checkForNativeTokens(), 5 * 1000);
        }
    }
}

var KycActionRequiredHtml = "<div id=\"kycActionRequiredDiv\">\n\n    {{#if Other}}\n    <strong>This is the message from KYC processor we received</strong>\n    <blockquote>\n        {{Other}}\n    </blockquote>\n    {{/if}}\n    <form novalidate id=\"kycActionRequiredForm\" name=\"kycActionRequiredForm\" onsubmit=\"return false;\">\n        {{{KycInfo}}}\n        {{#if SubmitData}}\n        <div class=\"input_error\" id=\"kycActionRequiredError\"></div>\n        <div class=\"buttons\">\n            <button type=\"submit\" id=\"kycActionRequiredSubmit\">Send new information</button>\n        </div>\n        {{/if}}\n    </form>\n</div>\n\n<div id=\"kycActionRequiredSubmittedDiv\" class=\"hidden center\">\n    <h3>You documents have been submitted.<br>We will email you when your account is ready.</h3>\n    You can close this window.\n</div>";

var WeDontKnowWhyHtml = "<fieldset>\n    Your application has been rejected during KYC process.<br><br>\n    We don't have the information on why that happened, but you can email us at\n    <a href=\"mailto:info@liminal.market?subject=My application was rejected&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market\">info@liminal.market</a>\n    and we can find out, and we should be able to solve it together.\n</fieldset>";

var IDENTITY_VERIFICATION = "<fieldset>\n    <p>\n        Identity needs to be verified.\n        This means you need to upload\n        a new photo of your id. You might try another type of ID, such as\n        driver's license if you tried passport before\n    </p>\n    <div class=\"grid\">\n        {{{fileUpload \"identity_verification\" \"Photo ID Front (Front of passport)\"}}}\n    </div>\n    <div class=\"grid\">\n        {{{fileUpload \"identity_verification_2\" \"Photo ID Back (Passport picture of ID) \"}}}\n    </div>\n\n</fieldset>";

var ADDRESS_VERIFICATION = "<fieldset>\n    <p>\n        Address needs to be verified. Please upload document that confirms your address.\n        A bill from the government or utility company in that last 30 days with your name it should work.\n    </p>\n    <div class=\"grid\">\n        {{{fileUpload \"address_verification\" \"Picture of address verification\"}}}\n    </div>\n</fieldset>";

var AFFILIATED = "<fieldset>\n    Further information needs to be submitted if account owner is affiliated to finra or an exchange\n    <br>\n    Please contact us at <a href=\"mailto:info@liminal.market\">info@liminal.market</a> for further information\n</fieldset>";

var CONTROL_PERSON = "<fieldset>\n    Further information needs to be submitted if account owner is a control person\n    <br>\n    Please contact us at <a href=\"mailto:info@liminal.market\">info@liminal.market</a> for further information\n</fieldset>";

var COUNTRY_NOT_SUPPORTED = "<fieldset>\n    The account owner’s country of tax residence is not supported by our KYC providers.\n    In this case, we’ll manually perform KYC on the user\n</fieldset>";

var DATE_OF_BIRTH = "<fieldset>\n    Date of birth needs to be verified. Please upload document that confirms your date of birth.\n\n    <div class=\"grid\">\n        {{{fileUpload \"date_of_birth_verification\" \"Date of birth verification\"}}}\n    </div>\n</fieldset>";

var FAMILY_MEMBER_PEP = "<fieldset>\n    Further information needs to be submitted if family member is a politically exposed person\n    <br>\n    Please contact us at <a href=\"mailto:info@liminal.market\">info@liminal.market</a> for further information\n</fieldset>";

var INVALID_IDENTITY_PASSPORT = "<fieldset>\n    Identity needs to be verified via a government issued ID.\n\n    <div class=\"grid\">\n        {{{fileUpload \"identity_verification\" \"Photo ID Front (Front of passport)\"}}}\n    </div>\n    <div class=\"grid\">\n        {{{fileUpload \"identity_verification_2\" \"Photo ID Back (Passport picture of ID) \"}}}\n    </div>\n</fieldset>";

var PEP = "<fieldset>\n    Further information needs to be submitted if account owner is politically exposed person\n    <br>\n    Please contact us at <a href=\"mailto:info@liminal.market\">info@liminal.market</a> for further information\n</fieldset>";

var SELFIE_VERIFICATION = "<fieldset>\n    Identity needs to be verified via a live selfie of the account owner\n\n    <div class=\"grid\">\n        {{{fileUpload \"identity_verification\" \"Live selfie verification\"}}}\n    </div>\n</fieldset>";

var TAX_IDENTIFICATION = "<fieldset>\n    Tax ID number needs to be verified. Please upload document that confirms your Tax Id\n\n    <div class=\"grid\">\n        {{{fileUpload \"tax_id_verification\" \"Tax id verification\"}}}\n    </div>\n</fieldset>";

var VISA_TYPE_OTHER = "<fieldset>\n    Further information needs to be submitted about account owner’s visa\n    <br>\n    Please contact us at <a href=\"mailto:info@liminal.market\">info@liminal.market</a> for further information\n</fieldset>";

var W8BEN_CORRECTION = "<fieldset>\n    Identifying information submitted by the user was incorrect so a new, corrected, W8BEN needs to be submitted\n    <br>\n    Please contact us at <a href=\"mailto:info@liminal.market\">info@liminal.market</a> for further information\n</fieldset>";

var FileUploadHtml = "<div>\n    <label for=\"{{inputId}}\">{{label}}</label>\n    <input type=\"file\" required id=\"{{inputId}}\" accept=\"{{accept}}\" capture=\"{{capture}}\">\n    <input type=\"hidden\" id=\"{{inputId}}_base64\" name=\"{{inputId}}_base64\">\n    <div class=\"error hidden\" id=\"{{inputId}}_error\"></div>\n</div>\n<div id=\"{{inputId}}_preview\">\n\n</div>";

class FileUpload {
    maxFileSize = 8 * 1024 * 1024 * 10; //10MB
    inputId;
    label;
    accept = "image/*,.pdf";
    capture = "environment";
    constructor(inputId, label, accept = "image/png,image/jpeg,.pdf", capture = "environment") {
        this.inputId = inputId;
        this.label = label;
        this.accept = accept;
        this.capture = capture;
    }
    render() {
        let template = WidgetGlobals.HandlebarsInstance.compile(FileUploadHtml);
        return template(this);
    }
    bindEvents() {
        let fileInput = document.getElementById(this.inputId);
        fileInput?.addEventListener("change", (evt) => {
            this.processFile(fileInput);
        });
    }
    processFile(element) {
        this.hideFileRelatedInfo(element.id);
        let files = element.files;
        if (!files)
            return;
        let file = files[0];
        if (!file) {
            this.showFileRelatedInfo(element.id, "No file selected. Please select file.");
            this.setBase64Input(element.id, "");
            return;
        }
        if (file.size > this.maxFileSize) {
            this.showFileRelatedInfo(element.id, "File " +
                file.name +
                " is to large. Files cannot be larger then 10MB. You need to make it smaller before submitting your application");
            this.setBase64Input(element.id, "");
            return;
        }
        let reader = new FileReader();
        reader.addEventListener("load", () => {
            this.setBase64Input(element.id, reader.result);
        });
        reader.addEventListener("error", () => {
            this.showFileRelatedInfo(element.id, "Could not read file " +
                file.name +
                ". Either the file is corrupt or your browser does not allow us to read it");
        });
        reader.readAsDataURL(file);
    }
    setBase64Input(elementId, value) {
        let base64Input = document.getElementById(elementId + "_base64");
        base64Input.value = value;
        let previewElement = document.getElementById(elementId + "_preview");
        if (!previewElement)
            return;
        if (value.indexOf("data:image") != -1) {
            previewElement.innerHTML = '<img src="' + base64Input.value + '" />';
        }
        else {
            previewElement.innerHTML = "";
        }
    }
    showFileRelatedInfo(elementId, text) {
        let fileRelatedInfo = document.getElementById(elementId + "_error");
        if (!fileRelatedInfo)
            return;
        fileRelatedInfo.innerHTML = text;
        fileRelatedInfo.classList.remove("hidden");
    }
    hideFileRelatedInfo(elementId) {
        let fileRelatedInfo = document.getElementById(elementId + "_error");
        if (!fileRelatedInfo)
            return;
        fileRelatedInfo.classList.add("hidden");
    }
    static fileUploads = [];
    static registerHandler() {
        WidgetGlobals.HandlebarsInstance.registerHelper("fileUpload", (id, label) => {
            let fileUpload = new FileUpload(id, label);
            FileUpload.fileUploads.push(fileUpload);
            return fileUpload.render();
        });
    }
}

class FormValidator {
    selector;
    constructor(selector) {
        this.selector = selector;
    }
    validateRequiredFields() {
        let inputs = document.querySelectorAll(this.selector + ' input[required], ' + this.selector + ' select[required]');
        for (let i = 0; i < inputs.length; i++) {
            let input = inputs[i];
            if (this.isMissingInputFromUser(input)) {
                let obj = {
                    message: 'You must fill into this field',
                    inputName: input.id,
                    labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,
                    pattern: input.pattern
                };
                this.handle(obj);
                return false;
            }
            if (input.pattern) {
                let pattern = input.pattern;
                let matches = input.value.match(pattern);
                if (matches == null) {
                    let obj = {
                        message: 'This is not valid date format, please use YYYY-MM-DD (year-month-date)',
                        inputName: input.id,
                        labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,
                        pattern: input.pattern
                    };
                    this.handle(obj);
                    return false;
                }
            }
        }
        return true;
    }
    isMissingInputFromUser(input) {
        return ((input.type == 'checkbox' && !input.checked) || StringHelper.isNullOrEmpty(input.value));
    }
    removeMissingInfo(errorDivId, focusElementId) {
        let element = document.getElementById(errorDivId);
        if (!element)
            return;
        element.style.display = 'none';
        if (!focusElementId)
            return;
        let focusElement = document.getElementById(focusElementId);
        if (focusElement) {
            focusElement.removeAttribute('aria-invalid');
        }
    }
    setMissingInfo(errorDivId, text, focusElementId) {
        let element = document.getElementById(errorDivId);
        if (!element)
            return;
        element.innerHTML = text;
        if (text == '') {
            element.style.display = 'none';
        }
        else {
            element.style.display = 'block';
            if (focusElementId) {
                document.getElementById(focusElementId)?.focus();
                document.getElementById(focusElementId)?.setAttribute('aria-invalid', 'true');
            }
        }
    }
    handle(obj) {
        let input = document.getElementById(obj.inputName);
        if (!input)
            return;
        let inputError = input.parentElement.querySelector('.input_error');
        if (inputError) {
            inputError.scrollIntoView({ block: 'center' });
            return;
        }
        input.setAttribute('aria-invalid', 'true');
        input.insertAdjacentHTML("beforebegin", '<div class="input_error" style="display: block" id="input_error_' + obj.inputName + '">' + obj.message + '</div>');
        input.focus();
        if (obj.pattern) {
            input.setAttribute('pattern', obj.pattern);
        }
        input.addEventListener('blur', (evt) => {
            evt.preventDefault();
            setTimeout(() => {
                let input = evt.target;
                let pattern = input.getAttribute('pattern');
                if ((pattern && input.value.match(pattern)) || (input.required && input.value) || input.checked) {
                    input.removeAttribute('aria-invalid');
                    let errorMessage = document.getElementById('input_error_' + obj.inputName);
                    if (errorMessage)
                        errorMessage.remove();
                }
            }, 800);
        });
    }
}

class KYCService extends BlockchainService {
    constructor() {
        super();
    }
    async saveKYCInfo(data) {
        return await this.post("kycRegistration", data);
    }
    async updateDocuments(params) {
        return await this.post("kycActionRequiredUpdate", params);
    }
}

class KycActionRequired {
    modal;
    templates;
    executeTradeButton;
    constructor(executeTradeButton) {
        this.modal = new Modal();
        this.templates = new Map();
        this.executeTradeButton = executeTradeButton;
        this.templates.set("WeDontKnowWhyHtml", WeDontKnowWhyHtml);
        this.templates.set("ADDRESS_VERIFICATION", ADDRESS_VERIFICATION);
        this.templates.set("AFFILIATED", AFFILIATED);
        this.templates.set("CONTROL_PERSON", CONTROL_PERSON);
        this.templates.set("COUNTRY_NOT_SUPPORTED", COUNTRY_NOT_SUPPORTED);
        this.templates.set("DATE_OF_BIRTH", DATE_OF_BIRTH);
        this.templates.set("FAMILY_MEMBER_PEP", FAMILY_MEMBER_PEP);
        this.templates.set("IDENTITY_VERIFICATION", IDENTITY_VERIFICATION);
        this.templates.set("INVALID_IDENTITY_PASSPORT", INVALID_IDENTITY_PASSPORT);
        this.templates.set("PEP", PEP);
        this.templates.set("SELFIE_VERIFICATION", SELFIE_VERIFICATION);
        this.templates.set("TAX_IDENTIFICATION", TAX_IDENTIFICATION);
        this.templates.set("VISA_TYPE_OTHER", VISA_TYPE_OTHER);
        this.templates.set("W8BEN_CORRECTION", W8BEN_CORRECTION);
        FileUpload.registerHandler();
    }
    async show() {
        let userService = new UserService();
        let kycResult = await userService.kycActionRequired();
        if (!kycResult)
            return;
        let kycInfo = this.getKycMessages(kycResult.messages);
        let template = WidgetGlobals.HandlebarsInstance.compile(KycActionRequiredHtml);
        let content = template({
            json: JSON.stringify(kycResult),
            KycInfo: kycInfo,
            Other: kycResult.additional_information,
            SubmitData: kycInfo.indexOf("<input") != -1,
        });
        this.modal.showModal("Action required", content, false, () => { }, false);
        let kycActionRequiredForm = document.getElementById("kycActionRequiredForm");
        kycActionRequiredForm?.addEventListener("submit", async (evt) => {
            evt.preventDefault();
            this.hideError();
            let submitBtn = document.getElementById("kycActionRequiredSubmit");
            LoadingHelper.setLoading(submitBtn);
            let formValidator = new FormValidator("#kycActionRequiredForm");
            if (!formValidator.validateRequiredFields())
                return;
            let params = FormHelper.getParams("#kycActionRequiredForm");
            let kycService = new KYCService();
            await kycService
                .updateDocuments(params)
                .then(() => {
                let kycActionRequiredDiv = document.getElementById("kycActionRequiredDiv");
                kycActionRequiredDiv?.classList.add("hidden");
                let kycActionRequiredSubmittedDiv = document.getElementById("kycActionRequiredSubmittedDiv");
                kycActionRequiredSubmittedDiv?.classList.remove("hidden");
                this.executeTradeButton.renderButton();
            })
                .catch((reason) => {
                this.showError(reason);
            })
                .finally(() => {
                LoadingHelper.removeLoading();
            });
        });
        for (let i = 0; i < FileUpload.fileUploads.length; i++) {
            FileUpload.fileUploads[i].bindEvents();
        }
    }
    getKycMessages(messages) {
        let kycInfo = "";
        for (let i = 0; i < messages.length; i++) {
            let htmlTemplate = this.templates.get(messages[i].key);
            if (!htmlTemplate) {
                //TODO: Here we should to logger, critical that we dont know why
                continue;
            }
            let template = WidgetGlobals.HandlebarsInstance.compile(htmlTemplate);
            kycInfo += template({ message: messages[i].message });
        }
        if (kycInfo == "") {
            let html = this.templates.get("WeDontKnowWhyHtml");
            let template = WidgetGlobals.HandlebarsInstance.compile(html);
            kycInfo = template({});
        }
        return kycInfo;
    }
    hideError() {
        let kycActionRequiredError = document.getElementById("kycActionRequiredError");
        if (!kycActionRequiredError)
            return;
        kycActionRequiredError.style.display = "none";
    }
    showError(reason) {
        let kycActionRequiredError = document.getElementById("kycActionRequiredError");
        if (!kycActionRequiredError)
            return;
        kycActionRequiredError.innerHTML =
            "Error occurred while saving your documents. Reason:" + reason;
        kycActionRequiredError.style.display = "block";
    }
}

var KYCFormHtml = "<div id=\"kyc_reg\">\n\n    <form id=\"kyc_wizard_form\" name=\"kyc_wizard_form\" novalidate onsubmit=\"return false\">\n        {{{KycContactHtml}}}\n        {{{KycIdentityHtml}}}\n        {{{KycTrustedContactHtml}}}\n        {{{KycDisclosureHtml}}}\n        {{{KycUploadHtml}}}\n        {{{KycAccountAgreementHtml}}}\n    </form>\n</div>\n\n<div id=\"waiting_for_kyc_reg\" class=\"hidden\">\n    KYC is being processed. This may take about 4-5 minutes. Window will close when it's done.\n    <br><br>\n    You can close the window, we will email you when KYC is finished.\n\n    <progress></progress>\n\n</div>";

var KycContactHtml = "<fieldset class=\"kycContact hidden\" data-form=\"1\">\n    <div class=\"explain\">\n        To be able to trade on the stock market, we need to get your information.\n        This is a requirement from the financial regulators.\n    </div>\n    <div>\n        <label for=\"email_address\">Email</label>\n        <input type=\"email\" required class=\"form-control\" id=\"email_address\" name=\"email_address\" placeholder=\"name@example.com\" autocomplete=\"email\" value=\"\">\n    </div>\n    <div>\n        <label for=\"phone_number\">Phone</label>\n        <input type=\"tel\" class=\"form-control\" id=\"phone_number\" name=\"phone_number\" placeholder=\"+1-555-666-7788\" autocomplete=\"tel\" value=\"\">\n    </div>\n    <div>\n        <label for=\"street_address\">Permanent Residential Address</label>\n        <div class=\"explain\">It must be a physical address, not a PO box.</div>\n        <input required id=\"street_address\" name=\"street_address\" placeholder=\"20 N San Mateo Dr\" value=\"\" autocomplete=\"address-line1\">\n    </div>\n    <div>\n        <label for=\"unit\">Unit / Apt #</label>\n        <input id=\"unit\" name=\"unit\" value=\"\">\n    </div>\n    <div>\n        <label for=\"city\">City</label>\n        <input id=\"city\" name=\"city\" placeholder=\"Pawnee\" value=\"\" autocomplete=\"address-level2\">\n    </div>\n    <div>\n        <label for=\"postal_code\">Postal code</label>\n        <input required id=\"postal_code\" autocomplete=\"postal-code\" name=\"postal_code\" placeholder=\"94401\" value=\"\">\n    </div>\n    <div id=\"state_div\">\n        <label for=\"state\">State (2 letters)</label>\n        <input maxlength=\"2\" id=\"state\" name=\"state\" placeholder=\"NY\" value=\"\" autocomplete=\"address-level1\">\n    </div>\n    <div>\n        <label for=\"country_of_tax_residence\">Country of tax residence</label>\n        {{#if edit}}\n        <input name=\"country_of_tax_residence\" readonly=\"readonly\" id=\"country_of_tax_residence\">\n        {{/if}}\n        {{#unless edit}}\n        <select required id=\"country_of_tax_residence\" name=\"country_of_tax_residence\" autocomplete=\"country\">\n            <option value=\"\"></option>\n            {{#each countries}}\n            <option value=\"{{code}}\">{{name}}</option>\n            {{/each}}\n        </select>\n        {{/unless}}\n    </div>\n    <div class=\"buttons\">\n        <button type=\"button\" id=\"contact_next\">Next: Identity</button>\n    </div>\n</fieldset>\n";

class KycValidatorError {
    validValues = '';
    inputName = '';
    labelText = '';
    message;
    pattern = '';
    onshow;
    kycForm;
    constructor(error, kycForm) {
        let obj = {};
        this.kycForm = kycForm;
        try {
            if (!error.inputName && typeof error == 'string') {
                obj = JSON.parse(error);
            }
            else {
                obj = error;
            }
            this.message = obj.message?.replace(/_/g, ' ');
            this.validValues = obj.validValues?.replace(/_/g, ' ');
            this.inputName = obj.inputName;
            this.labelText = obj.labelText;
            this.pattern = obj.pattern;
            this.onshow = obj.onshow;
            if (obj.serverError) {
                this.message = obj.serverError;
                if (this.message.indexOf('account with the requested email address already exists') != -1) {
                    this.inputName = 'email_address';
                    this.labelText = 'Email';
                }
            }
        }
        catch (e) {
            this.message = error.messsage;
        }
    }
    handle() {
        if (StringHelper.isNullOrEmpty(this.inputName)) {
            let activeFieldset = document.querySelector(this.kycForm.activeFieldsetSelector);
            let inputError = activeFieldset.querySelector('.input_error');
            if (inputError) {
                if (this.validValues) {
                    inputError.innerHTML = this.validValues.toString();
                }
                else {
                    inputError.innerHTML = this.message;
                }
                inputError.style.display = 'block';
                inputError.scrollIntoView();
            }
            return;
        }
        let input = document.getElementById(this.inputName);
        if (!input)
            return;
        let inputError = input.parentElement.querySelector('.input_error');
        if (inputError) {
            inputError.scrollIntoView({ block: 'center' });
            return;
        }
        input.setAttribute('aria-invalid', 'true');
        let errorInput = '<div class="input_error" style="display: block" id="input_error_' + this.inputName + '">' + this.message + '</div>';
        if (input.clientWidth < 300) {
            let div = this.getDivToDisplayErrorMessage(input);
            div.insertAdjacentHTML("beforebegin", errorInput);
        }
        else {
            input.insertAdjacentHTML("beforebegin", errorInput);
        }
        input.focus();
        if (this.pattern) {
            input.setAttribute('pattern', this.pattern);
        }
        input.addEventListener('blur', (evt) => {
            evt.preventDefault();
            setTimeout(() => {
                let input = evt.target;
                let pattern = input.getAttribute('pattern');
                if ((pattern && input.value.match(pattern)) || (input.type != 'checkbox' && input.type != 'radio' && input.required && input.value) || input.checked) {
                    input.removeAttribute('aria-invalid');
                    let errorMessage = document.getElementById('input_error_' + this.inputName);
                    if (errorMessage)
                        errorMessage.remove();
                }
            }, 800);
        });
        let fieldsetElement = input.closest('fieldset[data-form="1"]');
        if (fieldsetElement) {
            let className = fieldsetElement.className.replace('hidden', '').trim();
            this.kycForm.show(className);
            input.scrollIntoView(false);
        }
        if (this.onshow) {
            let link = document.getElementById(this.onshow.id);
            if (!link)
                return;
            link.addEventListener('click', async (evt) => {
                evt.preventDefault();
                //await this(this.onshow.functionName, this.onshow.params);
                //TODO: fix send email
                document.getElementById('input_error_' + this.inputName).innerHTML = 'Email has been sent to ' + this.onshow.params.email;
            });
        }
    }
    getDivToDisplayErrorMessage(input, counter = 1) {
        let div = input.parentElement.closest('div');
        if (!div)
            return input;
        if (div.clientWidth > 300 || counter > 5) {
            return div;
        }
        return this.getDivToDisplayErrorMessage(div, ++counter);
    }
}

class KycBase {
    kycForm;
    constructor(kycForm) {
        this.kycForm = kycForm;
        FileUpload.registerHandler();
    }
    showFieldset(selector, header) {
        this.hideFieldsets();
        document.querySelector(selector)?.classList.remove('hidden');
        document.querySelector('#liminal_market_modal_div > article > header > span').innerHTML = header;
        document.querySelector('#liminal_market_modal_div > article').scrollTop = 0;
        this.kycForm.activeFieldsetSelector = selector;
    }
    showRequiredMarker() {
        let inputs = document.querySelectorAll('input, select');
        for (let i = 0; i < inputs.length; i++) {
            let input = inputs[i];
            if (!input.id)
                continue;
            let label = document.querySelector('label[for=' + input.id + ']');
            if (!label)
                continue;
            if (input.required) {
                if (label.innerHTML.indexOf('*') == -1) {
                    label.innerHTML += '*';
                }
            }
            else {
                if (label.innerHTML.indexOf('*') != -1) {
                    label.innerHTML = label.innerHTML.replace('*', '');
                }
            }
        }
    }
    setRequired(inputId) {
        document.getElementById(inputId)?.setAttribute('required', 'required');
    }
    removeRequired(inputId) {
        document.getElementById(inputId)?.removeAttribute('required');
    }
    bind(selector, eventName, action) {
        let elements = document.querySelectorAll(selector);
        for (let i = 0; i < elements.length; i++) {
            elements[i].addEventListener(eventName, (evt) => {
                action(evt);
            });
        }
    }
    bindFileUploads() {
        for (let i = 0; i < FileUpload.fileUploads.length; i++) {
            FileUpload.fileUploads[i].bindEvents();
        }
    }
    hideFieldsets() {
        let fieldsets = document.querySelectorAll('#kyc_wizard_form > fieldset');
        for (let i = 0; i < fieldsets.length; i++) {
            fieldsets[i].classList.add('hidden');
        }
    }
    validateRequiredFields(selector) {
        let inputs = document.querySelectorAll(selector + ' input[required], ' + selector + ' select[required]');
        for (let i = 0; i < inputs.length; i++) {
            let input = inputs[i];
            if (this.isMissingInputFromUser(input)) {
                let obj = {
                    message: 'You must fill into this field',
                    inputName: input.id,
                    labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,
                    pattern: input.pattern
                };
                let kycValidationError = new KycValidatorError(obj, this.kycForm);
                kycValidationError.handle();
                return false;
            }
            if (input.pattern) {
                let pattern = input.pattern;
                let matches = input.value.match(pattern);
                if (matches == null) {
                    let obj = {
                        message: 'This is not valid date format, please use YYYY-MM-DD (year-month-date)',
                        inputName: input.id,
                        labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,
                        pattern: input.pattern
                    };
                    let kycValidationError = new KycValidatorError(obj, this.kycForm);
                    kycValidationError.handle();
                    return false;
                }
            }
        }
        return true;
    }
    showElement(elementId) {
        document.getElementById(elementId)?.classList.remove('hidden');
    }
    hideElement(elementId) {
        document.getElementById(elementId)?.classList.add('hidden');
    }
    setLabel(elementId, text) {
        let element = document.getElementById('tax_id_label');
        if (!element)
            return;
        element.innerHTML = text;
    }
    isMissingInputFromUser(input) {
        return ((input.type == 'checkbox' && !input.checked) || StringHelper.isNullOrEmpty(input.value));
    }
    removeMissingInfo(errorDivId, focusElementId) {
        let element = document.getElementById(errorDivId);
        if (!element)
            return;
        element.style.display = 'none';
        if (!focusElementId)
            return;
        let focusElement = document.getElementById(focusElementId);
        if (focusElement) {
            focusElement.removeAttribute('aria-invalid');
        }
    }
    setMissingInfo(errorDivId, text, focusElementId) {
        let element = document.getElementById(errorDivId);
        if (!element)
            return;
        element.innerHTML = text;
        if (text == '') {
            element.style.display = 'none';
        }
        else {
            element.style.display = 'block';
            if (focusElementId) {
                document.getElementById(focusElementId)?.focus();
                document.getElementById(focusElementId)?.setAttribute('aria-invalid', 'true');
            }
        }
    }
}

class KycContact extends KycBase {
    usTaxResidence = false;
    constructor(kycForm) {
        super(kycForm);
    }
    render(edit = false) {
        let template = WidgetGlobals.HandlebarsInstance.compile(KycContactHtml);
        return template({ edit: edit, countries: CountryHelper.Countries });
    }
    show() {
        this.showFieldset(".kycContact", "Contact information");
    }
    bindEvents() {
        this.bind("#country_of_tax_residence", "change", (evt) => {
            let input = evt.target;
            this.usTaxResidence = input.value.toUpperCase() == "USA";
            if (this.usTaxResidence) {
                document.getElementById("state_div")?.classList.remove("hidden");
                this.kycForm.setSteps(5);
                this.setRequired("state");
            }
            else {
                this.kycForm.setSteps(6);
                this.removeRequired("state");
                document.getElementById("state_div")?.classList.add("hidden");
            }
        });
        let showIdentityButton = document.getElementById("contact_next");
        if (showIdentityButton) {
            showIdentityButton.addEventListener("click", (evt) => {
                if (!this.validateRequiredFields(".kycContact"))
                    return;
                this.kycForm.kycIdentity.show();
            });
        }
    }
}

var KycIdentityHtml = "<fieldset class=\"kycIdentity hidden\" data-form=\"1\">\n    <div>\n        <label for=\"given_name\">Legal First name</label>\n        <input required id=\"given_name\" name=\"given_name\" placeholder=\"Ron\" value=\"\" autocomplete=\"given-name\">\n    </div>\n    <div>\n        <label for=\"middle_name\">Legal Middle name</label>\n        <input id=\"middle_name\" name=\"middle_name\" placeholder=\"\" value=\"\" autocomplete=\"additional-name\">\n    </div>\n    <div>\n        <label for=\"family_name\">Legal Last name</label>\n        <input required id=\"family_name\" name=\"family_name\" placeholder=\"Swanson\" value=\"\" autocomplete=\"family-name\">\n    </div>\n    {{#unless edit}}\n    <div>\n        <label for=\"date_of_birth\">Date of birth</label>\n        <input type=\"date\" required id=\"date_of_birth\" name=\"date_of_birth\" placeholder=\"1978-11-24\" pattern=\"\\d{4}-\\d{2}-\\d{2}\" value=\"\" autocomplete=\"bday\">\n    </div>\n\n    <div id=\"citizen_of_usa_question\" class=\"hidden\">\n        <label for=\"citizen_yes\">Are you a citizen of the United States?</label>\n        <fieldset>\n            <label>\n                <input type=\"radio\" id=\"citizen_yes\" name=\"citizen\" value=\"1\"> Yes\n            </label>\n            <label>\n                <input type=\"radio\" id=\"citizen_no\" name=\"citizen\" value=\"0\"> No\n            </label>\n            <fieldset id=\"citizen_no_type_options\" class=\"hidden\">\n                <label>\n                    <input type=\"radio\" name=\"permanent_resident\" id=\"citizen_no_type_options_1\" value=\"1\"> Green Card\n                    / Permanent Resident\n                </label>\n                <label><input type=\"radio\" name=\"permanent_resident\" id=\"citizen_no_type_options_2\" value=\"0\">\n                    Visa</label>\n            </fieldset>\n        </fieldset>\n    </div>\n    <div id=\"tax_id_type_options\">\n        <label for=\"tax_id_type\">Tax Id Type</label>\n        <select required id=\"tax_id_type\" name=\"tax_id_type\" placeholder=\"USA_SSN\">\n            <option value=\"USA_SSN\"></option>\n            <option value=\"ARG_AR_CUIT\">Argentina CUIT</option>\n            <option value=\"AUS_TFN\">Australian Tax File Number</option>\n            <option value=\"AUS_ABN\">Australian Business Number</option>\n            <option value=\"BOL_NIT\">Bolivia NIT</option>\n            <option value=\"BRA_CPF\">Brazil CPF</option>\n            <option value=\"CHL_RUT\">Chile RUT</option>\n            <option value=\"COL_NIT\">Colombia NIT</option>\n            <option value=\"CRI_NITE\">Costa Rica NITE</option>\n            <option value=\"DEU_TAX_ID\">Germany Tax ID (Identifikationsnummer)</option>\n            <option value=\"DOM_RNC\">Dominican Republic RNC</option>\n            <option value=\"ECU_RUC\">Ecuador RUC</option>\n            <option value=\"FRA_SPI\">France SPI (Reference Tax Number)</option>\n            <option value=\"GBR_UTR\">UK UTR (Unique Taxpayer Reference)</option>\n            <option value=\"GBR_NINO\">UK NINO (National Insurance Number)</option>\n            <option value=\"GTM_NIT\">Guatemala NIT</option>\n            <option value=\"HND_RTN\">Honduras RTN</option>\n            <option value=\"HUN_TIN\">Hungary TIN Number</option>\n            <option value=\"IDN_KTP\">Indonesia KTP</option>\n            <option value=\"IND_PAN\">India PAN Number</option>\n            <option value=\"ISR_TAX_ID\">Israel Tax ID (Teudat Zehut)</option>\n            <option value=\"ITA_TAX_ID\">Italy Tax ID (Codice Fiscale)</option>\n            <option value=\"JPN_TAX_ID\">Japan Tax ID (Koijin Bango)</option>\n            <option value=\"MEX_RFC\">Mexico RFC</option>\n            <option value=\"NIC_RUC\">Nicaragua RUC</option>\n            <option value=\"NLD_TIN\">Netherlands TIN Number</option>\n            <option value=\"PAN_RUC\">Panama RUC</option>\n            <option value=\"PER_RUC\">Peru RUC</option>\n            <option value=\"PRY_RUC\">Paraguay RUC</option>\n            <option value=\"SGP_NRIC\">Singapore NRIC</option>\n            <option value=\"SGP_FIN\">Singapore FIN</option>\n            <option value=\"SGP_ASGD\">Singapore ASGD</option>\n            <option value=\"SGP_ITR\">Singapore ITR</option>\n            <option value=\"SLV_NIT\">El Salvador NIT</option>\n            <option value=\"SWE_TAX_ID\">Sweden Tax ID (Personnummer)</option>\n            <option value=\"URY_RUT\">Uruguay RUT</option>\n            <option value=\"VEN_RIF\">Venezuela RIF</option>\n            <option value=\"NOT_SPECIFIED\">Other Tax IDs</option>\n        </select>\n    </div>\n    <div>\n        <label id=\"tax_id_label\" for=\"tax_id\">Tax Id (SSN)</label>\n        <input required id=\"tax_id\" name=\"tax_id\" placeholder=\"666-55-4321\" value=\"\">\n    </div>\n    <div id=\"country_of_birth_option\">\n        <label for=\"country_of_birth\">Country of birth</label>\n        <select id=\"country_of_birth\" name=\"country_of_birth\">\n            {{#each countries}}\n            <option value=\"{{code}}\">{{name}}</option>\n            {{/each}}\n        </select>\n    </div>\n    <div id=\"country_of_citizenship_option\">\n        <label for=\"country_of_citizenship\">Country of citizenship</label>\n        <select required id=\"country_of_citizenship\" name=\"country_of_citizenship\">\n            <option value=\"\"></option>\n            {{#each countries}}\n            <option value=\"{{code}}\">{{name}}</option>\n            {{/each}}\n        </select>\n    </div>\n    <div id=\"visa_type_option\" class=\"hidden\">\n        <div>\n            <label for=\"visa_type\">Visa type - <a href=\"https://travel.state.gov/content/travel/en/us-visas/visa-information-resources/all-visa-categories.html\" target=\"_blank\">Visa\n                information</a></label>\n            <select id=\"visa_type\" name=\"visa_type\">\n                <option value=\"\"></option>\n                <option value=\"B1\" selected=\"selected\">USA Visa Category B-1</option>\n                <option value=\"B2\">USA Visa Category B-2</option>\n                <option value=\"DACA\">USA Visa Category DACA</option>\n                <option value=\"E1\">USA Visa Category E-1</option>\n                <option value=\"E2\">USA Visa Category E-2</option>\n                <option value=\"E3\">USA Visa Category E-3</option>\n                <option value=\"F1\">USA Visa Category F-1</option>\n                <option value=\"G4\">USA Visa Category G-4</option>\n                <option value=\"H1B\">USA Visa Category H-1B</option>\n                <option value=\"J1\">USA Visa Category J-1</option>\n                <option value=\"L1\">USA Visa Category L-1</option>\n                <option value=\"OTHER\">Any other USA Visa Category</option>\n                <option value=\"O1\">USA Visa Category O-1</option>\n                <option value=\"TN1\">USA Visa Category TN-1</option>\n            </select>\n        </div>\n        <div id=\"visa_expiration_date_option\">\n            <label for=\"visa_expiration_date\">Visa expiration date</label>\n            <input type=\"date\" id=\"visa_expiration_date\" name=\"visa_expiration_date\" placeholder=\"2028-05-01\" value=\"\">\n        </div>\n        <div id=\"date_of_departure_from_usa_option\">\n            <label for=\"date_of_departure_from_usa\">Date of departure from USA</label>\n            <input type=\"date\" id=\"date_of_departure_from_usa\" name=\"date_of_departure_from_usa\" placeholder=\"2028-05-01\" value=\"\">\n        </div>\n\n    </div>\n    <div>\n        <label for=\"annual_income\">Annual Household Income</label>\n        <div class=\"explain\">\n            Annual household income includes income from sources such as employment, alimony, social security,\n            investment income, etc.\n        </div>\n        <select name=\"annual_income\" id=\"annual_income\">\n            <option value=\"\"></option>\n            <option value=\"1\">0 - $20,000</option>\n            <option value=\"2\">$20,000 - $49,999</option>\n            <option value=\"3\">$50,000 - $99,999</option>\n            <option value=\"4\">$100,000 - $499,999</option>\n            <option value=\"5\">$500,000 - $999,999</option>\n            <option value=\"6\">$1,000,000 - $9,999,999</option>\n        </select>\n    </div>\n    <div>\n        <label for=\"liquid_net_worth\">Liquid Assets</label>\n        <div class=\"explain\">Liquid assets is your net worth minus assets that cannot be\n            converted quickly and easily into cash, such as real estate, business equity,\n            personal property and automobiles, expected inheritances, assets earmarked for\n            other purposes, and investments or accounts subject to substantial penalties\n            if they were sold or if assets were withdrawn from them.\n        </div>\n        <select name=\"liquid_net_worth\" required id=\"liquid_net_worth\">\n            <option value=\"\"></option>\n            <option value=\"1\">0 - $20,000</option>\n            <option value=\"2\">$20,000 - $49,999</option>\n            <option value=\"3\">$50,000 - $99,999</option>\n            <option value=\"4\">$100,000 - $499,999</option>\n            <option value=\"5\">$500,000 - $999,999</option>\n            <option value=\"1\">$1,000,000 - $9,999,999</option>\n        </select>\n    </div>\n\n    <div>\n        <label for=\"funding_source\">Funding source</label>\n        <select required id=\"funding_source\" name=\"funding_source\" multiple=\"multiple\" size=\"4\" aria-label=\"size 3 select\">\n            <option value=\"employment_income\">Employment income</option>\n            <option value=\"investments\">Investments</option>\n            <option value=\"inheritance\">Inheritance</option>\n            <option value=\"business_income\">Business income</option>\n            <option value=\"savings\">Savings</option>\n            <option value=\"family\">Family</option>\n        </select>\n    </div>\n    {{/unless}}\n    <div class=\"grid buttons\">\n        <button type=\"button\" id=\"identity_prev\">Previous: Contact</button>\n        <button type=\"button\" id=\"identity_next\">Next: Trusted contacts</button>\n    </div>\n</fieldset>";

class KycIdentity extends KycBase {
    edit = false;
    constructor(kycForm) {
        super(kycForm);
    }
    render(edit = false) {
        this.edit = edit;
        let template = WidgetGlobals.HandlebarsInstance.compile(KycIdentityHtml);
        return template({ edit: edit, countries: CountryHelper.Countries });
    }
    show() {
        if (this.kycForm.kycContact.usTaxResidence) {
            this.showElement("citizen_of_usa_question");
            this.hideElement("tax_id_type_options");
            this.setLabel("tax_id_label", "SSN");
        }
        else {
            this.hideElement("citizen_of_usa_question");
            this.setLabel("tax_id_label", "National Tax Id (SSN)");
            this.showElement("tax_id_type_options");
        }
        this.showFieldset(".kycIdentity", "Identity");
        this.showElement("country_of_citizenship_option");
        let country_of_citizenship = document.getElementById("country_of_citizenship");
        if (country_of_citizenship) {
            country_of_citizenship.options[1].disabled = false;
        }
    }
    bindEvents() {
        this.bind("#citizen_yes", "click", (evt) => {
            let input = evt.target;
            if (input.checked) {
                let taxIdType = document.getElementById("tax_id_type");
                if (taxIdType)
                    taxIdType.value = "USA_SSN";
                let country_of_citizenship = document.getElementById("country_of_citizenship");
                country_of_citizenship.options[1].disabled = false;
                country_of_citizenship.value = "USA";
                this.hideElement("citizen_no_type_options");
                this.hideElement("visa_type_option");
                this.hideElement("country_of_citizenship_option");
                this.removeRequired("country_of_birth");
                this.removeRequired("visa_type");
                this.removeRequired("visa_expiration_date");
                this.removeRequired("date_of_departure_from_usa");
                document.getElementById("tax_id_label").innerHTML = "SSN";
                this.hideCitizenErrorMessage();
            }
        });
        this.bind("#citizen_no", "click", (evt) => {
            let input = evt.target;
            if (input.checked) {
                this.showElement("citizen_no_type_options");
                this.showElement("country_of_citizenship_option");
                this.setRequired("country_of_birth");
                document.getElementById("tax_id_label").innerHTML = "SSN";
                let country_of_citizenship = document.getElementById("country_of_citizenship");
                country_of_citizenship.options[0].selected = true;
                country_of_citizenship.options[1].disabled = true;
                this.hideCitizenErrorMessage();
            }
        });
        this.bind("#citizen_no_type_options_1", "click", (evt) => {
            let input = evt.target;
            if (input.checked) {
                this.showElement("country_of_citizenship_option");
                this.hideElement("visa_type_option");
                this.setRequired("country_of_birth");
                this.removeRequired("visa_type");
                this.removeRequired("visa_expiration_date");
                this.removeRequired("date_of_departure_from_usa");
            }
        });
        this.bind("#citizen_no_type_options_2", "click", (evt) => {
            let input = evt.target;
            if (input.checked) {
                this.showElement("visa_type_option");
                this.showElement("country_of_citizenship_option");
                this.setRequired("country_of_birth");
                this.setRequired("country_of_citizenship");
                this.setRequired("visa_type");
                this.setRequired("visa_expiration_date");
                this.setRequired("date_of_departure_from_usa");
            }
        });
        this.bind("#visa_type", "change", (evt) => {
            let input = evt.target;
            if (input.value == "B1" || input.value == "B2") {
                this.showElement("date_of_departure_from_usa_option");
            }
            else {
                this.hideElement("date_of_departure_from_usa_option");
            }
        });
        this.bindButtons();
    }
    hideCitizenErrorMessage() {
        document.getElementById("citizen_yes").removeAttribute("aria-invalid");
        let errorMessage = document.getElementById("input_error_citizen_yes");
        if (errorMessage)
            errorMessage.remove();
    }
    bindButtons() {
        let showContactButton = document.getElementById("identity_prev");
        showContactButton?.addEventListener("click", (evt) => {
            this.kycForm.kycContact.show();
        });
        let showDisclosuresButton = document.getElementById("identity_next");
        showDisclosuresButton?.addEventListener("click", (evt) => {
            if (!this.validateInputs())
                return;
            if (!this.validateRequiredFields(".kycIdentity"))
                return;
            this.kycForm.kycTrustedContact.show();
        });
    }
    validateInputs() {
        if (this.edit)
            return true;
        let citizen_yes = document.getElementById("citizen_yes");
        let citizen_no = document.getElementById("citizen_no");
        if (!this.kycForm.kycContact.usTaxResidence) {
            citizen_yes.checked = false;
            citizen_no.checked = false;
            return true;
        }
        if (!citizen_yes.checked && !citizen_no.checked) {
            let obj = {
                message: "You must select either option",
                inputName: "citizen_yes",
                labelText: document.querySelector("label[for=citizen_yes]").innerHTML,
            };
            let kycValidationError = new KycValidatorError(obj, this.kycForm);
            kycValidationError.handle();
            return false;
        }
        let greenCardOption = document.getElementById("citizen_no_type_options_1");
        let visaOption = document.getElementById("citizen_no_type_options_2");
        if (citizen_no.checked && !greenCardOption.checked && !visaOption.checked) {
            let obj = {
                message: 'You must select either option, "Green Card / Permanent Resident" or "Visa"',
                inputName: "citizen_no",
                labelText: "",
            };
            let kycValidationError = new KycValidatorError(obj, this.kycForm);
            kycValidationError.handle();
            return false;
        }
        return true;
    }
}

var KycDisclosureHtml = "<fieldset class=\"kycDisclosures hidden\" data-form=\"1\">\n    {{#unless edit}}\n    <div>\n        <label for=\"employment_status\">Employment status</label>\n        <select id=\"employment_status\" required name=\"employment_status\">\n            <option value=\"\"></option>\n            <option value=\"employed\">Employed</option>\n            <option value=\"unemployed\">Unemployed</option>\n            <option value=\"retired\">Retired</option>\n            <option value=\"student\">Student</option>\n        </select>\n    </div>\n    <div>\n        <label for=\"employer_name\">Employer name</label>\n        <input name=\"employer_name\" id=\"employer_name\">\n    </div>\n    <div>\n        <label for=\"employer_address\">Employer address</label>\n        <input name=\"employer_address\" id=\"employer_address\">\n    </div>\n    <div>\n        <label for=\"employment_position\">Occupation / Job title</label>\n        <input name=\"employment_position\" id=\"employment_position\" autocomplete=\"organization-title\">\n    </div>\n    {{/unless}}\n    <div class=\"disclosure_selections\">\n        Do any of the following apply to you or a member of your immediate family?\n        <div class=\"grid\">\n            <div>\n                <label for=\"is_affiliated_exchange_or_finra\">\n                    <input type=\"checkbox\" id=\"is_affiliated_exchange_or_finra\" name=\"is_affiliated_exchange_or_finra\" role=\"switch\">\n                </label>\n            </div>\n            <div>\n                Affiliated or work with a US registered broker-dealer or\n                FINRA.\n                <small class=\"explain\">Are you or an immediate family member affiliated with or employed by a stock\n                    exchange, regulatory body, member firm of an exchange, FINRA or a municipal securities\n                    broker-dealer?</small>\n\n                <div id=\"is_affiliated_exchange_or_finra_extra\"></div>\n            </div>\n        </div>\n        <div class=\"grid\">\n            <div>\n                <label for=\"is_control_person\">\n                    <input type=\"checkbox\" id=\"is_control_person\" name=\"is_control_person\" role=\"switch\">\n                </label>\n            </div>\n            <div>\n\n                Senior executive at or a 10% or greater shareholder of a publicly traded company.\n                <small class=\"explain\">Are you or an immediate family member an officer or 10% or greater shareholder of\n                    a publicly traded company, subject to the US Securities Exchange Act 1934?</small>\n                <div id=\"is_control_person_extra\"></div>\n            </div>\n        </div>\n        <div class=\"grid\">\n            <div>\n                <label for=\"is_politically_exposed\">\n                    <input type=\"checkbox\" id=\"is_politically_exposed\" name=\"is_politically_exposed\" role=\"switch\">\n                </label>\n            </div>\n            <div>\n                I am a senior political figure.\n                <small class=\"explain\">Are you currently or formerly a Politically Exposed Person or Public Official\n                    (PEP)? <a href=\"https://www.google.com/search?q=%E2%80%9CPolitically+Exposed+Person%E2%80%9D+(PEP)\" target=\"_blank\">What is PEP?</a> </small>\n                <div id=\"is_politically_exposed_extra\"></div>\n            </div>\n            \n        </div>\n        <div class=\"grid\">\n            <div>\n                <label for=\"immediate_family_exposed\">\n                    <input type=\"checkbox\" id=\"immediate_family_exposed\" name=\"immediate_family_exposed\" role=\"switch\">\n                </label>\n            </div>\n            <div>\n                I am a family member or relative of a senior political figure.\n                <small class=\"explain\">Are you an immediate family member currently or formerly a Politically Exposed\n                    Person or Public Official (PEP)? <a href=\"https://www.google.com/search?q=%E2%80%9CPolitically+Exposed+Person%E2%80%9D+(PEP)\" target=\"_blank\">What is PEP?</a></small>\n                <div id=\"immediate_family_exposed_extra\"></div>\n            </div>\n        </div>\n        <div class=\"grid\">\n            <div>\n                <label for=\"none_above\">\n                    <input type=\"checkbox\" id=\"none_above\" name=\"none_above\" role=\"switch\"></label>\n            </div>\n            <div>\n                None of the above apply to me or my family.\n            </div>\n        </div>\n        <div class=\"input_error\" id=\"none_above_error\"></div>\n    </div>\n\n    <div class=\"grid buttons\">\n        <button type=\"button\" id=\"disclosures_prev\">Previous: Trusted contact</button>\n        <button type=\"button\" id=\"disclosures_next\">Next: Agreements</button>\n    </div>\n</fieldset>";

var KycAffiliateOrControlledHtml = "<fieldset id=\"affiliate_or_controlled\">\n    <div>You need to fill in the following information</div>\n    <div>\n        <label for=\"company_name\">Company name</label>\n        <input name=\"company_name\" required id=\"company_name\" autocomplete=\"organization\">\n    </div>\n    <div>\n        <label for=\"company_street_address\">Company street address</label>\n        <input name=\"company_street_address\" required id=\"company_street_address\">\n    </div>\n    <div>\n        <label for=\"company_city\">Company city</label>\n        <input name=\"company_city\" required id=\"company_city\">\n    </div>\n    <div>\n        <label for=\"company_state\">Company state</label>\n        <input name=\"company_state\" required id=\"company_state\">\n    </div>\n    <div>\n        <label for=\"company_country\">Company country</label>\n        <select required id=\"company_country\" required name=\"company_country\">\n            {{#each countries}}\n            <option value=\"{{code}}\">{{name}}</option>\n            {{/each}}\n        </select>\n    </div>\n    <div>\n        <label for=\"company_compliance_email\">Company compliance officer email</label>\n        <input name=\"company_compliance_email\" required id=\"company_compliance_email\">\n    </div>\n    <div>\n        <div class=\"explain\">\n            In accordance with applicable FINRA rules, user will need to obtain a letter written\n            and signed by a compliance officer on company letterhead explicitly granting permission for\n            the applicant to carry the account and explicitly stating whether or not the firm requires\n            access to duplicate account statements and/or trade confirmations.\n\n            If the firm would like online access your duplicate account statements and/or trade confirmations,\n            include in the letter the applicant's full name and the following information for the interested\n            party: First and last name, title, email address, telephone number.\n\n        </div>\n        {{{fileUpload \"account_approval_letter\" \"Account approval letter\"}}}\n\n    </div>\n</fieldset>\n";

class KycAffiliateOrControlled extends KycBase {
    constructor(kycForm) {
        super(kycForm);
    }
    render() {
        let kycAffiliateOrControlledTemplate = WidgetGlobals.HandlebarsInstance.compile(KycAffiliateOrControlledHtml);
        return kycAffiliateOrControlledTemplate({
            countries: CountryHelper.Countries,
        });
    }
    bindEvents() {
        this.bindFileUploads();
        let company_country = document.getElementById("company_country");
        company_country?.addEventListener("change", (evt) => {
            let select = evt.target;
            if (select.value === "USA") {
                this.setRequired("company_state");
            }
            else {
                this.removeRequired("company_state");
            }
        });
    }
    validate() {
        let company_name = document.getElementById("company_name");
        if (!company_name)
            return true;
        return this.validateRequiredFields("#affiliate_or_controlled");
    }
}

var KycImmediateFamilyHtml = "<fieldset id=\"immediate_family\">\n    <div>Since you chose that your immediate family member, you need to fill in the following information</div>\n    <div>\n        <label for=\"disclosure_given_name\">Given name of political person</label>\n        <input name=\"disclosure_given_name\" id=\"disclosure_given_name\">\n    </div>\n    <div>\n        <label for=\"disclosure_family_name\">Family name of political person</label>\n        <input name=\"disclosure_family_name\" id=\"disclosure_family_name\">\n    </div>\n</fieldset>";

class KycImmediateFamily extends KycBase {
    constructor(kycForm) {
        super(kycForm);
    }
    render() {
        let kycImmediateFamilyTemplate = WidgetGlobals.HandlebarsInstance.compile(KycImmediateFamilyHtml);
        return kycImmediateFamilyTemplate({});
    }
    bindEvents() { }
    validate() {
        let disclosure_given_name = document.getElementById("disclosure_given_name");
        if (!disclosure_given_name)
            return true;
        return this.validateRequiredFields("#immediate_family");
    }
}

class KycDisclosures extends KycBase {
    kycAffiliatedOrControlled;
    kycImmediateFamily;
    constructor(kycForm) {
        super(kycForm);
        this.kycAffiliatedOrControlled = new KycAffiliateOrControlled(this.kycForm);
        this.kycImmediateFamily = new KycImmediateFamily(this.kycForm);
    }
    render(edit = false) {
        let template = WidgetGlobals.HandlebarsInstance.compile(KycDisclosureHtml);
        return template({ edit: edit });
    }
    show() {
        if (this.kycForm.steps == 5) {
            document.getElementById("disclosures_next").innerText =
                "Next: Agreements";
        }
        else {
            document.getElementById("disclosures_next").innerText =
                "Next: Upload documents";
        }
        this.showFieldset(".kycDisclosures", "Disclosures");
    }
    bindEvents() {
        let is_affiliated_exchange_or_finra = document.getElementById("is_affiliated_exchange_or_finra");
        is_affiliated_exchange_or_finra?.addEventListener("click", (evt) => {
            this.loadAffiliatedOrControlComponent("is_affiliated_exchange_or_finra");
        });
        let is_control_person = document.getElementById("is_control_person");
        is_control_person?.addEventListener("click", (evt) => {
            this.loadAffiliatedOrControlComponent("is_control_person");
        });
        let immediate_family_exposed = document.getElementById("immediate_family_exposed");
        immediate_family_exposed?.addEventListener("click", (evt) => {
            this.loadPep("immediate_family_exposed");
        });
        let is_politically_exposed = document.getElementById("is_politically_exposed");
        is_politically_exposed?.addEventListener("click", (evt) => {
            this.uncheck("immediate_family_exposed");
        });
        let none_above = document.getElementById("none_above");
        none_above?.addEventListener("click", (evt) => {
            this.removeMissingInfo("none_above_error");
            none_above.removeAttribute("aria-invalid");
        });
        let prev = document.getElementById("disclosures_prev");
        prev?.addEventListener("click", (evt) => {
            this.kycForm.kycTrustedContact.show();
        });
        let next = document.getElementById("disclosures_next");
        next?.addEventListener("click", (evt) => {
            if (!this.validateFields())
                return;
            if (this.kycForm.steps == 5) {
                this.kycForm.kycAccountAgreement.show();
            }
            else {
                this.kycForm.kycUpload.show();
            }
        });
    }
    loadAffiliatedOrControlComponent(elementId) {
        if (elementId == "is_affiliated_exchange_or_finra") {
            this.uncheck("is_control_person");
        }
        else {
            this.uncheck("is_affiliated_exchange_or_finra");
        }
        let element = document.getElementById(elementId);
        let extra = document.getElementById(elementId + "_extra");
        if (!extra)
            return;
        if (element.checked) {
            extra.innerHTML = this.kycAffiliatedOrControlled.render();
            this.kycAffiliatedOrControlled.bindEvents();
        }
        else {
            extra.innerHTML = "";
        }
    }
    loadPep(elementId) {
        if (elementId == "immediate_family_exposed") {
            this.uncheck("is_politically_exposed");
        }
        else {
            this.uncheck("immediate_family_exposed");
        }
        let element = document.getElementById(elementId);
        let extra = document.getElementById(elementId + "_extra");
        if (!extra)
            return;
        if (element.checked) {
            extra.innerHTML = this.kycImmediateFamily.render();
            this.kycImmediateFamily.bindEvents();
        }
        else {
            extra.innerHTML = "";
        }
    }
    uncheck(elementId) {
        let element = document.getElementById(elementId);
        element.checked = false;
        let extra = document.getElementById(elementId + "_extra");
        extra.innerHTML = "";
    }
    validateFields() {
        if (!this.validateRequiredFields(".kycDisclosures"))
            return false;
        if (!this.kycImmediateFamily.validate())
            return false;
        if (!this.kycAffiliatedOrControlled.validate())
            return false;
        let is_affiliated_exchange_or_finra = document.getElementById("is_affiliated_exchange_or_finra");
        let is_control_person = document.getElementById("is_control_person");
        let is_politically_exposed = document.getElementById("is_politically_exposed");
        let immediate_family_exposed = document.getElementById("immediate_family_exposed");
        let none_above = document.getElementById("none_above");
        if (!none_above.checked &&
            !is_affiliated_exchange_or_finra.checked &&
            !is_control_person.checked &&
            !is_politically_exposed.checked &&
            !immediate_family_exposed.checked) {
            this.setMissingInfo("none_above_error", 'You must select, "None of the above apply to me or my family." if nothing is selected', "none_above");
            return false;
        }
        if (none_above.checked &&
            (is_affiliated_exchange_or_finra.checked ||
                is_control_person.checked ||
                is_politically_exposed.checked ||
                immediate_family_exposed.checked)) {
            this.setMissingInfo("none_above_error", 'You cannot have "None of the above apply to me or my family." selected and other options selected. Please select only one', "none_above");
            return false;
        }
        return true;
    }
}

var KycAccountAgreementHtml = "<fieldset class=\"kycAccountAgreement hidden\" data-form=\"1\">\n    <div class=\"kycAccountAgreementGrid\">\n        <div id=\"account_agreement_error\" class=\"input_error\"></div>\n        <div class=\"grid\">\n            <div>\n                <label for=\"account_agreement\">\n                    <input required type=\"checkbox\" name=\"account_agreement\" id=\"account_agreement\" value=\"1\">\n                </label>\n            </div>\n            <div>\n                <label for=\"account_agreement\">\n                    I agree to <a href=\"https://files.alpaca.markets/disclosures/library/AcctAppMarginAndCustAgmt.pdf\" target=\"_blank\">Alpaca Customer Agreement</a>\n                </label>\n            </div>\n        </div>\n        <div id=\"customer_agreement_error\" class=\"input_error\"></div>\n        <div class=\"grid\">\n            <div>\n                <label for=\"customer_agreement\">\n                    <input required type=\"checkbox\" name=\"customer_agreement\" id=\"customer_agreement\" value=\"1\">\n                </label>\n            </div>\n            <div>\n                <label for=\"customer_agreement\">\n                    Customer Agreement Acknowledgement</label>\n                <div class=\"explain\">\n                    I have read, understood, and agree to be bound by Alpaca Securities LLC and Liminal.market Inc.\n                    account\n                    terms,\n                    and all other terms, disclosures and disclaimers applicable to me, as referenced in the Alpaca\n                    Customer\n                    Agreement.\n                    I also acknowledge that the Alpaca Customer Agreement contains a pre-dispute arbitration clause\n                    in\n                    Section\n                    43.\n                </div>\n\n            </div>\n\n        </div>\n        <div id=\"digital_signature_error\" class=\"input_error\"></div>\n        <div class=\"grid\">\n            <div>\n                <label for=\"digital_signature\">\n                    <input required type=\"checkbox\" name=\"digital_signature\" id=\"digital_signature\" value=\"1\">\n                </label>\n            </div>\n            <div>\n                <label for=\"digital_signature\">\n                    Digital Signature Acknowledgement</label>\n                <div class=\"explain\">\n                    I understand I am signing this agreement electronically,\n                    and that my electronic signature will have the same effect as physically signing and returning\n                    the\n                    Application Agreement.\n                </div>\n\n            </div>\n        </div>\n        <div class=\"grid hidden\" id=\"w8disclosure_div\">\n            <div>\n                <label for=\"w8disclosure\">\n                    <input required type=\"checkbox\" name=\"w8disclosure\" id=\"w8disclosure\" value=\"1\">\n                </label>\n            </div>\n            <div><label for=\"w8disclosure\">\n                I certify that I am not a US citizen, US resident alien or other US person for US tax purposes,\n                and I am submitting the applicable Form W-8 BEN with this form to certify my foreign status and,\n                if applicable, claim tax treaty benefits. </label>\n            </div>\n        </div>\n    </div>\n    <div class=\"grid buttons\">\n        <button type=\"button\" id=\"account_agreement_prev\">Previous: Upload documents</button>\n        <button type=\"submit\" id=\"submitKYC\">Confirm identity</button>\n    </div>\n    <div class=\"alert alert-danger\" id=\"kycError\" role=\"alert\"></div>\n</fieldset>\n";

class KycAccountAgreement extends KycBase {
    constructor(kycForm) {
        super(kycForm);
    }
    render(edit = false) {
        let template = WidgetGlobals.HandlebarsInstance.compile(KycAccountAgreementHtml);
        return template({ edit: edit });
    }
    show() {
        this.showFieldset(".kycAccountAgreement", "Agreements");
        if (this.kycForm.steps == 5) {
            document.getElementById("account_agreement_prev").innerText =
                "Previous: Disclosure";
        }
        else {
            document.getElementById("account_agreement_prev").innerText =
                "Previous: Upload documents";
        }
        if (this.kycForm.kycContact.usTaxResidence) {
            document.getElementById("w8disclosure_div")?.classList.add("hidden");
        }
        else {
            document.getElementById("w8disclosure_div")?.classList.remove("hidden");
        }
    }
    bindEvents() {
        let account_agreement_prev = document.getElementById("account_agreement_prev");
        account_agreement_prev?.addEventListener("click", (evt) => {
            if (this.kycForm.steps == 5) {
                this.kycForm.kycDisclosures.show();
            }
            else {
                this.kycForm.kycUpload.show();
            }
        });
        this.bindSubmitKyc();
    }
    bindSubmitKyc(edit = false) {
        let submitKYC = document.getElementById("submitKYC");
        if (!submitKYC)
            return;
        submitKYC.addEventListener("click", async (evt) => {
            evt.preventDefault();
            if (!edit && !this.validate())
                return;
            let account_agreement_prev = document.getElementById("account_agreement_prev");
            //if (account_agreement_prev) account_agreement_prev.classList.add('hidden');
            document.getElementById("liminal_market_modal_close");
            // if (liminal_market_modal_close) liminal_market_modal_close.style.display = 'none';
            let submitBtn = evt.target;
            LoadingHelper.setLoading(submitBtn);
            let params = FormHelper.getParams("#kyc_wizard_form");
            let networkInfo = WidgetGlobals.Network;
            params.chainId = networkInfo.ChainId;
            let kycService = new KYCService();
            let result = await kycService.saveKYCInfo(params).catch((reason) => {
                if (account_agreement_prev)
                    account_agreement_prev.classList.remove("hidden");
                LoadingHelper.removeLoading();
                if (reason.message) {
                    let kycError = new KycValidatorError(JSON.parse(reason.message), this.kycForm);
                    kycError.handle();
                }
                else {
                    console.log(reason);
                }
            });
            if (result) {
                let ausdFund = new FakeAUSDFund();
                ausdFund.showAUSDFakeFund();
                ExecuteOrderButton.Instance.renderButton();
            }
            else {
                if (account_agreement_prev)
                    account_agreement_prev.classList.remove("hidden");
                LoadingHelper.removeLoading();
            }
        });
    }
    validate() {
        let account_agreement = document.getElementById("account_agreement");
        if (!account_agreement?.checked) {
            this.setMissingInfo("account_agreement_error", "You need to agree to agreements", "account_agreement");
            return false;
        }
        else {
            this.removeMissingInfo("account_agreement_error", "account_agreement");
        }
        let customer_agreement = document.getElementById("customer_agreement");
        if (!customer_agreement?.checked) {
            this.setMissingInfo("customer_agreement_error", "You need to agree to customer agrement", "customer_agreement");
            return false;
        }
        else {
            this.removeMissingInfo("customer_agreement_error", "customer_agreement");
        }
        let digital_signature = document.getElementById("digital_signature");
        if (!digital_signature?.checked) {
            this.setMissingInfo("digital_signature_error", "You need to sign", "digital_signature");
            return false;
        }
        else {
            this.removeMissingInfo("digital_signature_error", "digital_signature");
        }
        return true;
    }
}

var KycTrustedContactHtml = "<fieldset class=\"kycTrustedContact hidden\" data-form=\"1\">\n    <div class=\"explain\">\n        A trusted contact is a person you authorize your financial firm to contact in limited circumstances,\n        such as if there is a concern about activity in your account and they have been unable to get in touch with you.\n        <br><br>\n        A trusted contact may be a family member, attorney, accountant or another third-party who you believe would\n        respect your privacy and know how to handle the responsibility.\n        The trusted person should be 18 years old or older.\n    </div>\n    <div>\n        <label for=\"trusted_first_name\">Legal first name of trusted contact</label>\n        <input id=\"trusted_first_name\" name=\"trusted_first_name\">\n    </div>\n    <div>\n        <label for=\"trusted_last_name\">Legal last name of trusted contact</label>\n        <input id=\"trusted_last_name\" name=\"trusted_last_name\">\n    </div>\n    <div>\n        If you fill in name, you are required to fill in one of the following, email, phone or address\n    </div>\n    <div class=\"input_error\" id=\"trusted_contact_missing_info\"></div>\n    <div>\n        <label for=\"trusted_email\">Email of trusted contact</label>\n        <input id=\"trusted_email\" type=\"email\" name=\"trusted_email\">\n    </div>\n    <div>\n        <label for=\"trusted_phone\">Phone of trusted contact</label>\n        <input id=\"trusted_phone\" type=\"tel\" name=\"trusted_phone\">\n    </div>\n    <div>\n        <label for=\"trusted_street_address\">Address of trusted contact</label>\n        <input id=\"trusted_street_address\" name=\"trusted_street_address\">\n    </div>\n    <div>\n        <label for=\"trusted_city\">City of trusted contact</label>\n        <input id=\"trusted_city\" name=\"trusted_city\">\n    </div>\n    <div>\n        <label for=\"trusted_state\">State of trusted contact</label>\n        <input id=\"trusted_state\" name=\"trusted_state\">\n    </div>\n    <div>\n        <label for=\"trusted_postal_code\">Postal code of trusted contact</label>\n        <input id=\"trusted_postal_code\" name=\"trusted_postal_code\">\n    </div>\n    <div>\n        <label for=\"trusted_country\">Country of trusted contact</label>\n        <select required id=\"trusted_country\" required name=\"trusted_country\">\n            <option value=\"\"></option>\n            {{#each countries}}\n            <option value=\"{{code}}\">{{name}}</option>\n            {{/each}}\n        </select>\n    </div>\n    {{#unless edit}}\n    <div class=\"grid buttons\">\n        <button type=\"button\" id=\"trustedContact_prev\">Previous: Identity</button>\n        <button type=\"button\" id=\"trustedContact_next\">Next: Disclosures</button>\n    </div>\n    {{/unless}}\n    {{#if edit}}\n    <div class=\"grid buttons\">\n        <button type=\"button\" id=\"trustedContact_prev\">Previous: Identity</button>\n        <button type=\"submit\" id=\"submitKYC\">Update account</button>\n    </div>\n    <div class=\"alert alert-danger\" id=\"kycError\" role=\"alert\"></div>\n    {{/if}}\n</fieldset>";

class KycTrustedContact extends KycBase {
    edit = false;
    constructor(kycForm) {
        super(kycForm);
    }
    render(edit = false) {
        this.edit = edit;
        let template = WidgetGlobals.HandlebarsInstance.compile(KycTrustedContactHtml);
        return template({ edit: edit, countries: CountryHelper.Countries });
    }
    show() {
        this.showFieldset(".kycTrustedContact", "Trusted contact");
    }
    bindEvents() {
        let showPrev = document.getElementById("trustedContact_prev");
        showPrev?.addEventListener("click", (evt) => {
            this.kycForm.kycIdentity.show();
        });
        let showNext = document.getElementById("trustedContact_next");
        showNext?.addEventListener("click", (evt) => {
            if (!this.validate())
                return;
            this.kycForm.kycDisclosures.show();
        });
        if (this.edit) {
            let kycAccount = new KycAccountAgreement(this.kycForm);
            if (!this.validate())
                return;
            kycAccount.bindSubmitKyc(this.edit);
        }
    }
    validate() {
        this.setMissingInfo("trusted_contact_missing_info", "");
        let trusted_first_name = document.getElementById("trusted_first_name");
        if (trusted_first_name &&
            !StringHelper.isNullOrEmpty(trusted_first_name.value)) {
            let trusted_email = document.getElementById("trusted_email");
            let trusted_phone = document.getElementById("trusted_phone");
            let trusted_street_address = document.getElementById("trusted_street_address");
            let trusted_city = document.getElementById("trusted_city");
            let trusted_postal_code = document.getElementById("trusted_postal_code");
            let trusted_country = document.getElementById("trusted_country");
            if (StringHelper.isNullOrEmpty(trusted_email.value) &&
                StringHelper.isNullOrEmpty(trusted_phone.value) &&
                StringHelper.isNullOrEmpty(trusted_street_address.value)) {
                this.setMissingInfo("trusted_contact_missing_info", "You need to fill in either email, phone or address");
                return;
            }
            if (!StringHelper.isNullOrEmpty(trusted_email.value) &&
                trusted_email.value.indexOf("@") == -1) {
                this.setMissingInfo("trusted_contact_missing_info", "Email is not valid. It must contain @ sign");
                return;
            }
            if (!StringHelper.isNullOrEmpty(trusted_street_address.value) &&
                (StringHelper.isNullOrEmpty(trusted_city.value) ||
                    StringHelper.isNullOrEmpty(trusted_postal_code.value) ||
                    StringHelper.isNullOrEmpty(trusted_country.value))) {
                this.setMissingInfo("trusted_contact_missing_info", "You need fill inn into City, Postal code and Country when filling the street address");
                return;
            }
        }
        return true;
    }
}

var KycUploadHtml = "<fieldset class=\"kycUpload hidden\" data-form=\"1\">\n    <div class=\"grid\">\n        {{{fileUpload \"identity_verification\" \"Photo ID Front (Front of passport)\"}}}\n    </div>\n\n    <div class=\"grid\">\n        {{{fileUpload \"identity_verification_2\" \"Photo ID Back (Passport picture of ID) \"}}}\n    </div>\n    <div class=\"grid\">\n        {{{fileUpload \"address_verification\" \"Picture of address verification\"}}}\n    </div>\n\n    <div class=\"grid buttons\">\n        <button type=\"button\" id=\"upload_prev\">Previous: Disclosures</button>\n        <button type=\"button\" id=\"upload_next\">Next: Agreements</button>\n    </div>\n</fieldset>";

class KycUpload extends KycBase {
    constructor(kycForm) {
        super(kycForm);
    }
    render() {
        let template = WidgetGlobals.HandlebarsInstance.compile(KycUploadHtml);
        return template({});
    }
    show() {
        this.showFieldset(".kycUpload", "Upload documents");
    }
    bindEvents() {
        this.bindFileUploads();
        let upload_prev = document.getElementById("upload_prev");
        upload_prev?.addEventListener("click", (evt) => {
            this.kycForm.kycDisclosures.show();
        });
        let upload_next = document.getElementById("upload_next");
        upload_next?.addEventListener("click", (evt) => {
            if (!this.validateRequiredFields(".kycUpload"))
                return;
            this.kycForm.kycAccountAgreement.show();
        });
    }
}

var RegistrationHtml = "<fieldset class=\"sandbox_registration\" data-form=\"1\">\n    <p>\n        Register test trading account and receive $50 on you aUSD token to play with.<br>\n        <small>You can always request more funding later with click of a button</small>\n    </p>\n    <div>\n        <label for=\"given_name\">Legal First name</label>\n        <input required id=\"given_name\" name=\"given_name\" placeholder=\"Ron\" value=\"\" autocomplete=\"given-name\">\n    </div>\n    <div>\n        <label for=\"family_name\">Legal Last name</label>\n        <input required id=\"family_name\" name=\"family_name\" placeholder=\"Swanson\" value=\"\" autocomplete=\"family-name\">\n    </div>\n    <div>\n        <label for=\"email_address\">Email</label>\n        <input type=\"email\" required class=\"form-control\" id=\"email_address\" name=\"email_address\" placeholder=\"name@example.com\" autocomplete=\"email\" value=\"\">\n    </div>\n    <div class=\"input_error\" id=\"sandbox_reg_error\"></div>\n    <div class=\"buttons\">\n        <button type=\"button\" id=\"register_and_fund\">Register and fund account</button>\n    </div>\n</fieldset>";

var WaitingHtml = "<div class=\"center\" id=\"sandbox_registration_waiting\">\n    We are registering your account at the broker and funding your account.\n    <br><br>\n    This will take couple of minutes.\n\n    <ol class=\"waiting_list\">\n        <li>We will update you here when it's done.</li>\n        <li>While you wait, <a href=\"#\" id=\"addTokenToWallet\">add aUSD to your wallet</a>\n            <blockquote id=\"needToCopy\" class=\"d-none\">\n                If the button didn't work, you can copy the address here and import it into your wallet\n                <input value=\"{{aUSDAddress}}\">\n            </blockquote>\n        </li>\n        <li aria-busy=\"true\" id=\"li_sandbox_account_status\">Account status: <span id=\"sandbox_account_status\">Being created</span>\n        </li>\n        <li id=\"li_sandbox_funding_status\">Funding status: <span id=\"sandbox_funding_status\">Not funded</span></li>\n    </ol>\n</div>\n";

class Waiting {
    modal;
    constructor() {
        this.modal = new Modal();
    }
    show() {
        let contractInfo = ContractInfo.getContractInfo();
        let template = WidgetGlobals.HandlebarsInstance.compile(WaitingHtml);
        this.modal.showModal("Sandbox registration - waiting", template({ aUSDAddress: contractInfo.AUSD_ADDRESS }), false, undefined, false);
        let addToWallet = document.getElementById("addTokenToWallet");
        addToWallet?.addEventListener("click", async (evt) => {
            let walletHelper = new WalletHelper();
            let result = await walletHelper.addTokenToWallet(contractInfo.AUSD_ADDRESS, "aUSD", () => {
                this.showCopyField();
            });
            if (!result)
                this.showCopyField();
        });
    }
    showCopyField() {
        let needToCopy = document.getElementById("needToCopy");
        if (!needToCopy)
            return;
        needToCopy.classList.remove("d-none");
    }
}

class Registration {
    modal;
    constructor() {
        this.modal = new Modal();
    }
    show() {
        if (WidgetGlobals.User.alpacaId) {
            let waiting = new Waiting();
            waiting.show();
            return;
        }
        let template = WidgetGlobals.HandlebarsInstance.compile(RegistrationHtml);
        this.modal.showModal("Sandbox registration", template({}));
        this.bindEvents();
    }
    bindEvents() {
        let register_and_fund = document.getElementById("register_and_fund");
        register_and_fund?.addEventListener("click", async () => {
            this.hideError();
            LoadingHelper.setLoading(register_and_fund);
            let formValidator = new FormValidator("#sandbox_registration");
            if (!formValidator.validateRequiredFields()) {
                LoadingHelper.removeLoading();
                return;
            }
            let firstName = document.querySelector("#given_name");
            let lastName = document.querySelector("#family_name");
            let email = document.querySelector("#email_address");
            const alpacaId = await WidgetGlobals.LiminalMarket.createSandboxAccount(firstName.value, lastName.value, email.value).catch((reason) => {
                let error = JSON.parse(reason.message);
                if (error.serverError) {
                    this.showError(error.serverError);
                }
                else {
                    this.showError(error);
                }
                LoadingHelper.removeLoading();
            });
            if (alpacaId) {
                WidgetGlobals.User.alpacaId = alpacaId;
                let waiting = new Waiting();
                waiting.show();
            }
        });
    }
    hideError() {
        let sandbox_reg_error = document.getElementById("sandbox_reg_error");
        if (sandbox_reg_error)
            sandbox_reg_error.style.display = "none";
    }
    showError(message) {
        let sandbox_reg_error = document.getElementById("sandbox_reg_error");
        if (!sandbox_reg_error) {
            alert(message);
            return;
        }
        sandbox_reg_error.style.display = "block";
        sandbox_reg_error.innerHTML = message;
    }
}

class KYCForm {
    steps = 5;
    modal;
    timeout = undefined;
    onHide;
    activeFieldsetSelector = ".kycContact";
    kycContact;
    kycIdentity;
    kycDisclosures;
    kycTrustedContact;
    kycUpload;
    kycAccountAgreement;
    constructor(onHide) {
        this.modal = new Modal();
        this.onHide = onHide;
        this.kycContact = new KycContact(this);
        this.kycIdentity = new KycIdentity(this);
        this.kycTrustedContact = new KycTrustedContact(this);
        this.kycDisclosures = new KycDisclosures(this);
        this.kycUpload = new KycUpload(this);
        this.kycAccountAgreement = new KycAccountAgreement(this);
    }
    show(className) {
        if (WidgetGlobals.Network.TestNetwork) {
            let registration = new Registration();
            registration.show();
            return;
        }
        new KYCForm(() => { });
        const ble = className;
        this[ble].show();
        this.activeFieldsetSelector = className;
    }
    showKYCForm(edit = false) {
        if (WidgetGlobals.Network.TestNetwork) {
            let registration = new Registration();
            registration.show();
            return;
        }
        let template = WidgetGlobals.HandlebarsInstance.compile(KYCFormHtml);
        let obj = {
            KycContactHtml: this.kycContact.render(),
            KycIdentityHtml: this.kycIdentity.render(),
            KycDisclosureHtml: this.kycDisclosures.render(),
            KycTrustedContactHtml: this.kycTrustedContact.render(),
            KycAccountAgreementHtml: this.kycAccountAgreement.render(),
            KycUploadHtml: this.kycUpload.render(),
        };
        let content = template(obj);
        let newModal = this.modal.showModal("KYC & AML", content, true, () => {
            this.clearTimeout();
            this.onHide();
        }, false);
        let taxResidence = document.getElementById("country_of_tax_residence");
        if (taxResidence) {
            this.steps = taxResidence.value == "USA" ? 5 : 6;
        }
        if (newModal) {
            this.kycContact.bindEvents();
            this.kycIdentity.bindEvents();
            this.kycTrustedContact.bindEvents();
            this.kycDisclosures.bindEvents();
            this.kycUpload.bindEvents();
            this.kycAccountAgreement.bindEvents();
            document
                .getElementById("kyc_wizard_form")
                .addEventListener("keyup", (evt) => {
                if (evt.key == "Enter") {
                    evt.preventDefault();
                    evt.stopPropagation();
                }
            });
        }
        this.kycContact.show();
    }
    setSteps(steps) {
        this.steps = steps;
    }
    clearTimeout() {
        if (this.timeout)
            clearTimeout(this.timeout);
    }
}

class KycStatusHandler {
    kycResponse;
    executeTradeButton;
    constructor(kycResponse, executeTradeButton) {
        this.kycResponse = kycResponse;
        this.executeTradeButton = executeTradeButton;
    }
    getButtonText() {
        let txt = "Finish registration";
        switch (this.kycResponse.status) {
            case "SUBMITTED":
            case "ONBOARDING":
            case "INACTIVE":
            case "APPROVED":
            case "EDITED":
            case "APPROVAL_PENDING":
                txt = "Submitted to KYC processor";
                break;
            case "ACTION_REQUIRED":
                txt = "Action required. Click to continue";
                break;
            case "REJECTED":
                txt = "Your application was rejected";
                break;
            case "DISABLED":
                txt = "Your account has been disabled";
                break;
            case "ACTIVE":
            case "ACCOUNT_UPDATED":
                txt =
                    "You are approved. KYC is being sent to blockchain. Give it few minutes";
                break;
            case "ACCOUNT_CLOSED":
                txt = "Your account has been closed";
                break;
        }
        return txt + "<small>Click for more info</small>";
    }
    getButtonClickEvent(executeTradeButton) {
        switch (this.kycResponse.status) {
            case "SUBMITTED":
            case "ONBOARDING":
            case "INACTIVE":
            case "APPROVED":
            case "EDITED":
            case "APPROVAL_PENDING":
                return this.showModal("Application is being processed", "You need to wait for KYC to be approved. Then you'll be able to do trades. " +
                    "This usually takes few minutes for the first submission, but can take longer for second submission. " +
                    "We will email you when you are approved or if there are problems<br /><br />" +
                    "If this status has been for more than 1 day, and you haven't gotten any email from us. Please email us at " +
                    "<a target='_blank' href='mailto:info@liminal.market?subject=My application is being processed for to long&body=Hi, can you help me to find out what the problem is, the KYC process has not changed for some time? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>");
            case "ACTION_REQUIRED":
                return async () => {
                    let kycActionRequired = new KycActionRequired(executeTradeButton);
                    await kycActionRequired.show();
                };
            case "REJECTED":
                return this.showModal("Application was rejected", "Your application has been rejected during KYC process.<br /><br />" +
                    "We don't have the information on why that happened, but you can email us at " +
                    "<a target='_blank' href='mailto:info@liminal.market?subject=My application was rejected&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>" +
                    " and we can find out, and we should be able to solve it together.");
            case "DISABLED":
                return this.showModal("Application was disabled", "Your account has been disabled.<br /><br />" +
                    "We don't have the information on why that happened, but you can email us at " +
                    "<a target='_blank' href='mailto:info@liminal.market?subject=My application was disabled&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>" +
                    " and we can find out, and we should be able to solve it together.");
            case "ACCOUNT_CLOSED":
                return this.showModal("Application was closed", "Your account has been closed.<br /><br />" +
                    "We don't have the information on why that happened, but you can email us at " +
                    "<a target='_blank' href='mailto:info@liminal.market?subject=My application was closed&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>" +
                    " and we can find out, and we should be able to solve it together.");
            case "ACCOUNT_UPDATED":
            case "ACTIVE":
                return this.showModal("Account soon ready", "Your account has been approved...<br /><br/>" +
                    "..but, after we approve your account, we write the information to the blockchain." +
                    " This usually takes just few(2-3) minutes.<br /><br/> If this is taking longer, " +
                    'please email us at <a target="_blank" href="mailto:info@liminal.market?subject=KYC is being written to blockchain&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market">info@liminal.market</a>');
        }
        return () => {
            let kycForm = new KYCForm(async () => {
                await this.executeTradeButton.renderButton();
            });
            kycForm.showKYCForm();
        };
    }
    showModal(title, content) {
        return () => {
            let modal = new Modal();
            modal.showModal(title, content);
        };
    }
}

var KycApprovedHtml = "<h2>You are account has been approved</h2>\n<p>We have approved your account. You can now fund your account and start to trade.\n\n    <button id=\"kycApprovedFund\">Fund account</button>\n</p>";

class KycApproved {
    show() {
        let template = WidgetGlobals.HandlebarsInstance.compile(KycApprovedHtml);
        let modal = new Modal();
        modal.showModal("Account approved", template({}));
        let fundAccount = document.getElementById("kycApprovedFund");
        fundAccount?.addEventListener("click", (evt) => {
            modal.hideModal();
            let ausdFund = new FakeAUSDFund();
            ausdFund.showAUSDFakeFund();
        });
        if (ExecuteOrderButton.Instance) {
            clearInterval(ExecuteOrderButton.Instance.kycIdDoneTimeout);
            ExecuteOrderButton.Instance.renderButton();
        }
    }
}

var OrderProgressHtml = "<div id=\"executing-order-progress\" class=\"hidden\">\n  <div id=\"progress-text\"></div>\n  <progress></progress>\n</div>\n";

class OrderProgress {
    template = undefined;
    progressNr = 0;
    static instance = new OrderProgress();
    constructor() {
        this.template = WidgetGlobals.HandlebarsInstance.compile(OrderProgressHtml);
    }
    static getInstance() {
        return this.instance;
    }
    render() {
        let dom = document.querySelector(".tradeSwitch");
        if (!dom)
            return;
        dom.outerHTML = this.renderToString();
    }
    renderToString() {
        return this.template();
    }
    clearProgressText() {
        let executingOrderProgress = document.getElementById("executing-order-progress");
        executingOrderProgress?.classList.add("hidden");
        this.progressNr = 0;
    }
    setProgressText(progressNr, text, hash, hideInSeconds) {
        console.log("thisNr", this.progressNr, "nr", progressNr, "text", text);
        if (progressNr < this.progressNr)
            return;
        let executingOrderProgress = document.getElementById("executing-order-progress");
        if (!executingOrderProgress)
            return;
        let progressText = document.getElementById("progress-text");
        if (!progressText)
            return;
        let networkInfo = WidgetGlobals.Network;
        progressText.innerHTML =
            text +
                '<br /><a href="' +
                networkInfo.BlockExplorer +
                "/tx/" +
                hash +
                '" target="_blank" style="font-size:10px">View</a>';
        executingOrderProgress.classList.remove("hidden");
        this.progressNr = progressNr;
        if (hideInSeconds) {
            setTimeout(() => {
                this.clearProgressText();
            }, hideInSeconds * 1000);
        }
    }
}

var TradeExecutedHtml = "<article class=\"trade_executed\">\n  <nav>\n    <ul>\n      <li>\n        <img src=\"https://app.liminal.market{{sellingLogo}}\"><br>\n        {{sellingSymbol}}<br>\n        {{sellingAmount}}\n      </li>\n    </ul>\n    <ul>\n      <li>----></li>\n    </ul>\n    <ul>\n      <li>\n        <img src=\"https://app.liminal.market{{buyingLogo}}\"><br>\n        {{buyingSymbol}}<br>\n        <abbr title=\"{{buyingQuantity}}\" data-tooltip=\"{{buyingQuantity}}\">{{buyingRoundQuantity}}</abbr>\n      </li>\n    </ul>\n  </nav>\n  <div>\n    Should be visible in your wallet on address {{shortEthAddress}}.\n    <br>\n    <a href=\"https://info.liminal.market/#/chain/{{chainId}}/{{ethAddress}}\" target=\"_blank\">View portfolio</a>\n    <br><br>\n    <small>You can view the\n      <a href=\"{{blockExplorerLink}}\" target=\"_blank\">transaction here</a></small>\n  </div>\n</article>\n";

// canvas-confetti v1.6.0 built on 2022-10-24T21:26:41.619Z
var module = {};

// source content
(function main(global, module, isWorker, workerSize) {
  var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);
  function noop() {}

  // create a promise if it exists, otherwise, just
  // call the function directly
  function promise(func) {
    var ModulePromise = module.exports.Promise;
    var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;
    if (typeof Prom === 'function') {
      return new Prom(func);
    }
    func(noop, noop);
    return null;
  }
  var raf = function () {
    var TIME = Math.floor(1000 / 60);
    var frame, cancel;
    var frames = {};
    var lastFrameTime = 0;
    if (typeof requestAnimationFrame === 'function' && typeof cancelAnimationFrame === 'function') {
      frame = function (cb) {
        var id = Math.random();
        frames[id] = requestAnimationFrame(function onFrame(time) {
          if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {
            lastFrameTime = time;
            delete frames[id];
            cb();
          } else {
            frames[id] = requestAnimationFrame(onFrame);
          }
        });
        return id;
      };
      cancel = function (id) {
        if (frames[id]) {
          cancelAnimationFrame(frames[id]);
        }
      };
    } else {
      frame = function (cb) {
        return setTimeout(cb, TIME);
      };
      cancel = function (timer) {
        return clearTimeout(timer);
      };
    }
    return {
      frame: frame,
      cancel: cancel
    };
  }();
  var getWorker = function () {
    var worker;
    var prom;
    var resolves = {};
    function decorate(worker) {
      function execute(options, callback) {
        worker.postMessage({
          options: options || {},
          callback: callback
        });
      }
      worker.init = function initWorker(canvas) {
        var offscreen = canvas.transferControlToOffscreen();
        worker.postMessage({
          canvas: offscreen
        }, [offscreen]);
      };
      worker.fire = function fireWorker(options, size, done) {
        if (prom) {
          execute(options, null);
          return prom;
        }
        var id = Math.random().toString(36).slice(2);
        prom = promise(function (resolve) {
          function workerDone(msg) {
            if (msg.data.callback !== id) {
              return;
            }
            delete resolves[id];
            worker.removeEventListener('message', workerDone);
            prom = null;
            done();
            resolve();
          }
          worker.addEventListener('message', workerDone);
          execute(options, id);
          resolves[id] = workerDone.bind(null, {
            data: {
              callback: id
            }
          });
        });
        return prom;
      };
      worker.reset = function resetWorker() {
        worker.postMessage({
          reset: true
        });
        for (var id in resolves) {
          resolves[id]();
          delete resolves[id];
        }
      };
    }
    return function () {
      if (worker) {
        return worker;
      }
      if (!isWorker && canUseWorker) {
        var code = ['var CONFETTI, SIZE = {}, module = {};', '(' + main.toString() + ')(this, module, true, SIZE);', 'onmessage = function(msg) {', '  if (msg.data.options) {', '    CONFETTI(msg.data.options).then(function () {', '      if (msg.data.callback) {', '        postMessage({ callback: msg.data.callback });', '      }', '    });', '  } else if (msg.data.reset) {', '    CONFETTI && CONFETTI.reset();', '  } else if (msg.data.resize) {', '    SIZE.width = msg.data.resize.width;', '    SIZE.height = msg.data.resize.height;', '  } else if (msg.data.canvas) {', '    SIZE.width = msg.data.canvas.width;', '    SIZE.height = msg.data.canvas.height;', '    CONFETTI = module.exports.create(msg.data.canvas);', '  }', '}'].join('\n');
        try {
          worker = new Worker(URL.createObjectURL(new Blob([code])));
        } catch (e) {
          // eslint-disable-next-line no-console
          typeof console !== undefined && typeof console.warn === 'function' ? console.warn('🎊 Could not load worker', e) : null;
          return null;
        }
        decorate(worker);
      }
      return worker;
    };
  }();
  var defaults = {
    particleCount: 50,
    angle: 90,
    spread: 45,
    startVelocity: 45,
    decay: 0.9,
    gravity: 1,
    drift: 0,
    ticks: 200,
    x: 0.5,
    y: 0.5,
    shapes: ['square', 'circle'],
    zIndex: 100,
    colors: ['#26ccff', '#a25afd', '#ff5e7e', '#88ff5a', '#fcff42', '#ffa62d', '#ff36ff'],
    // probably should be true, but back-compat
    disableForReducedMotion: false,
    scalar: 1
  };
  function convert(val, transform) {
    return transform ? transform(val) : val;
  }
  function isOk(val) {
    return !(val === null || val === undefined);
  }
  function prop(options, name, transform) {
    return convert(options && isOk(options[name]) ? options[name] : defaults[name], transform);
  }
  function onlyPositiveInt(number) {
    return number < 0 ? 0 : Math.floor(number);
  }
  function randomInt(min, max) {
    // [min, max)
    return Math.floor(Math.random() * (max - min)) + min;
  }
  function toDecimal(str) {
    return parseInt(str, 16);
  }
  function colorsToRgb(colors) {
    return colors.map(hexToRgb);
  }
  function hexToRgb(str) {
    var val = String(str).replace(/[^0-9a-f]/gi, '');
    if (val.length < 6) {
      val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];
    }
    return {
      r: toDecimal(val.substring(0, 2)),
      g: toDecimal(val.substring(2, 4)),
      b: toDecimal(val.substring(4, 6))
    };
  }
  function getOrigin(options) {
    var origin = prop(options, 'origin', Object);
    origin.x = prop(origin, 'x', Number);
    origin.y = prop(origin, 'y', Number);
    return origin;
  }
  function setCanvasWindowSize(canvas) {
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
  }
  function setCanvasRectSize(canvas) {
    var rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
  function getCanvas(zIndex) {
    var canvas = document.createElement('canvas');
    canvas.style.position = 'fixed';
    canvas.style.top = '0px';
    canvas.style.left = '0px';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = zIndex;
    return canvas;
  }
  function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
    context.save();
    context.translate(x, y);
    context.rotate(rotation);
    context.scale(radiusX, radiusY);
    context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
    context.restore();
  }
  function randomPhysics(opts) {
    var radAngle = opts.angle * (Math.PI / 180);
    var radSpread = opts.spread * (Math.PI / 180);
    return {
      x: opts.x,
      y: opts.y,
      wobble: Math.random() * 10,
      wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),
      velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,
      angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),
      tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,
      color: opts.color,
      shape: opts.shape,
      tick: 0,
      totalTicks: opts.ticks,
      decay: opts.decay,
      drift: opts.drift,
      random: Math.random() + 2,
      tiltSin: 0,
      tiltCos: 0,
      wobbleX: 0,
      wobbleY: 0,
      gravity: opts.gravity * 3,
      ovalScalar: 0.6,
      scalar: opts.scalar
    };
  }
  function updateFetti(context, fetti) {
    fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;
    fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;
    fetti.wobble += fetti.wobbleSpeed;
    fetti.velocity *= fetti.decay;
    fetti.tiltAngle += 0.1;
    fetti.tiltSin = Math.sin(fetti.tiltAngle);
    fetti.tiltCos = Math.cos(fetti.tiltAngle);
    fetti.random = Math.random() + 2;
    fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);
    fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);
    var progress = fetti.tick++ / fetti.totalTicks;
    var x1 = fetti.x + fetti.random * fetti.tiltCos;
    var y1 = fetti.y + fetti.random * fetti.tiltSin;
    var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;
    var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;
    context.fillStyle = 'rgba(' + fetti.color.r + ', ' + fetti.color.g + ', ' + fetti.color.b + ', ' + (1 - progress) + ')';
    context.beginPath();
    if (fetti.shape === 'circle') {
      context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);
    } else if (fetti.shape === 'star') {
      var rot = Math.PI / 2 * 3;
      var innerRadius = 4 * fetti.scalar;
      var outerRadius = 8 * fetti.scalar;
      var x = fetti.x;
      var y = fetti.y;
      var spikes = 5;
      var step = Math.PI / spikes;
      while (spikes--) {
        x = fetti.x + Math.cos(rot) * outerRadius;
        y = fetti.y + Math.sin(rot) * outerRadius;
        context.lineTo(x, y);
        rot += step;
        x = fetti.x + Math.cos(rot) * innerRadius;
        y = fetti.y + Math.sin(rot) * innerRadius;
        context.lineTo(x, y);
        rot += step;
      }
    } else {
      context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));
      context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));
      context.lineTo(Math.floor(x2), Math.floor(y2));
      context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));
    }
    context.closePath();
    context.fill();
    return fetti.tick < fetti.totalTicks;
  }
  function animate(canvas, fettis, resizer, size, done) {
    var animatingFettis = fettis.slice();
    var context = canvas.getContext('2d');
    var animationFrame;
    var destroy;
    var prom = promise(function (resolve) {
      function onDone() {
        animationFrame = destroy = null;
        context.clearRect(0, 0, size.width, size.height);
        done();
        resolve();
      }
      function update() {
        if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {
          size.width = canvas.width = workerSize.width;
          size.height = canvas.height = workerSize.height;
        }
        if (!size.width && !size.height) {
          resizer(canvas);
          size.width = canvas.width;
          size.height = canvas.height;
        }
        context.clearRect(0, 0, size.width, size.height);
        animatingFettis = animatingFettis.filter(function (fetti) {
          return updateFetti(context, fetti);
        });
        if (animatingFettis.length) {
          animationFrame = raf.frame(update);
        } else {
          onDone();
        }
      }
      animationFrame = raf.frame(update);
      destroy = onDone;
    });
    return {
      addFettis: function (fettis) {
        animatingFettis = animatingFettis.concat(fettis);
        return prom;
      },
      canvas: canvas,
      promise: prom,
      reset: function () {
        if (animationFrame) {
          raf.cancel(animationFrame);
        }
        if (destroy) {
          destroy();
        }
      }
    };
  }
  function confettiCannon(canvas, globalOpts) {
    var isLibCanvas = !canvas;
    var allowResize = !!prop(globalOpts || {}, 'resize');
    var globalDisableForReducedMotion = prop(globalOpts, 'disableForReducedMotion', Boolean);
    var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, 'useWorker');
    var worker = shouldUseWorker ? getWorker() : null;
    var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;
    var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;
    var preferLessMotion = typeof matchMedia === 'function' && matchMedia('(prefers-reduced-motion)').matches;
    var animationObj;
    function fireLocal(options, size, done) {
      var particleCount = prop(options, 'particleCount', onlyPositiveInt);
      var angle = prop(options, 'angle', Number);
      var spread = prop(options, 'spread', Number);
      var startVelocity = prop(options, 'startVelocity', Number);
      var decay = prop(options, 'decay', Number);
      var gravity = prop(options, 'gravity', Number);
      var drift = prop(options, 'drift', Number);
      var colors = prop(options, 'colors', colorsToRgb);
      var ticks = prop(options, 'ticks', Number);
      var shapes = prop(options, 'shapes');
      var scalar = prop(options, 'scalar');
      var origin = getOrigin(options);
      var temp = particleCount;
      var fettis = [];
      var startX = canvas.width * origin.x;
      var startY = canvas.height * origin.y;
      while (temp--) {
        fettis.push(randomPhysics({
          x: startX,
          y: startY,
          angle: angle,
          spread: spread,
          startVelocity: startVelocity,
          color: colors[temp % colors.length],
          shape: shapes[randomInt(0, shapes.length)],
          ticks: ticks,
          decay: decay,
          gravity: gravity,
          drift: drift,
          scalar: scalar
        }));
      }

      // if we have a previous canvas already animating,
      // add to it
      if (animationObj) {
        return animationObj.addFettis(fettis);
      }
      animationObj = animate(canvas, fettis, resizer, size, done);
      return animationObj.promise;
    }
    function fire(options) {
      var disableForReducedMotion = globalDisableForReducedMotion || prop(options, 'disableForReducedMotion', Boolean);
      var zIndex = prop(options, 'zIndex', Number);
      if (disableForReducedMotion && preferLessMotion) {
        return promise(function (resolve) {
          resolve();
        });
      }
      if (isLibCanvas && animationObj) {
        // use existing canvas from in-progress animation
        canvas = animationObj.canvas;
      } else if (isLibCanvas && !canvas) {
        // create and initialize a new canvas
        canvas = getCanvas(zIndex);
        document.body.appendChild(canvas);
      }
      if (allowResize && !initialized) {
        // initialize the size of a user-supplied canvas
        resizer(canvas);
      }
      var size = {
        width: canvas.width,
        height: canvas.height
      };
      if (worker && !initialized) {
        worker.init(canvas);
      }
      initialized = true;
      if (worker) {
        canvas.__confetti_initialized = true;
      }
      function onResize() {
        if (worker) {
          // TODO this really shouldn't be immediate, because it is expensive
          var obj = {
            getBoundingClientRect: function () {
              if (!isLibCanvas) {
                return canvas.getBoundingClientRect();
              }
            }
          };
          resizer(obj);
          worker.postMessage({
            resize: {
              width: obj.width,
              height: obj.height
            }
          });
          return;
        }

        // don't actually query the size here, since this
        // can execute frequently and rapidly
        size.width = size.height = null;
      }
      function done() {
        animationObj = null;
        if (allowResize) {
          global.removeEventListener('resize', onResize);
        }
        if (isLibCanvas && canvas) {
          document.body.removeChild(canvas);
          canvas = null;
          initialized = false;
        }
      }
      if (allowResize) {
        global.addEventListener('resize', onResize, false);
      }
      if (worker) {
        return worker.fire(options, size, done);
      }
      return fireLocal(options, size, done);
    }
    fire.reset = function () {
      if (worker) {
        worker.reset();
      }
      if (animationObj) {
        animationObj.reset();
      }
    };
    return fire;
  }

  // Make default export lazy to defer worker creation until called.
  var defaultFire;
  function getDefaultFire() {
    if (!defaultFire) {
      defaultFire = confettiCannon(null, {
        useWorker: true,
        resize: true
      });
    }
    return defaultFire;
  }
  module.exports = function () {
    return getDefaultFire().apply(this, arguments);
  };
  module.exports.reset = function () {
    getDefaultFire().reset();
  };
  module.exports.create = confettiCannon;
})(function () {
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof self !== 'undefined') {
    return self;
  }
  return this || {};
}(), module, false);
var create = module.exports.create;

class OrderExecutedModal {
    async show(object) {
        await AUsdBalance.forceLoadAUSDBalanceUI();
        OrderProgress.getInstance().clearProgressText();
        let providerInfo = ProviderInfo.Instance;
        let networkInfo = WidgetGlobals.Network;
        let isBuy = object.side == "buy";
        let obj = isBuy
            ? this.getBuyingSharesObj(object)
            : this.getSellSharesObj(object);
        obj.walletName = providerInfo?.WalletName ?? "";
        obj.blockExplorerLink =
            networkInfo.BlockExplorer + "/tx/" + object.transaction_hash;
        let template = WidgetGlobals.HandlebarsInstance.compile(TradeExecutedHtml);
        let content = template(obj);
        let modal = new Modal();
        modal.showModal("Trade executed", content);
        let myCanvas = document.createElement("canvas");
        myCanvas.id = "confetti";
        document.querySelector(".trade_executed").appendChild(myCanvas);
        let myConfetti = create(myCanvas, {
            resize: true,
            useWorker: true,
        });
        myConfetti({ particleCount: 200, spread: 200 });
        let addTokenToWallet = document.getElementById("addTokenToWallet");
        if (!addTokenToWallet)
            return;
        addTokenToWallet.addEventListener("click", (evt) => {
            let address = evt.target.dataset.address;
            let walletHelper = new WalletHelper();
            walletHelper.addTokenToWallet(address, obj.buyingSymbol, () => {
                let addTokenToWalletFailed = document.getElementById("addTokenToWalletFailed");
                if (!addTokenToWalletFailed)
                    return;
                addTokenToWalletFailed.classList.remove("d-none");
            });
        });
    }
    getBuyingSharesObj(object) {
        let ethAddress = object.walletAddress;
        let tokenAddress = object.tokenAddress;
        let buyingQuantity = object.filled_qty;
        let sellingAmount = "$" + object.amount;
        return {
            sellingLogo: "/img/logos/aUSD.png",
            sellingSymbol: "aUSD",
            sellingAmount: sellingAmount,
            buyingLogo: "/img/logos/" + object.symbol + ".png",
            buyingSymbol: object.symbol,
            buyingQuantity: buyingQuantity,
            buyingRoundQuantity: roundNumberDecimal(buyingQuantity, 6) + " shares",
            shortEthAddress: shortEth(ethAddress),
            ethAddress: ethAddress,
            tokenAddress: tokenAddress,
            chainId: WidgetGlobals.Network.ChainId,
        };
    }
    getSellSharesObj(object) {
        let ethAddress = object.sender;
        let tokenAddress = object.recipient;
        let buyingQuantity = BigNumber.from(object.filled_avg_price).mul(BigNumber.from(object.filled_qty));
        let sellingAmount = object.filled_qty;
        return {
            sellingLogo: "/img/logos/" + object.symbol + ".png",
            sellingSymbol: object.symbol,
            sellingAmount: sellingAmount + " shares",
            buyingLogo: "/img/logos/aUSD.png",
            buyingSymbol: "aUSD",
            buyingQuantity: utils.formatUnits(buyingQuantity),
            buyingRoundQuantity: "$" + utils.formatUnits(roundBigNumberDecimal(buyingQuantity, 6)),
            shortEthAddress: shortEth(ethAddress),
            ethAddress: ethAddress,
            tokenAddress: tokenAddress,
            chainId: WidgetGlobals.Network.ChainId,
        };
    }
}

var ListenerExports = requireListener();
var Listener = /*@__PURE__*/getDefaultExportFromCjs(ListenerExports);

class ExecuteOrderButton {
    authenticateService;
    sellTradeInput;
    buyTradeInput;
    template;
    button;
    static Instance;
    constructor(sellTradeInput, buyTradeInput) {
        this.sellTradeInput = sellTradeInput;
        this.buyTradeInput = buyTradeInput;
        this.authenticateService = new AuthenticateService();
        this.template = WidgetGlobals.HandlebarsInstance.compile(ExecuteOrderButtonHtml);
        ExecuteOrderButton.Instance = this;
        this.button = document.getElementById("liminal_market_execute_order");
    }
    renderToString() {
        return this.template(this);
    }
    async renderButton() {
        // if (this.button) {
        //   this.button.outerHTML = this.button.outerHTML;
        // }
        this.button = document.getElementById("liminal_market_execute_order");
        this.loadingButton(this.button);
        //wallet connected
        if (!(await this.walletIsConnected(this.button))) {
            return;
        }
        //user logged in
        if (!(await this.userIsLoggedIn(this.button))) {
            return;
        }
        //chain id correct
        if (!this.chainIdIsCorrect(this.button)) {
            return;
        }
        //native token is available
        if (!(await this.userHasNativeToken(this.button))) {
            return;
        }
        //kyc is done
        if (!(await this.kycIsDone(this.button))) {
            return;
        }
        //ausd is setup
        if (!(await this.userHasAUSD(this.button))) {
            return;
        }
        //ausd > buy amount
        if (!(await this.userHasEnoughQty(this.button))) {
            return;
        }
        if (!this.hasQuantityAndSymbol(this.button)) {
            return;
        }
        if (!(await this.isMarketOpen(this.button))) {
            return;
        }
        this.enableExecuteOrder(this.button);
    }
    enableExecuteOrder(button) {
        //if (this.sellTradeInput.quantity.eq(0)) return;
        //execute trade can be done
        button.innerHTML = "Execute trade";
        button.classList.replace("disabled", "enabled");
        this.stopLoadingButton(button);
        console.log("service contract", LiminalMarket.ServiceContractAddress);
        button.addEventListener("click", async () => {
            this.loadingButton(button);
            button.innerHTML = "Confirm transaction in your wallet";
            let symbol = this.buyTradeInput.symbol;
            let side = "buy";
            let qtyWei = this.sellTradeInput.quantity.toString();
            if (symbol == "aUSD") {
                side = "sell";
                symbol = this.sellTradeInput.symbol;
            }
            let liminalMarket = WidgetGlobals.LiminalMarket;
            Listener.onOrderExecuted = async (event) => {
                let orderExecutedModal = new OrderExecutedModal();
                orderExecutedModal.show(event);
                OrderProgress.getInstance().clearProgressText();
            };
            Listener.onOrderSentToMarket = async (event) => {
                OrderProgress.getInstance().setProgressText(0, "Sent to stock market");
            };
            Listener.onOrderExecutedWritingToChain = async (event) => {
                OrderProgress.getInstance().setProgressText(0, "Order executed writing to blockchain");
            };
            console.log("execute order", side, symbol, qtyWei.toString());
            await liminalMarket
                .executeOrder(side, symbol, qtyWei)
                .then((result) => {
                button.innerHTML = "Execute trade";
                OrderProgress.getInstance().setProgressText(0, "Sending order");
            })
                .catch((reason) => {
                OrderProgress.getInstance().setProgressText(100, reason.message, "", 10);
                button.innerHTML = "Execute trade";
                return;
            })
                .finally(() => {
                this.stopLoadingButton(button);
            });
        });
    }
    loadingButton(button) {
        button.setAttribute("aria-busy", "true");
    }
    stopLoadingButton(button) {
        button.removeAttribute("aria-busy");
    }
    async walletIsConnected(button) {
        let authenticationService = new AuthenticateService();
        await authenticationService.isAuthenticated();
        if (WidgetGlobals.User.provider)
            return true;
        button.innerHTML = "Connect wallet";
        button.addEventListener("click", async (evt) => {
            let connectWallet = new ConnectWallet();
            await connectWallet.connectWallet(evt.target);
        });
        this.stopLoadingButton(button);
        return false;
    }
    async userIsLoggedIn(button) {
        if (WidgetGlobals.User.isLoggedIn)
            return true;
        button.innerHTML = "Login";
        button.addEventListener("click", async () => {
            await this.authenticateService.authenticateUser();
        });
        this.stopLoadingButton(button);
        return false;
    }
    chainIdIsCorrect(button) {
        let chainId = WidgetGlobals.User.chainId;
        if (chainId === WidgetGlobals.Network.ChainId)
            return true;
        let usersWalletNetwork = NetworkInfo.getNetworkInfoByChainId(chainId);
        if (usersWalletNetwork) {
            NetworkInfo.setNetworkByChainId(chainId);
            return true;
        }
        button.innerHTML = "Switch Network";
        button.addEventListener("click", async () => {
            await WidgetGlobals.Network.addNetworkToWallet();
        });
        this.stopLoadingButton(button);
        return false;
    }
    async userHasNativeToken(button) {
        let networkInfo = WidgetGlobals.Network;
        let hasEnoughNativeTokens = await networkInfo.hasEnoughNativeTokens();
        if (hasEnoughNativeTokens)
            return true;
        button.classList.replace("enabled", "disabled");
        button.innerHTML =
            "You need " +
                networkInfo.NativeCurrencyName +
                " tokens. Click me for some tokens";
        button.addEventListener("click", () => {
            let nativeTokenNeededModal = new NativeTokenNeeded(() => {
                this.renderButton();
            });
            nativeTokenNeededModal.show();
        });
        this.stopLoadingButton(button);
        return false;
    }
    kycIdDoneTimeout;
    async kycIsDone(button) {
        let kycResponse = await WidgetGlobals.LiminalMarket.kycStatus();
        if (!kycResponse.isValidKyc) {
            let kycStatusHandler = new KycStatusHandler(kycResponse, this);
            button.innerHTML = kycStatusHandler.getButtonText();
            button.addEventListener("click", kycStatusHandler.getButtonClickEvent(this));
            if (kycResponse.status == "ACTIVE") {
                this.loadingButton(button);
                this.kycIdDoneTimeout = setInterval(async () => {
                    kycResponse = await WidgetGlobals.LiminalMarket.kycStatus();
                    if (kycResponse.isValidKyc) {
                        this.hasBuyingPower = kycResponse.hasBuyingPower;
                        if (!this.hasBuyingPower) {
                            let kycApproved = new KycApproved();
                            kycApproved.show();
                        }
                        clearInterval(this.kycIdDoneTimeout);
                        await this.renderButton();
                    }
                }, 30 * 1000);
            }
            else {
                this.stopLoadingButton(button);
            }
            return false;
        }
        this.stopLoadingButton(button);
        return true;
    }
    checkBalanceInterval;
    hasBuyingPower = false;
    async userHasAUSD(button) {
        let balance = await WidgetGlobals.LiminalMarket.getAUSDBalance(WidgetGlobals.User.address);
        if (balance.gt(0))
            return true;
        if (this.hasBuyingPower) {
            button.innerHTML = "We are funding your aUSD token";
            this.checkBalanceInterval = setInterval(async () => {
                let balance = await WidgetGlobals.LiminalMarket.getAUSDBalance(WidgetGlobals.User.address);
                if (balance.gt(0)) {
                    await AUsdBalance.forceLoadAUSDBalanceUI();
                    clearInterval(this.checkBalanceInterval);
                    await this.renderButton();
                }
            }, 10 * 1000);
            return false;
        }
        if (WidgetGlobals.Network.TestNetwork) {
            button.innerHTML = "You need aUSD. Click here to get some";
        }
        else {
            button.innerHTML = "You need aUSD. Click here for instructions";
        }
        button.addEventListener("click", () => {
            let ausdFund = new FakeAUSDFund();
            ausdFund.showAUSDFakeFund();
        });
        this.stopLoadingButton(button);
        return false;
    }
    async userHasEnoughQty(button) {
        if (this.sellTradeInput.symbol == "aUSD") {
            let balance = await WidgetGlobals.LiminalMarket.getAUSDBalance(WidgetGlobals.User.address);
            if (balance.gte(this.sellTradeInput.quantity))
                return true;
            button.innerHTML = "You don't have enough aUSD. Click for more funding";
            button.addEventListener("click", () => {
                let ausdFund = new FakeAUSDFund();
                ausdFund.showAUSDFakeFund();
            });
        }
        else {
            let userQuantity = await WidgetGlobals.LiminalMarket.getSecurityTokenQuantity(this.sellTradeInput.symbol, WidgetGlobals.User.address);
            if (this.sellTradeInput.quantity.lte(userQuantity))
                return true;
            button.innerHTML = "You don't have enough " + this.sellTradeInput.symbol;
            button.classList.replace("disable", "enable");
        }
        this.stopLoadingButton(button);
        return false;
    }
    async isMarketOpen(button) {
        let userService = new UserService();
        let isMarketOpen = await userService.isMarketOpenOrUserOffHours();
        if (isMarketOpen)
            return true;
        button.innerHTML = "Market is closed";
        button.classList.replace("enabled", "disabled");
        this.stopLoadingButton(button);
        return false;
    }
    hasQuantityAndSymbol(button) {
        if (this.sellTradeInput.quantity.eq(0)) {
            button.innerHTML = "Type in quantity";
            this.stopLoadingButton(button);
            return false;
        }
        if (this.buyTradeInput.name == "") {
            button.innerHTML = "Select stock to buy";
            this.stopLoadingButton(button);
            return false;
        }
        return true;
    }
}

class EventService {
    static register() {
        UserInfo.onUserLoggedIn.push(async () => {
            console.log("Doing EventService listening");
            // eventService.listen();
        });
    }
    listen() {
        let network = WidgetGlobals.Network;
        let eventSource = new EventSource(network.ServerUrl +
            "/listenForChanges?jwt=" +
            WidgetGlobals.LiminalMarket.account.token);
        eventSource.onmessage = async (e) => {
            let data = e.data;
            console.log(e);
            if (!data || data == "ok")
                return;
            let obj = isJSON(data);
            if (!obj) {
                console.log("data is not json:", data);
                return;
            }
            if (obj.methodName == "OrderExecuted") ;
            else if (obj.methodName == "SendingToExchange") {
                await OrderProgress.getInstance().setProgressText(1, "Received order, sending to stock exchange", obj.hash);
            }
            else if (obj.methodName == "OrderExecutedWritingBlockchain") {
                await OrderProgress.getInstance().setProgressText(1, "Order executed, writing to blockchain", "");
            }
            else if (obj.methodName == "UpdateAUsdOnChain") {
                FakeAUSDFund.writingToChain();
            }
            else if (obj.methodName == "BalanceSet") {
                if (WidgetGlobals.Network.TestNetwork) {
                    let sandbox_registration_waiting = document.getElementById("sandbox_registration_waiting");
                    if (sandbox_registration_waiting) {
                        let sandbox_funding_status = document.getElementById("sandbox_funding_status");
                        if (sandbox_funding_status)
                            sandbox_funding_status.innerHTML =
                                "Funding done 🎉 - Reloading page";
                        location.reload();
                        return;
                    }
                }
                let aUsdBalance = new AUsdBalance();
                let balance = formatEther(obj.balance);
                aUsdBalance.updateUIBalance(BigNumber.from(balance));
                ExecuteOrderButton.Instance?.renderButton();
            }
            else if (obj.methodName == "AccountValidated") {
                if (WidgetGlobals.Network.TestNetwork) {
                    let li_sandbox_account_status = document.getElementById("li_sandbox_account_status");
                    if (li_sandbox_account_status) {
                        li_sandbox_account_status.setAttribute("aria-busy", "false");
                        let sandbox_account_status = document.getElementById("sandbox_account_status");
                        if (sandbox_account_status)
                            sandbox_account_status.innerHTML = "Account created 🎉";
                        let li_sandbox_funding_status = document.getElementById("li_sandbox_funding_status");
                        if (li_sandbox_funding_status) {
                            li_sandbox_funding_status.setAttribute("aria-busy", "true");
                        }
                    }
                    clearInterval(ExecuteOrderButton.Instance.kycIdDoneTimeout);
                    ExecuteOrderButton.Instance.renderButton();
                    return;
                }
                let hasBuyingPower = obj.hasBuyingPower;
                if (!hasBuyingPower) {
                    let kycApproved = new KycApproved();
                    kycApproved.show();
                }
                else if (ExecuteOrderButton.Instance) {
                    ExecuteOrderButton.Instance.hasBuyingPower = obj.hasBuyingPower;
                    clearInterval(ExecuteOrderButton.Instance.kycIdDoneTimeout);
                    ExecuteOrderButton.Instance.renderButton();
                }
            }
        };
    }
}

var TradeType;
(function (TradeType) {
    TradeType["Sell"] = "Sell";
    TradeType["Buy"] = "Buy";
})(TradeType || (TradeType = {}));

var TradeInputHtml = "<article class=\"{{tradeType}}Inputs tradeInputArticle\">\n  <div class=\"grid tradeInput\">\n    <div class=\"select_token\">\n      <a id=\"{{tradeType}}SelectStock\" href=\"#\" role=\"button\">\n        {{#if logo}}\n        <img src=\"https://app.liminal.market{{logo}}\">\n        {{/if}} {{symbol}}\n      </a>\n    </div>\n    <div class=\"trade_input\">\n      <input autocomplete=\"off\" autocorrect=\"off\" type=\"tel\" spellcheck=\"false\" value=\"{{strQuantity}}\" placeholder=\"0.0\">\n    </div>\n    <div class=\"balance\">\n      Balance :\n      <abbr title=\"{{balance}}\" data-tooltip=\"{{balance}}\" class=\"balance_value\">{{abbrBalance}}</abbr>\n      <a href=\"\" class=\"balance_max\">Max</a>\n    </div>\n    <div class=\"price_per_share\"></div>\n  </div>\n  <progress class=\"progress d-none\" value=\"0\" max=\"1\"></progress>\n  <div class=\"exceeds_wallet_balance d-none\">Exceeds wallet balance</div>\n</article>\n";

var SecuritiesListHtml = "<figure>\n    <table id=\"liminal_market_securities_table\" role=\"grid\">\n    <thead>\n    <tr>\n        <th colspan=\"2\"><input autocomplete=\"off\" type=\"search\" id=\"search_for_symbol\" placeholder=\"Search for name or symbol in {{securitiesCount}} stocks\"></th>\n    </tr>\n    </thead>\n    <tbody id=\"{{tbodyId}}\">\n    {{>securities}}\n    </tbody>\n</table>\n<span id=\"liminal_market_load_more\"></span>\n</figure>";

var SecurityHtml = "{{#each securities}}\n<tr data-symbol=\"{{{Symbol}}}\" data-logo=\"{{LogoPath}}{{Logo}}\" data-name=\"{{Name}}\">\n  <td class=\"symbol_logo\">\n    <img src=\"https://app.liminal.market{{LogoPath}}{{Logo}}\">\n  </td>\n  <td class=\"security_information\">\n    <strong>{{Name}}</strong><br>\n    <nav class=\"security_extra\">\n      <ul>\n        <li>\n          <a href=\"https://strike.market/stocks/{{Symbol}}\" target=\"_blank\">{{Symbol}}</a>\n        </li>\n      </ul>\n      <ul>\n        <li>\n          <a href=\"\" class=\"getAddress\" data-symbol=\"{{Symbol}}\">Get address</a>\n        </li>\n      </ul>\n      <ul>\n        <li>\n          <a href=\"\" class=\"addToWallet\" data-symbol=\"{{Symbol}}\">Add to wallet</a>\n        </li>\n      </ul>\n    </nav>\n  </td>\n</tr>\n{{/each}}\n";

class LiminalMarketService extends BlockchainService {
    static LiminalMarketInfo;
    constructor() {
        super();
    }
    async getSymbolContractAddress(symbol) {
        await this.loadEther();
        const contract = new Contract(this.contracts.LIMINAL_MARKET_ADDRESS, this.getSecurityTokenAbi, WidgetGlobals.User.ether);
        return await contract.getSecurityToken(symbol);
    }
    async createToken(symbol, creatingToken) {
        const contract = new Contract(this.contracts.LIMINAL_MARKET_ADDRESS, this.createTokenAbi, WidgetGlobals.User.signer);
        let result = await contract.createToken(symbol);
        creatingToken();
        console.log("createToken result:", result);
        await result.wait();
        return await this.getSymbolContractAddress(symbol);
    }
    getSecurityTokenAbi = [
        {
            inputs: [
                {
                    internalType: "string",
                    name: "symbol",
                    type: "string",
                },
            ],
            name: "getSecurityToken",
            outputs: [
                {
                    internalType: "address",
                    name: "",
                    type: "address",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
    ];
    createTokenAbi = [
        {
            inputs: [
                {
                    internalType: "string",
                    name: "symbol",
                    type: "string",
                },
            ],
            name: "createToken",
            outputs: [
                {
                    internalType: "contract SecurityToken",
                    name: "",
                    type: "address",
                },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
    ];
}

class CopyHelper {
    fallbackCopyTextToClipboard(text) {
        let textArea = document.createElement("textarea");
        textArea.value = text;
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            let successful = document.execCommand('copy');
            return successful;
        }
        catch (err) {
            console.error(err);
            return false;
        }
        finally {
            document.body.removeChild(textArea);
        }
    }
    async copyTextToClipboard(text) {
        if (!navigator.clipboard) {
            return this.fallbackCopyTextToClipboard(text);
        }
        let result = await navigator.clipboard.writeText(text).then(ble => {
            console.log('ble', ble);
            return true;
        }).
            catch(function (err) {
            console.info(err);
            return false;
        });
        console.log(result);
        return result;
    }
}

var AddressInfoHtml = "<article id=\"symbolInfoToCopy\">\n    This is the address for the symbol {{symbol}}.\n    <br>\n    <input value=\"{{address}}\">\n</article>\n";

var ContractAddressNotFound = "<tr id=\"symbolInfoToCopy\">\n    <td colspan=\"4\">\n        <article>\n        This symbol has never been bought and does not exist. Buy this symbol and address will become available.\n        </article>\n    </td>\n</tr>";

class SecuritiesList {
    page;
    tbodyId = "liminal_market_securities_list";
    loadmore;
    onSelectSymbol = undefined;
    constructor() {
        this.page = 0;
        this.loadmore = true;
    }
    async render() {
        let securitiesService = await SecuritiesService.getInstance();
        let securitiesCount = securitiesService.securitiesArray.length;
        let securities = await securitiesService.getPaginatingSecurities(this.page++);
        WidgetGlobals.HandlebarsInstance.registerPartial("securities", SecurityHtml);
        let template = WidgetGlobals.HandlebarsInstance.compile(SecuritiesListHtml);
        let obj = {
            tbodyId: this.tbodyId,
            securities: securities,
            securitiesCount: securitiesCount,
        };
        return template(obj);
    }
    async bindEvents(onSelectSymbol) {
        this.bindOnClickEvent(onSelectSymbol);
        await this.bindSearchEvent();
        this.bindLoadMore();
    }
    bindOnClickEvent(onSelectSymbol) {
        let table = document.getElementById("liminal_market_securities_table");
        if (!table) {
            ErrorInfo.report(new GeneralError("Page could not load correctly, try reloading"));
            return;
        }
        this.onSelectSymbol = onSelectSymbol;
        table.onclick = async (evt) => {
            await this.handleClick(evt);
        };
    }
    async handleClick(evt) {
        let element = evt.target;
        if (element.tagName.toLocaleLowerCase() === "a") {
            await this.addToWalletOrGetAddress(evt, element);
            return;
        }
        let parentTr = element.parentElement;
        if (!parentTr)
            return;
        if (parentTr.tagName.toLocaleLowerCase() !== "tr") {
            parentTr = parentTr.parentElement;
        }
        let symbol = parentTr.dataset.symbol;
        if (!symbol)
            return;
        let name = parentTr.dataset.name;
        let logo = parentTr.dataset.logo;
        if (this.onSelectSymbol) {
            this.onSelectSymbol(symbol, name, logo);
        }
    }
    async bindSearchEvent() {
        let searchForSymbol = document.getElementById("search_for_symbol");
        if (!searchForSymbol)
            return;
        let securitiesService = await SecuritiesService.getInstance();
        let timeout = null;
        searchForSymbol.addEventListener("keyup", async (evt) => {
            if (timeout != null)
                clearTimeout(timeout);
            timeout = setTimeout(async () => {
                let search = evt.target.value;
                if (!search || search.length < 2) {
                    this.loadmore = true;
                    await this.showTopSecurities(securitiesService);
                    return;
                }
                this.loadmore = false;
                let securities = await securitiesService.find(search);
                this.loadSecuritiesToDom(securities);
            }, 500);
        });
    }
    async showTopSecurities(securitiesService) {
        let securities = await securitiesService.getTopSecurities();
        this.loadSecuritiesToDom(securities);
    }
    loadSecuritiesToDom(securities) {
        let tbody = document.getElementById(this.tbodyId);
        if (!tbody)
            return;
        let template = WidgetGlobals.HandlebarsInstance.compile(SecurityHtml);
        let obj = {
            securities: securities,
        };
        let content = template(obj);
        tbody.innerHTML = content;
    }
    bindLoadMore() {
        const el = document.querySelector("#liminal_market_load_more");
        const observer = new window.IntersectionObserver(async ([entry]) => {
            if (entry.isIntersecting) {
                await this.loadMore();
            }
        }, {
            root: null,
            threshold: 0.1, // set offset 0.1 means trigger if atleast 10% of element in viewport
        });
        observer.observe(el);
    }
    async loadMore() {
        if (!this.loadmore)
            return;
        let tbody = document.getElementById(this.tbodyId);
        if (!tbody)
            return;
        let securitiesService = await SecuritiesService.getInstance();
        let securities = await securitiesService.getPaginatingSecurities(this.page++);
        let template = WidgetGlobals.HandlebarsInstance.compile(SecurityHtml);
        let obj = {
            securities: securities,
        };
        let content = template(obj);
        tbody.insertAdjacentHTML("beforeend", content);
    }
    async addToWalletOrGetAddress(event, element) {
        let className = element.className;
        if (className != "getAddress" && className != "addToWallet") {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        let symbol = element.dataset.symbol;
        if (!symbol)
            return;
        LoadingHelper.setLoading(element);
        let liminalMarketService = new LiminalMarketService();
        let address = await liminalMarketService.getSymbolContractAddress(symbol);
        if (className == "getAddress") {
            await this.showGetAddress(element, symbol, address);
        }
        else {
            await this.showAddToWallet(element, symbol, address);
        }
        LoadingHelper.removeLoading();
    }
    async showGetAddress(element, symbol, address) {
        if (address !== AddressZero) {
            let copyHelper = new CopyHelper();
            let success = await copyHelper.copyTextToClipboard(address);
            if (success) {
                element.innerText = "Copied";
                return;
            }
        }
        this.renderContractInfoToString(element, address, symbol, AddressInfoHtml);
    }
    async showAddToWallet(element, symbol, address) {
        if (address !== AddressZero) {
            let walletHelper = new WalletHelper();
            let added = await walletHelper.addTokenToWallet(address, symbol, () => {
                LoadingHelper.removeLoading();
                this.renderContractInfoToString(element, address, symbol, AddToWalletHtml);
            });
            if (added) {
                return "";
            }
        }
        this.renderContractInfoToString(element, address, symbol, AddToWalletHtml);
    }
    renderContractInfoToString(element, address, symbol, template) {
        let symbolInfoToCopy = document.getElementById("symbolInfoToCopy");
        if (symbolInfoToCopy)
            symbolInfoToCopy.remove();
        let content = "";
        if (address === AddressZero) {
            let template = WidgetGlobals.HandlebarsInstance.compile(ContractAddressNotFound);
            content = template(null);
        }
        else {
            let template = WidgetGlobals.HandlebarsInstance.compile(AddressInfoHtml);
            let obj = {
                symbol: symbol,
                address: address,
            };
            content = template(obj);
        }
        element.parentElement.parentElement.parentElement.insertAdjacentHTML("afterend", content);
    }
}

class SecuritiesListModal {
    page;
    tbodyId = 'liminal_market_securities_list';
    loadmore;
    modal;
    constructor() {
        this.page = 0;
        this.loadmore = true;
        this.modal = new Modal();
    }
    async showModal(onSelectSymbol) {
        let securitiesList = new SecuritiesList();
        let content = await securitiesList.render();
        this.modal.showModal('Select stock to buy', content, true);
        //if (newInstance)
        {
            await securitiesList.bindEvents(onSelectSymbol);
        }
    }
    hideModal() {
        this.modal.hideModal();
    }
}

class TradeInfo {
    price;
    lastTrade;
    constructor(price, lastTrade) {
        this.price = price;
        this.lastTrade = lastTrade;
    }
}

class HttpError {
    method;
    url;
    body;
    serverError;
    constructor(obj) {
        this.method = obj.method;
        this.url = obj.url;
        this.body = obj.body;
        this.serverError = obj.serverError;
    }
    handle() {
        console.log(this);
        ErrorInfo.report(new GeneralError('Error doing request. Server response was:' + this.serverError.data.message));
    }
}

class CloudError extends GeneralError {
    constructor(e) {
        super(e);
        try {
            let obj = JSON.parse(e.message);
            if (obj.name) {
                let errorHandler = CloudError.getActionInstance(obj.name, obj);
                if (errorHandler) {
                    errorHandler.handle();
                    return;
                }
            }
            ErrorInfo.error(obj);
        }
        catch (jsonError) {
            ErrorInfo.error(e);
        }
    }
    static getActionInstance(action, obj) {
        let tmp = undefined;
        for (let i = 0; i < CloudError.Errors.length; i++) {
            if (CloudError.Errors[i].name === action) {
                let errorHandler = CloudError.Errors[i];
                return new errorHandler(obj);
            }
        }
        return tmp;
    }
    static Errors = [
        HttpError
    ];
}

class StockPriceService extends BaseService {
    constructor() {
        super();
    }
    async getSymbolPrice(symbol, tradeType) {
        const params = {
            symbol: symbol
        };
        let result = await this.get("getSymbolPrice", params)
            .catch((e) => {
            throw new CloudError(e);
        });
        if (!result.quote)
            throw new Error('Quote could not be provided');
        let quote = result.quote;
        let price = (tradeType == TradeType.Sell) ? quote.ap : quote.bp;
        let tradeInfo = new TradeInfo(price, quote.t);
        return tradeInfo;
    }
}

var PricePerShareHtml = "<abbr title=\"Last trade was {{lastTraded}}\" data-tooltip=\"Last trade was {{lastTraded}}\">{{text}}</abbr>";

class TradePanelInput {
    symbol;
    name;
    logo;
    address;
    tradeType;
    quantity;
    strQuantity;
    balance;
    lastPrice;
    lastTraded;
    qtyPerDollar;
    template;
    pricePerShareTemplate;
    otherTradePanelInput;
    onUpdate;
    isDirty = false;
    constructor(symbol, name, logo, address, tradeType) {
        this.symbol = symbol;
        this.name = name;
        this.logo = logo;
        this.address = address;
        this.tradeType = tradeType;
        this.quantity = BigNumber.from(0);
        this.strQuantity = "";
        this.balance = BigNumber.from(0);
        this.lastPrice = 0;
        this.qtyPerDollar = 0;
        this.lastTraded = "";
        this.template = WidgetGlobals.HandlebarsInstance.compile(TradeInputHtml);
        this.pricePerShareTemplate =
            WidgetGlobals.HandlebarsInstance.compile(PricePerShareHtml);
    }
    setOtherTradePanelInput(tradePanelInput) {
        this.otherTradePanelInput = tradePanelInput;
    }
    renderToString() {
        return this.template(this);
    }
    render(bindEvents = true) {
        let element = document.querySelector("." + this.tradeType + "Inputs");
        element.outerHTML = this.renderToString();
        if (bindEvents) {
            this.bindEvents();
        }
    }
    bindEvents() {
        this.bindQuantityListener();
        this.bindSelectStockButton();
        this.bindMaxLink();
    }
    setSymbol(symbol, name, logo) {
        this.symbol = symbol;
        this.name = name;
        this.logo = logo;
        this.isDirty = true;
    }
    bindSelectStockButton() {
        let selectStock = document.querySelector("#" + this.tradeType + "SelectStock");
        if (!selectStock)
            return;
        selectStock.addEventListener("click", async (evt) => {
            evt.preventDefault();
            let securityList = new SecuritiesListModal();
            await securityList.showModal(async (symbol, name, logo) => {
                securityList.hideModal();
                if (this.otherTradePanelInput &&
                    this.symbol == "aUSD" &&
                    symbol != this.symbol) {
                    this.otherTradePanelInput.setSymbol(this.symbol, this.name, this.logo);
                }
                this.symbol = symbol;
                this.name = name;
                this.logo = logo;
                let liminalMarketService = new LiminalMarketService();
                this.address = await liminalMarketService.getSymbolContractAddress(symbol);
                this.render();
                this.loadBalance().then();
                await this.loadLastTrade();
                if (this.onUpdate)
                    this.onUpdate();
            });
        });
    }
    bindQuantityListener() {
        let qtyInput = document.querySelector("." + this.tradeType + "Inputs .trade_input input");
        if (!qtyInput)
            return;
        let inputTimer;
        qtyInput.addEventListener("keyup", (evt) => {
            if (inputTimer)
                clearTimeout(inputTimer);
            inputTimer = setTimeout(() => {
                let inputValue = evt.target.value;
                this.setQuantity(inputValue);
                this.loadProgressbar();
                if (this.otherTradePanelInput)
                    this.otherTradePanelInput.updateQuantity();
                if (this.onUpdate)
                    this.onUpdate();
            }, 300);
        });
    }
    bindMaxLink() {
        let maxBalanceDom = document.querySelector("." + this.tradeType + "Inputs .balance_max");
        if (!maxBalanceDom)
            return;
        maxBalanceDom.addEventListener("click", (evt) => {
            evt.preventDefault();
            let qtyInput = document.querySelector("." + this.tradeType + "Inputs .trade_input input");
            if (!qtyInput)
                return;
            qtyInput.value = utils.formatUnits(this.balance);
            this.setQuantity(qtyInput.value);
            this.loadProgressbar();
            if (this.otherTradePanelInput)
                this.otherTradePanelInput.updateQuantity();
            if (this.onUpdate)
                this.onUpdate();
        });
    }
    async loadBalance() {
        this.balance = BigNumber.from(0);
        let ethAddress = WidgetGlobals.User.address;
        let balanceDom = document.querySelector("." + this.tradeType + "Inputs .balance_value");
        if (!balanceDom)
            return;
        if (this.symbol === "aUSD") {
            if (ethAddress) {
                this.balance = await WidgetGlobals.LiminalMarket.getAUSDBalance(ethAddress);
            }
            balanceDom.innerHTML =
                "$" + parseFloat(utils.formatEther(this.balance)).toFixed(2);
        }
        else if (this.name !== "") {
            this.balance = BigNumber.from(0);
            if (ethAddress) {
                this.balance =
                    await WidgetGlobals.LiminalMarket.getSecurityTokenQuantity(this.symbol, ethAddress);
            }
            balanceDom.innerHTML =
                "" + parseFloat(utils.formatEther(this.balance)).toFixed(2);
        }
        balanceDom.dataset.tooltip = "" + parseFloat(utils.formatEther(this.balance));
        balanceDom.title = "" + parseFloat(utils.formatEther(this.balance));
        this.loadProgressbar();
        this.toggleMaxBalanceLink();
    }
    async loadLastTrade() {
        if (this.symbol === "aUSD") {
            this.lastPrice = 1;
            this.qtyPerDollar = 1;
            return;
        }
        if (!this.otherTradePanelInput || this.name == "")
            return;
        let aUsdPricePerShare = document.querySelector("." + this.otherTradePanelInput.tradeType + "Inputs .price_per_share");
        if (!aUsdPricePerShare)
            return;
        let pricePerShare = document.querySelector("." + this.tradeType + "Inputs .price_per_share");
        if (!pricePerShare)
            return;
        aUsdPricePerShare.setAttribute("aria-busy", "true");
        pricePerShare.setAttribute("aria-busy", "true");
        let stockPriceService = new StockPriceService();
        let tradeInfo = await stockPriceService
            .getSymbolPrice(this.symbol, this.otherTradePanelInput.tradeType)
            .catch((reason) => {
            alert(reason.message);
            aUsdPricePerShare.removeAttribute("aria-busy");
            pricePerShare.removeAttribute("aria-busy");
        });
        if (!tradeInfo)
            return;
        this.lastPrice = tradeInfo.price;
        this.lastTraded = tradeInfo.lastTrade.toString();
        this.qtyPerDollar = 1 / this.lastPrice;
        let pricePerShareHtml = {
            lastTraded: this.lastTraded,
            text: "≈ $" + this.lastPrice + " per share",
        };
        pricePerShare.innerHTML = this.pricePerShareTemplate(pricePerShareHtml);
        let pricePerAUsdHtml = {
            lastTraded: this.lastTraded,
            text: "1 aUSD ≈ " +
                roundNumberDecimal(this.qtyPerDollar, 6) +
                " " +
                this.symbol,
        };
        aUsdPricePerShare.innerHTML = this.pricePerShareTemplate(pricePerAUsdHtml);
        this.updateQuantity();
        aUsdPricePerShare.removeAttribute("aria-busy");
        pricePerShare.removeAttribute("aria-busy");
    }
    updateQuantity() {
        if (!this.otherTradePanelInput)
            return;
        let qtyInput = document.querySelector("." + this.tradeType + "Inputs .trade_input input");
        if (!qtyInput)
            return;
        if (this.symbol === "aUSD") {
            qtyInput.value =
                "" +
                    (parseFloat(utils.formatUnits(this.otherTradePanelInput.quantity)) /
                        this.otherTradePanelInput.qtyPerDollar).toFixed(18);
        }
        else {
            qtyInput.value =
                "" +
                    (parseFloat(utils.formatUnits(this.otherTradePanelInput.quantity)) *
                        this.qtyPerDollar).toFixed(18);
        }
        if (qtyInput.value == "0.000000000000000000") {
            qtyInput.value = "";
        }
        this.setQuantity(qtyInput.value);
        this.loadProgressbar();
    }
    loadProgressbar() {
        if (this.quantity.eq(0) ||
            this.balance.eq(0) ||
            this.tradeType == TradeType.Buy)
            return;
        let progressDom = document.querySelector("." + this.tradeType + "Inputs .progress");
        if (!progressDom)
            return;
        let percentage = parseFloat(utils.formatUnits(this.quantity.div(this.balance)));
        progressDom.value = percentage;
        progressDom.classList.remove("d-none");
        let exceedsBalance = document.querySelector("." + this.tradeType + "Inputs .exceeds_wallet_balance");
        if (percentage > 1) {
            exceedsBalance.classList.remove("d-none");
            progressDom.setAttribute("aria-invalid", "true");
        }
        else {
            exceedsBalance.classList.add("d-none");
        }
    }
    static async switchPanels(sellTradePanelInput, buyTradePanelInput) {
        let sellSymbol = sellTradePanelInput.symbol;
        let sellName = sellTradePanelInput.name;
        let sellLogo = sellTradePanelInput.logo;
        let sellQuantity = sellTradePanelInput.quantity;
        sellTradePanelInput.setSymbol(buyTradePanelInput.symbol, buyTradePanelInput.name, buyTradePanelInput.logo);
        sellTradePanelInput.quantity = buyTradePanelInput.quantity;
        buyTradePanelInput.setSymbol(sellSymbol, sellName, sellLogo);
        buyTradePanelInput.quantity = sellQuantity;
        await sellTradePanelInput.updatePanel();
        await buyTradePanelInput.updatePanel();
        return [sellTradePanelInput, buyTradePanelInput];
    }
    setQuantity(value) {
        console.log("setQuantity", value);
        if (value == "") {
            value = "0";
        }
        this.quantity = utils.parseEther(value);
        this.strQuantity = value;
    }
    quantityFormatted() {
        return this.symbol === "aUSD" ? "$" + this.quantity : this.quantity;
    }
    async updatePanel() {
        this.updateQuantity();
        this.render(true);
        await this.loadBalance();
        await this.loadLastTrade();
    }
    toggleMaxBalanceLink() {
        let maxBalanceDom = document.querySelector("." + this.tradeType + "Inputs .balance_max");
        if (!maxBalanceDom)
            return;
        if (this.balance.eq(0)) {
            maxBalanceDom.classList.add("d-none");
        }
        else {
            maxBalanceDom.classList.remove("d-none");
        }
    }
}

var TradeSwitchHtml = "<div class=\"grid tradeSwitch\">\n    <a title=\"Switch the trade\" href=\"\" class=\"switchBtn\" class=\"outline\"></a>\n</div>";

class TradeSwitch {
    template = undefined;
    constructor() {
        this.template = WidgetGlobals.HandlebarsInstance.compile(TradeSwitchHtml);
    }
    renderToString() {
        return this.template();
    }
    render() {
        let dom = document.querySelector(".tradeSwitch");
        if (!dom)
            return;
        dom.outerHTML = this.renderToString();
    }
    bindEvents(sellTradePanelInput, buyTradePanelInput, executeTradeButton) {
        let dom = document.querySelector(".switchBtn");
        if (!dom)
            return;
        dom.addEventListener("click", async (evt) => {
            evt.preventDefault();
            [sellTradePanelInput, buyTradePanelInput] =
                await TradePanelInput.switchPanels(sellTradePanelInput, buyTradePanelInput);
        });
    }
}

var slugifyExports = {};
var slugify$1 = {
  get exports(){ return slugifyExports; },
  set exports(v){ slugifyExports = v; },
};

(function (module, exports) {
  (function (name, root, factory) {
    {
      module.exports = factory();
      module.exports['default'] = factory();
    }
  })('slugify', commonjsGlobal, function () {
    var charMap = JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","¢":"cent","£":"pound","¤":"currency","¥":"yen","©":"(c)","ª":"a","®":"(r)","º":"o","À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ý":"y","þ":"th","ÿ":"y","Ā":"A","ā":"a","Ă":"A","ă":"a","Ą":"A","ą":"a","Ć":"C","ć":"c","Č":"C","č":"c","Ď":"D","ď":"d","Đ":"DJ","đ":"dj","Ē":"E","ē":"e","Ė":"E","ė":"e","Ę":"e","ę":"e","Ě":"E","ě":"e","Ğ":"G","ğ":"g","Ģ":"G","ģ":"g","Ĩ":"I","ĩ":"i","Ī":"i","ī":"i","Į":"I","į":"i","İ":"I","ı":"i","Ķ":"k","ķ":"k","Ļ":"L","ļ":"l","Ľ":"L","ľ":"l","Ł":"L","ł":"l","Ń":"N","ń":"n","Ņ":"N","ņ":"n","Ň":"N","ň":"n","Ō":"O","ō":"o","Ő":"O","ő":"o","Œ":"OE","œ":"oe","Ŕ":"R","ŕ":"r","Ř":"R","ř":"r","Ś":"S","ś":"s","Ş":"S","ş":"s","Š":"S","š":"s","Ţ":"T","ţ":"t","Ť":"T","ť":"t","Ũ":"U","ũ":"u","Ū":"u","ū":"u","Ů":"U","ů":"u","Ű":"U","ű":"u","Ų":"U","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","ź":"z","Ż":"Z","ż":"z","Ž":"Z","ž":"z","Ə":"E","ƒ":"f","Ơ":"O","ơ":"o","Ư":"U","ư":"u","ǈ":"LJ","ǉ":"lj","ǋ":"NJ","ǌ":"nj","Ș":"S","ș":"s","Ț":"T","ț":"t","ə":"e","˚":"o","Ά":"A","Έ":"E","Ή":"H","Ί":"I","Ό":"O","Ύ":"Y","Ώ":"W","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ϊ":"I","Ϋ":"Y","ά":"a","έ":"e","ή":"h","ί":"i","ΰ":"y","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","ς":"s","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ϊ":"i","ϋ":"y","ό":"o","ύ":"y","ώ":"w","Ё":"Yo","Ђ":"DJ","Є":"Ye","І":"I","Ї":"Yi","Ј":"J","Љ":"LJ","Њ":"NJ","Ћ":"C","Џ":"DZ","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","ё":"yo","ђ":"dj","є":"ye","і":"i","ї":"yi","ј":"j","љ":"lj","њ":"nj","ћ":"c","ѝ":"u","џ":"dz","Ґ":"G","ґ":"g","Ғ":"GH","ғ":"gh","Қ":"KH","қ":"kh","Ң":"NG","ң":"ng","Ү":"UE","ү":"ue","Ұ":"U","ұ":"u","Һ":"H","һ":"h","Ә":"AE","ә":"ae","Ө":"OE","ө":"oe","Ա":"A","Բ":"B","Գ":"G","Դ":"D","Ե":"E","Զ":"Z","Է":"E\'","Ը":"Y\'","Թ":"T\'","Ժ":"JH","Ի":"I","Լ":"L","Խ":"X","Ծ":"C\'","Կ":"K","Հ":"H","Ձ":"D\'","Ղ":"GH","Ճ":"TW","Մ":"M","Յ":"Y","Ն":"N","Շ":"SH","Չ":"CH","Պ":"P","Ջ":"J","Ռ":"R\'","Ս":"S","Վ":"V","Տ":"T","Ր":"R","Ց":"C","Փ":"P\'","Ք":"Q\'","Օ":"O\'\'","Ֆ":"F","և":"EV","ء":"a","آ":"aa","أ":"a","ؤ":"u","إ":"i","ئ":"e","ا":"a","ب":"b","ة":"h","ت":"t","ث":"th","ج":"j","ح":"h","خ":"kh","د":"d","ذ":"th","ر":"r","ز":"z","س":"s","ش":"sh","ص":"s","ض":"dh","ط":"t","ظ":"z","ع":"a","غ":"gh","ف":"f","ق":"q","ك":"k","ل":"l","م":"m","ن":"n","ه":"h","و":"w","ى":"a","ي":"y","ً":"an","ٌ":"on","ٍ":"en","َ":"a","ُ":"u","ِ":"e","ْ":"","٠":"0","١":"1","٢":"2","٣":"3","٤":"4","٥":"5","٦":"6","٧":"7","٨":"8","٩":"9","پ":"p","چ":"ch","ژ":"zh","ک":"k","گ":"g","ی":"y","۰":"0","۱":"1","۲":"2","۳":"3","۴":"4","۵":"5","۶":"6","۷":"7","۸":"8","۹":"9","฿":"baht","ა":"a","ბ":"b","გ":"g","დ":"d","ე":"e","ვ":"v","ზ":"z","თ":"t","ი":"i","კ":"k","ლ":"l","მ":"m","ნ":"n","ო":"o","პ":"p","ჟ":"zh","რ":"r","ს":"s","ტ":"t","უ":"u","ფ":"f","ქ":"k","ღ":"gh","ყ":"q","შ":"sh","ჩ":"ch","ც":"ts","ძ":"dz","წ":"ts","ჭ":"ch","ხ":"kh","ჯ":"j","ჰ":"h","Ṣ":"S","ṣ":"s","Ẁ":"W","ẁ":"w","Ẃ":"W","ẃ":"w","Ẅ":"W","ẅ":"w","ẞ":"SS","Ạ":"A","ạ":"a","Ả":"A","ả":"a","Ấ":"A","ấ":"a","Ầ":"A","ầ":"a","Ẩ":"A","ẩ":"a","Ẫ":"A","ẫ":"a","Ậ":"A","ậ":"a","Ắ":"A","ắ":"a","Ằ":"A","ằ":"a","Ẳ":"A","ẳ":"a","Ẵ":"A","ẵ":"a","Ặ":"A","ặ":"a","Ẹ":"E","ẹ":"e","Ẻ":"E","ẻ":"e","Ẽ":"E","ẽ":"e","Ế":"E","ế":"e","Ề":"E","ề":"e","Ể":"E","ể":"e","Ễ":"E","ễ":"e","Ệ":"E","ệ":"e","Ỉ":"I","ỉ":"i","Ị":"I","ị":"i","Ọ":"O","ọ":"o","Ỏ":"O","ỏ":"o","Ố":"O","ố":"o","Ồ":"O","ồ":"o","Ổ":"O","ổ":"o","Ỗ":"O","ỗ":"o","Ộ":"O","ộ":"o","Ớ":"O","ớ":"o","Ờ":"O","ờ":"o","Ở":"O","ở":"o","Ỡ":"O","ỡ":"o","Ợ":"O","ợ":"o","Ụ":"U","ụ":"u","Ủ":"U","ủ":"u","Ứ":"U","ứ":"u","Ừ":"U","ừ":"u","Ử":"U","ử":"u","Ữ":"U","ữ":"u","Ự":"U","ự":"u","Ỳ":"Y","ỳ":"y","Ỵ":"Y","ỵ":"y","Ỷ":"Y","ỷ":"y","Ỹ":"Y","ỹ":"y","–":"-","‘":"\'","’":"\'","“":"\\\"","”":"\\\"","„":"\\\"","†":"+","•":"*","…":"...","₠":"ecu","₢":"cruzeiro","₣":"french franc","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","€":"euro","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","₸":"kazakhstani tenge","₹":"indian rupee","₺":"turkish lira","₽":"russian ruble","₿":"bitcoin","℠":"sm","™":"tm","∂":"d","∆":"delta","∑":"sum","∞":"infinity","♥":"love","元":"yuan","円":"yen","﷼":"rial","ﻵ":"laa","ﻷ":"laa","ﻹ":"lai","ﻻ":"la"}');
    var locales = JSON.parse('{"bg":{"Й":"Y","Ц":"Ts","Щ":"Sht","Ъ":"A","Ь":"Y","й":"y","ц":"ts","щ":"sht","ъ":"a","ь":"y"},"de":{"Ä":"AE","ä":"ae","Ö":"OE","ö":"oe","Ü":"UE","ü":"ue","ß":"ss","%":"prozent","&":"und","|":"oder","∑":"summe","∞":"unendlich","♥":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","¢":"centavos","£":"libras","¤":"moneda","₣":"francos","∑":"suma","∞":"infinito","♥":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","¢":"centime","£":"livre","¤":"devise","₣":"franc","∑":"somme","∞":"infini","♥":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","¢":"centavo","∑":"soma","£":"libra","∞":"infinito","♥":"amor"},"uk":{"И":"Y","и":"y","Й":"Y","й":"y","Ц":"Ts","ц":"ts","Х":"Kh","х":"kh","Щ":"Shch","щ":"shch","Г":"H","г":"h"},"vi":{"Đ":"D","đ":"d"},"da":{"Ø":"OE","ø":"oe","Å":"AA","å":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"større end"},"nb":{"&":"og","Å":"AA","Æ":"AE","Ø":"OE","å":"aa","æ":"ae","ø":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","Å":"AA","Ä":"AE","Ö":"OE","å":"aa","ä":"ae","ö":"oe"}}');
    function replace(string, options) {
      if (typeof string !== 'string') {
        throw new Error('slugify: string argument expected');
      }
      options = typeof options === 'string' ? {
        replacement: options
      } : options || {};
      var locale = locales[options.locale] || {};
      var replacement = options.replacement === undefined ? '-' : options.replacement;
      var trim = options.trim === undefined ? true : options.trim;
      var slug = string.normalize().split('')
      // replace characters based on charMap
      .reduce(function (result, ch) {
        var appendChar = locale[ch];
        if (appendChar === undefined) appendChar = charMap[ch];
        if (appendChar === undefined) appendChar = ch;
        if (appendChar === replacement) appendChar = ' ';
        return result + appendChar
        // remove not allowed characters
        .replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, '');
      }, '');
      if (options.strict) {
        slug = slug.replace(/[^A-Za-z0-9\s]/g, '');
      }
      if (trim) {
        slug = slug.trim();
      }

      // Replace spaces with replacement character, treating multiple consecutive
      // spaces as a single space.
      slug = slug.replace(/\s+/g, replacement);
      if (options.lower) {
        slug = slug.toLowerCase();
      }
      return slug;
    }
    replace.extend = function (customMap) {
      Object.assign(charMap, customMap);
    };
    return replace;
  });
})(slugify$1);

var escaperExports = {};
var escaper$1 = {
  get exports(){ return escaperExports; },
  set exports(v){ escaperExports = v; },
};

/*!
 * Escaper v2.5.3
 * https://github.com/kobezzza/Escaper
 *
 * Released under the MIT license
 * https://github.com/kobezzza/Escaper/blob/master/LICENSE
 *
 * Date: Tue, 23 Jan 2018 15:58:45 GMT
 */
(function (module, exports) {
  (function (global, factory) {
    factory(exports) ;
  })(commonjsGlobal, function (exports) {

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var Escaper = void 0;
    var escaper = Escaper = {
      VERSION: [2, 5, 3],
      content: [],
      cache: {},
      snakeskinRgxp: null,
      symbols: null,
      replace: replace,
      paste: paste
    };
    var stringLiterals = {
      '"': true,
      '\'': true,
      '`': true
    };
    var literals = {
      '/': true
    };
    for (var key in stringLiterals) {
      if (!stringLiterals.hasOwnProperty(key)) {
        break;
      }
      literals[key] = true;
    }
    var singleComments = {
      '//': true,
      '//*': true,
      '//!': true,
      '//#': true,
      '//@': true,
      '//$': true
    };
    var multComments = {
      '/*': true,
      '/**': true,
      '/*!': true,
      '/*#': true,
      '/*@': true,
      '/*$': true
    };
    var keyArr = [];
    var finalMap = {};
    for (var _key in literals) {
      if (!literals.hasOwnProperty(_key)) {
        break;
      }
      keyArr.push(_key);
      finalMap[_key] = true;
    }
    for (var _key2 in singleComments) {
      if (!singleComments.hasOwnProperty(_key2)) {
        break;
      }
      keyArr.push(_key2);
      finalMap[_key2] = true;
    }
    for (var _key3 in multComments) {
      if (!multComments.hasOwnProperty(_key3)) {
        break;
      }
      keyArr.push(_key3);
      finalMap[_key3] = true;
    }
    var rgxpFlags = [];
    var rgxpFlagsMap = {
      'g': true,
      'm': true,
      'i': true,
      'y': true,
      'u': true
    };
    for (var _key4 in rgxpFlagsMap) {
      if (!rgxpFlagsMap.hasOwnProperty(_key4)) {
        break;
      }
      rgxpFlags.push(_key4);
    }
    var escapeEndMap = {
      '-': true,
      '+': true,
      '*': true,
      '%': true,
      '~': true,
      '>': true,
      '<': true,
      '^': true,
      ',': true,
      ';': true,
      '=': true,
      '|': true,
      '&': true,
      '!': true,
      '?': true,
      ':': true,
      '(': true,
      '{': true,
      '[': true
    };
    var escapeEndWordMap = {
      'return': true,
      'yield': true,
      'await': true,
      'typeof': true,
      'void': true,
      'instanceof': true,
      'delete': true,
      'in': true,
      'new': true,
      'of': true
    };

    /**
     * @param {!Object} obj
     * @param {!Object} p
     * @param {(boolean|number)} val
     */
    function mix(obj, p, val) {
      for (var _key5 in obj) {
        if (!obj.hasOwnProperty(_key5)) {
          break;
        }
        if (_key5 in p === false) {
          p[_key5] = val;
        }
      }
    }
    var symbols = void 0;
    var snakeskinRgxp = void 0;
    var uSRgxp = /[^\s/]/;
    var wRgxp = /[a-z]/;
    var sRgxp = /\s/;
    var nRgxp = /[\r\n]/;
    var posRgxp = /\${pos}/g;
    var objMap = {
      'object': true,
      'function': true
    };

    /**
     * Replaces all found blocks ' ... ', " ... ", ` ... `, / ... /, // ..., /* ... *\/ to
     * __ESCAPER_QUOT__number_ in a string and returns a new string
     *
     * @param {string} str - source string
     * @param {(Object<string, boolean>|boolean)=} [opt_withCommentsOrParams=false] - parameters:
     *
     *     (if a parameter value is set to -1, then all found matches will be removed from the final string,
     *          or if the value will be set to true/false they will be included/excluded)
     *
     *     *) @label    - template for replacement, e.g. __ESCAPER_QUOT__${pos}_
     *     *) @all      - replaces all found matches
     *     *) @comments - replaces all kinds of comments
     *     *) @strings  - replaces all kinds of string literals
     *     *) @literals - replaces all kinds of string literals and regular expressions
     *     *) `
     *     *) '
     *     *) "
     *     *) /
     *     *) //
     *     *) //*
     *     *) //!
     *     *) //#
     *     *) //@
     *     *) //$
     *     *) /*
     *     *) /**
     *     *) /*!
     *     *) /*#
     *     *) /*@
     *     *) /*$
     *
     *     OR if the value is boolean, then will be replaced all found comments (true) / literals (false)
     *
     * @param {Array=} [opt_content=Escaper.content] - array for matches
     * @param {?boolean=} [opt_snakeskin] - private parameter for using with Snakeskin
     * @return {string}
     */
    function replace(str, opt_withCommentsOrParams, opt_content, opt_snakeskin) {
      symbols = symbols || Escaper.symbols || 'a-z';
      snakeskinRgxp = snakeskinRgxp || Escaper.snakeskinRgxp || new RegExp('[!$' + symbols + '_]', 'i');
      var _Escaper = Escaper,
        cache = _Escaper.cache,
        content = _Escaper.content;
      var isObj = Boolean(opt_withCommentsOrParams && objMap[typeof opt_withCommentsOrParams === 'undefined' ? 'undefined' : _typeof(opt_withCommentsOrParams)]);
      var p = isObj ? Object(opt_withCommentsOrParams) : {};
      function mark(pos) {
        if (p['@label']) {
          return p['@label'].replace(posRgxp, pos);
        }
        return '__ESCAPER_QUOT__' + pos + '_';
      }
      var withComments = false;
      if (typeof opt_withCommentsOrParams === 'boolean') {
        withComments = Boolean(opt_withCommentsOrParams);
      }
      if ('@comments' in p) {
        mix(multComments, p, p['@comments']);
        mix(singleComments, p, p['@comments']);
        delete p['@comments'];
      }
      if ('@strings' in p) {
        mix(stringLiterals, p, p['@strings']);
        delete p['@strings'];
      }
      if ('@literals' in p) {
        mix(literals, p, p['@literals']);
        delete p['@literals'];
      }
      if ('@all' in p) {
        mix(finalMap, p, p['@all']);
        delete p['@all'];
      }
      var cacheKey = '';
      for (var i = -1; ++i < keyArr.length;) {
        var el = keyArr[i];
        if (multComments[el] || singleComments[el]) {
          p[el] = withComments || p[el];
        } else {
          p[el] = p[el] || !isObj;
        }
        cacheKey += p[el] + ',';
      }
      var initStr = str,
        stack = opt_content || content;
      if (stack === content && cache[cacheKey] && cache[cacheKey][initStr]) {
        return cache[cacheKey][initStr];
      }
      var begin = false,
        end = true;
      var escape = false,
        comment = false;
      var selectionStart = 0,
        block = false;
      var templateVar = 0,
        filterStart = false;
      var cut = void 0,
        label = void 0;
      var part = '',
        rPart = '';
      for (var _i = -1; ++_i < str.length;) {
        var _el = str.charAt(_i);
        var next = str.charAt(_i + 1),
          word = str.substr(_i, 2),
          extWord = str.substr(_i, 3);
        if (!comment) {
          if (!begin) {
            if (_el === '/') {
              if (singleComments[word] || multComments[word]) {
                if (singleComments[extWord] || multComments[extWord]) {
                  comment = extWord;
                } else {
                  comment = word;
                }
              }
              if (comment) {
                selectionStart = _i;
                continue;
              }
            }
            if (escapeEndMap[_el] || escapeEndWordMap[rPart]) {
              end = true;
              rPart = '';
            } else if (uSRgxp.test(_el)) {
              end = false;
            }
            if (wRgxp.test(_el)) {
              part += _el;
            } else {
              rPart = part;
              part = '';
            }
            var skip = false;
            if (opt_snakeskin) {
              if (_el === '|' && snakeskinRgxp.test(next)) {
                filterStart = true;
                end = false;
                skip = true;
              } else if (filterStart && sRgxp.test(_el)) {
                filterStart = false;
                end = true;
                skip = true;
              }
            }
            if (!skip) {
              if (escapeEndMap[_el]) {
                end = true;
              } else if (uSRgxp.test(_el)) {
                end = false;
              }
            }
          }

          // [] inside RegExp
          if (begin === '/' && !escape) {
            if (_el === '[') {
              block = true;
            } else if (_el === ']') {
              block = false;
            }
          }
          if (!begin && templateVar) {
            if (_el === '}') {
              templateVar--;
            } else if (_el === '{') {
              templateVar++;
            }
            if (!templateVar) {
              _el = '`';
            }
          }
          if (begin === '`' && !escape && word === '${') {
            _el = '`';
            _i++;
            templateVar++;
          }
          if (finalMap[_el] && (_el !== '/' || end) && !begin) {
            begin = _el;
            selectionStart = _i;
          } else if (begin && (_el === '\\' || escape)) {
            escape = !escape;
          } else if (finalMap[_el] && begin === _el && !escape && (begin !== '/' || !block)) {
            if (_el === '/') {
              for (var j = -1; ++j < rgxpFlags.length;) {
                if (rgxpFlagsMap[str.charAt(_i + 1)]) {
                  _i++;
                }
              }
            }
            begin = false;
            end = false;
            if (p[_el]) {
              cut = str.substring(selectionStart, _i + 1);
              if (p[_el] === -1) {
                label = '';
              } else {
                label = mark(stack.length);
                stack.push(cut);
              }
              str = str.substring(0, selectionStart) + label + str.substring(_i + 1);
              _i += label.length - cut.length;
            }
          }
        } else if (nRgxp.test(next) && singleComments[comment] || multComments[_el + str.charAt(_i - 1)] && _i - selectionStart > 2 && multComments[comment]) {
          if (p[comment]) {
            cut = str.substring(selectionStart, _i + 1);
            if (p[comment] === -1) {
              label = '';
            } else {
              label = mark(stack.length);
              stack.push(cut);
            }
            str = str.substring(0, selectionStart) + label + str.substring(_i + 1);
            _i += label.length - cut.length;
          }
          comment = false;
        }
      }
      if (stack === content) {
        cache[cacheKey] = cache[cacheKey] || {};
        cache[cacheKey][initStr] = str;
      }
      return str;
    }
    var pasteRgxp = /__ESCAPER_QUOT__(\d+)_/g;

    /**
     * Replaces all found blocks __ESCAPER_QUOT__number_ to real content in a string
     * and returns a new string
     *
     * @param {string} str - source string
     * @param {Array=} [opt_content=Escaper.content] - array of matches
     * @param {RegExp=} [opt_rgxp] - RegExp for searching, e.g. /__ESCAPER_QUOT__(\d+)_/g
     * @return {string}
     */
    function paste(str, opt_content, opt_rgxp) {
      return str.replace(opt_rgxp || pasteRgxp, function (str, pos) {
        return (opt_content || Escaper.content)[pos];
      });
    }
    exports['default'] = escaper;
    exports.replace = replace;
    exports.paste = paste;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
  });
})(escaper$1, escaperExports);

var isRegexp = function (re) {
  return Object.prototype.toString.call(re) === '[object RegExp]';
};

var isRegExp = isRegexp;
var stripCssComments = function (str, opts) {
  str = str.toString();
  opts = opts || {};
  var preserveFilter;
  var comment = '';
  var currentChar = '';
  var insideString = false;
  var preserveImportant = !(opts.preserve === false || opts.all === true);
  var ret = '';
  if (typeof opts.preserve === 'function') {
    preserveImportant = false;
    preserveFilter = opts.preserve;
  } else if (isRegExp(opts.preserve)) {
    preserveImportant = false;
    preserveFilter = function (comment) {
      return opts.preserve.test(comment);
    };
  }
  for (var i = 0; i < str.length; i++) {
    currentChar = str[i];
    if (str[i - 1] !== '\\') {
      if (currentChar === '"' || currentChar === '\'') {
        if (insideString === currentChar) {
          insideString = false;
        } else if (!insideString) {
          insideString = currentChar;
        }
      }
    }

    // find beginning of /* type comment
    if (!insideString && currentChar === '/' && str[i + 1] === '*') {
      // ignore important comment when configured to preserve comments using important syntax: /*!
      if (!(preserveImportant && str[i + 2] === '!')) {
        var j = i + 2;

        // iterate over comment
        for (; j < str.length; j++) {
          // find end of comment
          if (str[j] === '*' && str[j + 1] === '/') {
            if (preserveFilter) {
              // evaluate comment text
              ret = preserveFilter(comment) ? ret + ('/*' + comment + '*/') : ret;
              comment = '';
            }
            break;
          }

          // store comment text to be evaluated by the filter when the end of the comment is reached
          if (preserveFilter) {
            comment += str[j];
          }
        }

        // resume iteration over CSS string from the end of the comment
        i = j + 1;
        continue;
      }
    }
    ret += currentChar;
  }
  return ret;
};

var slugify = slugifyExports;
var escaper = escaperExports;
var stripComments = stripCssComments;
var scopeCss = scope;
scope.replace = replace;
function scope(css, parent, o) {
  if (!css) return css;
  if (!parent) return css;
  if (typeof o === 'string') o = {
    keyframes: o
  };
  if (!o) o = {
    keyframes: false
  };
  css = replace(css, parent + ' $1$2');

  //regexp.escape
  var parentRe = parent.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');

  //replace self-selectors
  css = css.replace(new RegExp('(' + parentRe + ')\\s*\\1(?=[\\s\\r\\n,{])', 'g'), '$1');

  //replace `:host` with parent
  css = css.replace(new RegExp('(' + parentRe + ')\\s*:host', 'g'), '$1');

  //revoke wrongly replaced @ statements, like @supports, @import, @media etc.
  css = css.replace(new RegExp('(' + parentRe + ')\\s*@', 'g'), '@');

  //revoke wrongly replaced :root blocks
  css = css.replace(new RegExp('(' + parentRe + ')\\s*:root', 'g'), ':root');

  //animations: prefix animation anmes
  var animations = [],
    animationNameRe = /@keyframes\s+([a-zA-Z0-9_-]+)\s*{/g,
    match;
  while ((match = animationNameRe.exec(css)) !== null) {
    if (animations.indexOf(match[1]) < 0) animations.push(match[1]);
  }
  var slug = slugify(parent);
  animations.forEach(function (name) {
    var newName = (o.keyframes === true ? slug + '-' : typeof o.keyframes === 'string' ? o.keyframes : '') + name;
    css = css.replace(new RegExp('(@keyframes\\s+)' + name + '(\\s*{)', 'g'), '$1' + newName + '$2');
    css = css.replace(new RegExp('(animation(?:-name)?\\s*:[^;]*\\s*)' + name + '([\\s;}])', 'g'), '$1' + newName + '$2');
  });
  //animation: revoke wrongly replaced keyframes
  css = css.replace(new RegExp('(' + parentRe + ' )(\\s*(?:to|from|[+-]?(?:(?:\\.\\d+)|(?:\\d+(?:\\.\\d*)?))%))(?=[\\s\\r\\n,{])', 'g'), '$2');
  return css;
}
function replace(css, replacer) {
  var arr = [];
  css = stripComments(css);

  // escape strings etc.
  css = escaper.replace(css, true, arr);
  css = css.replace(/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/g, replacer);

  // insert comments, strings etc. back
  css = escaper.paste(css, arr);
  return css;
}
var scopeCss$1 = scopeCss;

class TradePanel {
    quantity;
    constructor() {
        this.quantity = 0;
    }
    async loadStyle(elementSelector) {
        console.log(elementSelector);
        const existingLinkTag = document.getElementById("liminal-market-css");
        if (!existingLinkTag) {
            let picoStream = await (await fetch("https://app.liminal.market/css/pico/pico.min.css")).text();
            let picoCss = scopeCss$1(picoStream, elementSelector)
                .replace(/:root/g, `:is(${elementSelector} > *)`);
            let liminalStream = await (await fetch("https://app.liminal.market/css/style.css")).text();
            let liminalCss = scopeCss$1(liminalStream, elementSelector)
                .replace(/:root/g, `:is(${elementSelector} > *)`);
            document.head.insertAdjacentHTML("beforeend", `
          <style>
             ${picoCss}
             ${liminalCss}
          </style>
        `);
        }
    }
    async render(elementSelector, symbol, name, logo, address) {
        WidgetGlobals.elementSelector = elementSelector;
        let element = document.querySelector(elementSelector);
        if (!element)
            return;
        await this.loadStyle(elementSelector);
        let contractInfo = ContractInfo.getContractInfo(WidgetGlobals.Network.Name);
        let sellTradeInput = new TradePanelInput("aUSD", "aUSD at Broker", "/img/ausd.png", contractInfo.AUSD_ADDRESS, TradeType.Sell);
        let buyTradeInput;
        if (!symbol) {
            buyTradeInput = new TradePanelInput("Select stock", "", "", "", TradeType.Buy);
        }
        else {
            buyTradeInput = new TradePanelInput(symbol, name, logo, address, TradeType.Buy);
        }
        sellTradeInput.setOtherTradePanelInput(buyTradeInput);
        buyTradeInput.setOtherTradePanelInput(sellTradeInput);
        let tradeSwitch = new TradeSwitch();
        let executeOrderButton = new ExecuteOrderButton(sellTradeInput, buyTradeInput);
        let orderProgress = OrderProgress.getInstance();
        let sellInput = sellTradeInput.renderToString();
        let buyInput = buyTradeInput.renderToString();
        let switchHtml = tradeSwitch.renderToString();
        let executeOrderButtonHtml = executeOrderButton.renderToString();
        let orderProgressHtml = orderProgress.renderToString();
        element.innerHTML =
            sellInput +
                switchHtml +
                buyInput +
                switchHtml +
                executeOrderButtonHtml +
                orderProgressHtml;
        await sellTradeInput.loadBalance();
        await buyTradeInput.loadBalance();
        if (symbol) {
            await buyTradeInput.loadLastTrade();
        }
        sellTradeInput.bindEvents();
        buyTradeInput.bindEvents();
        await executeOrderButton.renderButton();
        tradeSwitch.bindEvents(sellTradeInput, buyTradeInput, executeOrderButton);
        sellTradeInput.onUpdate = () => {
            if (buyTradeInput.isDirty)
                buyTradeInput.updatePanel();
            executeOrderButton.renderButton();
        };
        buyTradeInput.onUpdate = () => {
            if (sellTradeInput.isDirty)
                sellTradeInput.updatePanel();
            executeOrderButton.renderButton();
        };
    }
    formatBuyPanel(symbol, name, logo, tradeType, contractAddress) {
        document.getElementById("liminal_market_select_symbol").innerHTML = symbol;
    }
}

class TradePanelWidget {
    constructor() {
        WidgetGlobals.HandlebarsInstance = Handlebars;
        WidgetGlobals.Network = NetworkInfo.getInstance();
        WidgetGlobals.User = new User(null, "", WidgetGlobals.Network.ChainId, "");
        EventService.register();
    }
    async render(elementSelector, symbol, name, logo, address) {
        let authenticationService = new AuthenticateService();
        await authenticationService.isAuthenticated();
        new TradePanel().render(elementSelector, symbol, name, logo, address);
    }
}

export { TradePanelWidget };
